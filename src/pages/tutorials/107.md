---
layout: ../../layouts/tutorial/TextTutorial.astro
title: 'How to Create "SystemInfo" App'
description: "This tutorial shows how easy it is to extend existing watch functions to display information provided by the Tizen.System.Battery API."
created: "2018/06/31"
modified: "2020/04/19"
profile: ["wearable"]
type: "dotnet"
level: 3
state: "open"
thumbnail: "/assets/images/tutorials/107/SystemInfoThumbnail.png"
---

#

# I. INTRODUCTION

## 1. Overview

In this tutorial, we will work on the SystemInfo application which uses Tizen.System API to obtain data provided by the system in order to present it on the screen. The goal is to extend its functionality with the ability of displaying information provided by the Tizen.System.Battery API.



To make it easier, in the following pages of this chapter we will look at how the application works and show you how to get and display the information provided by the API.



First, take a look at final version of the application. The application’s UI consists of multiple pages, each of which contains a list of items reflecting a group of system information.



<img src="/assets/images/tutorials/107/main_page.png" style="height:360px; width:360px"/>



<img src="/assets/images/tutorials/107/battery_page.png" style="height:360px; width:360px"/>



<img src="/assets/images/tutorials/107/display_page.png" style="height:360px; width:360px"/>



<img src="/assets/images/tutorials/107/led_page.png" style="height:360px; width:360px"/>



<img src="/assets/images/tutorials/107/vibrator_page.png" style="height:360px; width:360px"/>



<img src="/assets/images/tutorials/107/usb_page.png" style="height:360px; width:360px"/>



<img src="/assets/images/tutorials/107/capabilities_page.png" style="height:360px; width:360px"/>



<img src="/assets/images/tutorials/107/settings_page.png" style="undefined"/>



The application uses Tizen Wearable CircularUI extension of the Xamarin Forms framework to easily adjust its appearance to the wearable profile.



Content of this tutorial is under [Flora](http://floralicense.org/license) license.

## 2. Importing and building solution

In this step, we will import and build Visual Studio solution containing initial application code.



Step 1: Download and unpack [system-info.zip](https://s3-us-west-1.amazonaws.com/tizenschool/107/system-info.zip) file.



Step 2: Click File > Open > Project/Solution...

<img src="/assets/images/tutorials/107/step2frame2.png" style="height:889px; width:1300px"/>



Step 3: Go to downloaded directory and select SystemInfo.sln file (Microsoft Visual Studio Solution), then click the "Open" button.

<img src="/assets/images/tutorials/107/step3frame2.png" style="height:889px; width:1300px"/>

The solution structure should appear in the Solution Explorer view. It should contain two projects: SystemInfo and SystemInfo.Tizen.Wearable.

<img src="/assets/images/tutorials/107/step3_2frame2.png" style="height:889px; width:1300px"/>



Step 4: Right click on the solution and select "Restore NuGet Packages" from the context menu. This will set up NuGet packages for all projects.

<img src="/assets/images/tutorials/107/step4frame2.png" style="height:889px; width:1300px"/>



Step 5: Right click on the solution again and select "Clean Solution" from the context menu.

<img src="/assets/images/tutorials/107/step5frame2.png" style="height:889px; width:1300px"/>



Step 6: Right click on the solution again and select "Rebuild Solution" from the context menu.

<img src="/assets/images/tutorials/107/step6frame2.png" style="height:889px; width:1300px"/>



Step 7: Right click on the "SystemInfo.Tizen.Wearable" project and select "Set as StartUp Project" from the context menu.

<img src="/assets/images/tutorials/107/step7frame2.png" style="height:889px; width:1300px"/>

Right now the application can be run on the emulator or target device. We will start with base version of the application. It is complete and working application that allows you to view almost all information provided by the Tizen System API.

<img src="/assets/images/tutorials/107/step7_2.PNG" style="undefined"/>

As you can see the current version of application does not support displaying battery properties. We will implement this feature during this tutorial.

## 3. Application structure

The application source code has been organized so that it can be easily extended to other platforms and devices.

<img src="/assets/images/tutorials/107/stepXXX.png" style="height:329px; width:235px"/>

As you can see the main solution is divided into two parts:

To access platform specific functionality from the shared code the application uses DependencyService mechanism. In practice, the application defines an interface in the portable part and the DependencyService finds the correct implementation of that interface from the various platform projects.

## 4. Main page with list of system information categories

In this tutorial's part you will read how the application creates the main page with list of system information categories.



The layout of the application's main page is defined in the SystemInfo.Tizen.Wearable/View/MainPage class. The XAML part of the class uses the Tizen Wearable CircularUI extension of the Xamarin Forms framework to create the CirclePage with CircleListView in the content.

```xml
<?xml version="1.0" encoding="utf-8" ?>
<w:CirclePage xmlns="http://xamarin.com/schemas/2014/forms"
              xmlns:x="http://schemas.microsoft.com/winfx/2009/xaml"
              xmlns:w="clr-namespace:Tizen.Wearable.CircularUI.Forms;assembly=Tizen.Wearable.CircularUI.Forms"
              x:Class="SystemInfo.Tizen.Wearable.View.MainPage"
              NavigationPage.HasNavigationBar="False"
              RotaryFocusObject="{x:Reference listView}">

    <w:CirclePage.Content>
        <w:CircleListView x:Name="listView"
                          Header="System Info"
                          ItemsSource="{Binding .}"
                          IsGroupingEnabled="True">
            <w:CircleListView.HeaderTemplate>
                <DataTemplate>
                    <Label Text="{Binding .}"
                           FontAttributes="Bold"
                           TextColor="Aqua"
                           FontSize="12"
                           HorizontalTextAlignment="Center" />
                </DataTemplate>
            </w:CircleListView.HeaderTemplate>
            <w:CircleListView.GroupHeaderTemplate>
                <DataTemplate>
                    <TextCell Text="{Binding Name}" />
                </DataTemplate>
            </w:CircleListView.GroupHeaderTemplate>
            <w:CircleListView.ItemTemplate>
                <DataTemplate>
                    <TextCell Text="{Binding Title}"
                              Command="{Binding OnTap}" />
                </DataTemplate>
            </w:CircleListView.ItemTemplate>
        </w:CircleListView>
    </w:CirclePage.Content>

</w:CirclePage>
```

The CircleListView defines three templates:



In the code behind the application creates the BindingContext in the **MainPage** class constructor.

```csharp
using System.Collections.ObjectModel;
using SystemInfo.ViewModel;
using Tizen.Wearable.CircularUI.Forms;
using Xamarin.Forms.Xaml;

namespace SystemInfo.Tizen.Wearable.View
{
    /// <summary>
    /// Main page of the application. Shows application's main menu.
    /// </summary>
    [XamlCompilation(XamlCompilationOptions.Compile)]
    public partial class MainPage : CirclePage
    {
        #region methods

        /// <summary>
        /// Default class constructor.
        /// Initializes page component.
        /// </summary>
        public MainPage()
        {
            BindingContext = PrepareMainMenuItems();

            InitializeComponent();
        }

        /// <summary>
        /// Returns main menu items grouped by their type.
        /// </summary>
        /// <returns>Main menu items.</returns>
        private ObservableCollection<MenuItemsCollection> PrepareMainMenuItems()
        {
            return new ObservableCollection<MenuItemsCollection>
            {
                new MenuItemsCollection(new PropertyViewModel().PropertiesCollection)
                {
                    Name = "Properties"
                },
                new MenuItemsCollection(new OtherViewModel().PropertiesCollection)
                {
                    Name = "Other"
                }
            };
        }

        #endregion
    }
}
```

The  **PrepareMainMenuItems** method, which is responsible for it, returns ObservableCollection of **MenuItemsCollection** instances grouped by their type. The Name property of each item of the final collection is displayed in the application UI as a name of items group.



Let's take a look at elements of such a collection on the example of data provided by the **PropertyViewModel** class.

```csharp
using System.Collections.ObjectModel;
using SystemInfo.Utils;
using SystemInfo.ViewModel.List;

namespace SystemInfo.ViewModel
{
    /// <summary>
    /// ViewModel class for property page.
    /// </summary>
    public class PropertyViewModel : ViewModelBase
    {
        #region fields

        /// <summary>
        /// List of content of property page.
        /// </summary>
        public static readonly string[] Properties = { "Display", "LED", "Vibrator", "USB" };

        /// <summary>
        /// Local storage of property page content.
        /// </summary>
        private ObservableCollection<ItemViewModel> _propertiesCollection;

        #endregion

        #region properties

        /// <summary>
        /// Gets or sets property page content.
        /// </summary>
        public ObservableCollection<ItemViewModel> PropertiesCollection
        {
            get => _propertiesCollection;
            set => SetProperty(ref _propertiesCollection, value);
        }

        #endregion

        #region methods

        /// <summary>
        /// Default class constructor.
        /// </summary>
        public PropertyViewModel()
        {
            PropertiesCollection = ListUtils.CreateItemsListWithNavigation(Properties);
        }

        #endregion
    }
}
```

As you can see, the **PropertiesCollection** of **ItemViewModel** items is created in the class contructor. For that purpose, the application uses the **CreateItemsListWithNavigation** method of the **ListUtils** class and passes to it the  **Properties** array as an argument. Finally, the **PropertiesCollection** property should contain  **ItemViewModel** items with system information data describing Display, LED, Vibrator and USB.



Let's take a deeper look at how the list elements are created.

```csharp
using System.Collections.ObjectModel;
using System.Windows.Input;
using SystemInfo.ViewModel.List;
using Xamarin.Forms;

namespace SystemInfo.Utils
{
    /// <summary>
    /// Class that contains methods for creating different list items.
    /// </summary>
    public static class ListUtils
    {
        #region fields

        /// <summary>
        /// Navigation context.
        /// </summary>
        private static readonly INavigation Navigation;

        #endregion

        #region methods

        /// <summary>
        /// Default class constructor.
        /// </summary>
        static ListUtils()
        {
            Navigation = Application.Current.MainPage?.Navigation;
        }

        /// <summary>
        /// Creates and populates observable collection of items. Each item navigate to another page.
        /// </summary>
        /// <param name="properties">Titles of items.</param>
        /// <returns>Collection of items with navigation.</returns>
        public static ObservableCollection<ItemViewModel> CreateItemsListWithNavigation(string[] properties)
        {
            var itemCollection = new ObservableCollection<ItemViewModel>();

            foreach (var property in properties)
            {
                itemCollection.Add(new ItemViewModel(property, CreateItemCommand(PageProvider.CreatePage(property))));
            }

            return itemCollection;
        }

        /// <summary>
        /// Creates observable, grouped collection of items with initial values.
        /// </summary>
        /// <param name="titles">Titles of items.</param>
        /// <param name="groupName">Group name.</param>
        /// <param name="initialValues">Initial values of items.</param>
        /// <returns>Collection of items with initial values.</returns>
        public static ListItem CreateGroupedItemsList(string[] titles, string groupName, string[] initialValues)
        {
            var list = CreateItemsList(titles, initialValues, ListItemType.Standard);
            list.GroupName = groupName;

            return list;
        }

        /// <summary>
        /// Creates observable collection of items with initial values. All items has common type.
        /// </summary>
        /// <param name="titles">Titles of items.</param>
        /// <param name="initialValues">Initial values of items.</param>
        /// <param name="itemType">Common type for all types.</param>
        /// <returns>Collection of items with initial values.</returns>
        public static ListItem CreateItemsList(string[] titles, string[] initialValues, ListItemType itemType)
        {
            var itemCollection = new ListItem();

            for (int i = 0; i < titles.Length; i++)
            {
                itemCollection.Add(new ItemViewModel(titles[i], new Command(() => { }, () => false), initialValues[i],
                    itemType));
            }

            return itemCollection;
        }

        /// <summary>
        /// Creates observable collection of items with initial values. The type must be specified for each item.
        /// </summary>
        /// <param name="titles">Titles of items.</param>
        /// <param name="initialValues">Initial values of items.</param>
        /// <param name="itemsType">Items' type.</param>
        /// <returns>Collection of list items.</returns>
        public static ListItem CreateItemsList(string[] titles, string[] initialValues, ListItemType[] itemsType)
        {
            var itemCollection = new ListItem();

            for (int i = 0; i < titles.Length; i++)
            {
                itemCollection.Add(new ItemViewModel(titles[i], new Command(() => { }, () => false), initialValues[i],
                    itemsType[i]));
            }

            return itemCollection;
        }

        /// <summary>
        /// Creates command for item, that navigate to another page.
        /// </summary>
        /// <param name="page">Page that will be pushed to navigation stack.</param>
        /// <returns>Command object.</returns>
        private static ICommand CreateItemCommand(Page page)
        {
            return new Command(() => { Navigation.PushAsync(page); }, () => true);
        }

        #endregion
    }
}
```

The **CreateItemsListWithNavigation** method of the  **ListUtils** class returns ObservableCollection of  **ItemViewModel** instances. It iterates through the properties names and for each element adds new instance of **ItemViewModel** class to created collection.



The  **ItemViewModel**  class presented on the code snippet below contains **Title** and **OnTap**  properties which are binded to the application UI and are responsible for list item appearence (label text) and behaviour (tap action).

```csharp
using System.Windows.Input;
using SystemInfo.Utils;

namespace SystemInfo.ViewModel.List
{
    /// <summary>
    /// ViewModel class for single list's item.
    /// </summary>
    public class ItemViewModel : ViewModelBase
    {
        #region fields

        /// <summary>
        /// Local storage of item's description.
        /// </summary>
        private string _description;

        #endregion

        #region properties

        /// <summary>
        /// Gets item's title.
        /// </summary>
        public string Title { get; }

        /// <summary>
        /// Gets item's type.
        /// </summary>
        public ListItemType ListItemType { get; }

        /// <summary>
        /// Gets or sets item's description.
        /// </summary>
        public string Description
        {
            get => _description;
            set => SetProperty(ref _description, value);
        }

        /// <summary>
        /// Gets command executed when item is tapped.
        /// </summary>
        public ICommand OnTap { get; }

        #endregion

        #region methods

        /// <summary>
        /// Class constructor.
        /// </summary>
        /// <param name="title">Title of the item.</param>
        /// <param name="onTap">On tap command.</param>
        /// <param name="description">Description of the item.</param>
        /// <param name="listItemType">Type of the item.</param>
        public ItemViewModel(string title, ICommand onTap, string description = "",
            ListItemType listItemType = ListItemType.Standard)
        {
            Title = title;
            Description = description;
            OnTap = onTap;
            ListItemType = listItemType;
        }

        #endregion
    }
}
```



## 5. Navigating to properties pages

In this tutorial's part you can read how the application obtains information necessary to create navigation between pages.



Let's take a look again at the **CreateItemsListWithNavigation** method of the **ListUtils** class.

```csharp
using System.Collections.ObjectModel;
using System.Windows.Input;
using SystemInfo.ViewModel.List;
using Xamarin.Forms;

namespace SystemInfo.Utils
{
    /// <summary>
    /// Class that contains methods for creating different list items.
    /// </summary>
    public static class ListUtils
    {
        #region fields

        /// <summary>
        /// Navigation context.
        /// </summary>
        private static readonly INavigation Navigation;

        #endregion

        #region methods

        /// <summary>
        /// Default class constructor.
        /// </summary>
        static ListUtils()
        {
            Navigation = Application.Current.MainPage?.Navigation;
        }

        /// <summary>
        /// Creates and populates observable collection of items. Each item navigate to another page.
        /// </summary>
        /// <param name="properties">Titles of items.</param>
        /// <returns>Collection of items with navigation.</returns>
        public static ObservableCollection<ItemViewModel> CreateItemsListWithNavigation(string[] properties)
        {
            var itemCollection = new ObservableCollection<ItemViewModel>();

            foreach (var property in properties)
            {
                itemCollection.Add(new ItemViewModel(property, CreateItemCommand(PageProvider.CreatePage(property))));
            }

            return itemCollection;
        }

        /// <summary>
        /// Creates observable, grouped collection of items with initial values.
        /// </summary>
        /// <param name="titles">Titles of items.</param>
        /// <param name="groupName">Group name.</param>
        /// <param name="initialValues">Initial values of items.</param>
        /// <returns>Collection of items with initial values.</returns>
        public static ListItem CreateGroupedItemsList(string[] titles, string groupName, string[] initialValues)
        {
            var list = CreateItemsList(titles, initialValues, ListItemType.Standard);
            list.GroupName = groupName;

            return list;
        }

        /// <summary>
        /// Creates observable collection of items with initial values. All items has common type.
        /// </summary>
        /// <param name="titles">Titles of items.</param>
        /// <param name="initialValues">Initial values of items.</param>
        /// <param name="itemType">Common type for all types.</param>
        /// <returns>Collection of items with initial values.</returns>
        public static ListItem CreateItemsList(string[] titles, string[] initialValues, ListItemType itemType)
        {
            var itemCollection = new ListItem();

            for (int i = 0; i < titles.Length; i++)
            {
                itemCollection.Add(new ItemViewModel(titles[i], new Command(() => { }, () => false), initialValues[i],
                    itemType));
            }

            return itemCollection;
        }

        /// <summary>
        /// Creates observable collection of items with initial values. The type must be specified for each item.
        /// </summary>
        /// <param name="titles">Titles of items.</param>
        /// <param name="initialValues">Initial values of items.</param>
        /// <param name="itemsType">Items' type.</param>
        /// <returns>Collection of list items.</returns>
        public static ListItem CreateItemsList(string[] titles, string[] initialValues, ListItemType[] itemsType)
        {
            var itemCollection = new ListItem();

            for (int i = 0; i < titles.Length; i++)
            {
                itemCollection.Add(new ItemViewModel(titles[i], new Command(() => { }, () => false), initialValues[i],
                    itemsType[i]));
            }

            return itemCollection;
        }

        /// <summary>
        /// Creates command for item, that navigate to another page.
        /// </summary>
        /// <param name="page">Page that will be pushed to navigation stack.</param>
        /// <returns>Command object.</returns>
        private static ICommand CreateItemCommand(Page page)
        {
            return new Command(() => { Navigation.PushAsync(page); }, () => true);
        }

        #endregion
    }
}
```

The  **ItemViewModel** class constructor takes two parameters, which define items name and items tap action. In order to define proper page to which the application should navigate to, the application uses the  **CreateItemCommand** method. This method takes **Page** object as an argument returned by **CreatePage** method of the **PageProvider** class and returns new command to be executed every time the item is tapped.

```csharp
using SystemInfo.View;
using Xamarin.Forms;

namespace SystemInfo.Utils
{
    /// <summary>
    /// Helper class that provides application's pages.
    /// </summary>
    public static class PageProvider
    {
        #region methods

        /// <summary>
        /// Method that provides platform-specific pages.
        /// </summary>
        /// <param name="s">Title of page.</param>
        /// <returns>Returns page by its title. In case of unsupported title empty ContentPage will be returned.</returns>
        public static Page CreatePage(string s)
        {
            switch (s)
            {
                case "Display":
                    return DependencyService.Get<IPageResolver>().DisplayPage;
                case "USB":
                    return DependencyService.Get<IPageResolver>().UsbPage;
                case "Capabilities":
                    return DependencyService.Get<IPageResolver>().CapabilitiesPage;
                case "Settings":
                    return DependencyService.Get<IPageResolver>().SettingsPage;
                case "LED":
                    return DependencyService.Get<IPageResolver>().LedPage;
                case "Vibrator":
                    return DependencyService.Get<IPageResolver>().VibratorPage;
                default:
                    return new ContentPage { Title = "Default " + s };
            }
        }

        #endregion
    }
}
```

To access the page classes, which are located in the profile specific part, the **CreatePage** method uses previously mentioned  **DependencyService** , which tries to find class which implements **IPageResolver** interface and provides necessary page properties.



The  **PageResolver**  class, which implements this interface provides all necessary public properties, which give access to references of the application pages.

```csharp
using SystemInfo.Tizen.Wearable.View;
using SystemInfo.View;
using Xamarin.Forms;

[assembly: Dependency(typeof(PageResolver))]
namespace SystemInfo.Tizen.Wearable.View
{
    /// <summary>
    /// Class that provides application with platform depended views.
    /// </summary>
    public class PageResolver : IPageResolver
    {
        #region fields

        /// <summary>
        /// Local storage of MainPage.
        /// </summary>
        private MainPage _mainPage;

        /// <summary>
        /// Local storage of CapabilitiesPage.
        /// </summary>
        private CapabilitiesPage _capabilitiesPage;

        /// <summary>
        /// Local storage of DisplayPage.
        /// </summary>
        private DisplayPage _displayPage;

        /// <summary>
        /// Local storage of LedPage.
        /// </summary>
        private LedPage _ledPage;

        /// <summary>
        /// Local storage of SettingsPage.
        /// </summary>
        private SettingsPage _settingsPage;

        /// <summary>
        /// Local storage of UsbPage.
        /// </summary>
        private UsbPage _usbPage;

        /// <summary>
        /// Local storage of VibratorPage.
        /// </summary>
        private VibratorPage _vibratorPage;

        #endregion

        #region Properties

        /// <summary>
        /// Gets MainPage.
        /// </summary>
        public Page MainPage => _mainPage ?? (_mainPage = new MainPage());

        /// <summary>
        /// Gets CapabilitiesPage.
        /// </summary>
        public Page CapabilitiesPage => _capabilitiesPage ?? (_capabilitiesPage = new CapabilitiesPage());

        /// <summary>
        /// Gets DisplayPage.
        /// </summary>
        public Page DisplayPage => _displayPage ?? (_displayPage = new DisplayPage());

        /// <summary>
        /// Gets LedPage.
        /// </summary>
        public Page LedPage => _ledPage ?? (_ledPage = new LedPage());

        /// <summary>
        /// Gets SettingsPage.
        /// </summary>
        public Page SettingsPage => _settingsPage ?? (_settingsPage = new SettingsPage());

        /// <summary>
        /// Gets UsbPage.
        /// </summary>
        public Page UsbPage => _usbPage ?? (_usbPage = new UsbPage());

        /// <summary>
        /// Gets VibratorPage.
        /// </summary>
        public Page VibratorPage => _vibratorPage ?? (_vibratorPage = new VibratorPage());

        #endregion
    }
}
```

## 6. Property page with list of system information data

In this tutorial's part you can read how the application obtains and displays information provided by the Tizen.System API. It is explained by the example of accessing and displaying LED status information.



The LED page layout is defined in the SystemInfo.Tizen.Wearable/View/LedPage class. As with the MainPage the XAML part of the class uses the Tizen Wearable CircularUI extension of the Xamarin Forms framework to create the CirclePage with CircleListView in the content.

```xml
<?xml version="1.0" encoding="utf-8" ?>
<w:CirclePage xmlns="http://xamarin.com/schemas/2014/forms"
              xmlns:x="http://schemas.microsoft.com/winfx/2009/xaml"
              xmlns:viewModel="clr-namespace:SystemInfo.ViewModel;assembly=SystemInfo"
              xmlns:control="clr-namespace:SystemInfo.Tizen.Wearable.Control;assembly=SystemInfo.Tizen.Wearable"
              xmlns:w="clr-namespace:Tizen.Wearable.CircularUI.Forms;assembly=Tizen.Wearable.CircularUI.Forms"
              x:Class="SystemInfo.Tizen.Wearable.View.LedPage"
              NavigationPage.HasNavigationBar="False"
              RotaryFocusObject="{x:Reference listView}">

    <w:CirclePage.BindingContext>
        <viewModel:LedViewModel />
    </w:CirclePage.BindingContext>

    <w:CirclePage.Content>
        <w:CircleListView x:Name="listView"
                          Header="LED"
                          ItemsSource="{Binding ItemList}">
            <w:CircleListView.HeaderTemplate>
                <DataTemplate>
                    <Label Text="{Binding .}"
                           FontAttributes="Bold"
                           TextColor="Aqua"
                           FontSize="13"
                           HorizontalTextAlignment="Center" />
                </DataTemplate>
            </w:CircleListView.HeaderTemplate>
            <w:CircleListView.ItemTemplate>
                <DataTemplate>
                    <control:TizenTextCell Text="{Binding Title}"
                                           Command="{Binding OnTap}"
                                           Detail="{Binding Description}" />
                </DataTemplate>
            </w:CircleListView.ItemTemplate>
        </w:CircleListView>
    </w:CirclePage.Content>

</w:CirclePage>
```

The CircleListView defines two templates:



Additionally the SystemInfo/ViewModel/LedViewModel class is initialized as the BindingContext.

```csharp
using SystemInfo.Model.Led;
using SystemInfo.Utils;

namespace SystemInfo.ViewModel
{
    /// <summary>
    /// ViewModel class for LED page.
    /// </summary>
    public class LedViewModel : ViewModelBase
    {
        #region fields

        /// <summary>
        /// Properties of device's LED.
        /// </summary>
        public static readonly string[] Properties = { "Max Brightness", "Brightness" };

        /// <summary>
        /// Local storage of device's LED properties.
        /// </summary>
        private ListItem _itemList;

        #endregion

        #region properties

        /// <summary>
        /// Gets or sets device's LED properties.
        /// </summary>
        public ListItem ItemList
        {
            get => _itemList;
            set => SetProperty(ref _itemList, value);
        }

        #endregion

        #region methods

        /// <summary>
        /// Default class constructor.
        /// </summary>
        public LedViewModel()
        {
            var led = new Led();

            string[] initialValues =
            {
                led.MaxBrightness.ToString(),
                led.Brightness.ToString()
            };

            ItemList = ListUtils.CreateItemsList(Properties, initialValues, ListItemType.Standard);

            led.LedChanged += OnLedChanged;
        }

        /// <summary>
        /// Updates LED's brightness.
        /// </summary>
        /// <param name="s">Object that sent event.</param>
        /// <param name="e">Event's argument.</param>
        private void OnLedChanged(object s, LedEventArgs e)
        {
            ItemList["Brightness"] = e.Brightness.ToString();
        }

        #endregion
    }
}
```

The LedViewModel class provides  **ItemList** property of  **ListItem** type, which is used as item source for the **CircleListView** element on the **LedPage** . It is an ObservableCollection of ItemViewModel items with additional ability of returning item description by its title.

```csharp
using System.Collections.ObjectModel;
using System.Linq;
using SystemInfo.ViewModel.List;

namespace SystemInfo.Utils
{
    /// <summary>
    /// Observable collection of items. It allows to build groups in ListView.
    /// </summary>
    public class ListItem : ObservableCollection<ItemViewModel>
    {
        #region properties

        /// <summary>
        /// Gets or sets group name.
        /// </summary>
        public string GroupName { get; set; } = "";

        /// <summary>
        /// Gets or sets single item's description by its title.
        /// </summary>
        /// <param name="s">Title of the item.</param>
        /// <returns>Item's description.</returns>
        public string this[string s]
        {
            get => GetItemByTitle(s).Description;
            set => GetItemByTitle(s).Description = value;
        }

        #endregion

        #region methods

        /// <summary>
        /// Search for specific item by its title.
        /// </summary>
        /// <param name="title">Item's title.</param>
        /// <returns>If item with given title is found, function returns that item, otherwise returns null.</returns>
        private ItemViewModel GetItemByTitle(string title)
        {
            return this.FirstOrDefault(item => item.Title.Equals(title));
        }

        #endregion
    }
}
```



The constructor of the LedViewModel class creates an instance of the **Led** model class, and uses provided data to initialize the  **ItemList** collection. All items are created based on the array defined in the **Properties** property. The constructor also defines an event handler of the  **LedChanged** event provided by the **Led** model, which updates the **Brightness** item of the **ItemList** property every time it occurs.



But how the **Led** model obtains the required data?



```csharp
using System;
using Xamarin.Forms;

namespace SystemInfo.Model.Led
{
    /// <summary>
    /// Class that holds information about LED.
    /// </summary>
    public class Led
    {
        #region fields

        /// <summary>
        /// Service that provides information about LED.
        /// </summary>
        private readonly ILed _service;

        #endregion

        #region properties

        /// <summary>
        /// Gets LED's max brightness.
        /// </summary>
        public int MaxBrightness => _service.MaxBrightness;

        /// <summary>
        /// Gets LED's brightness.
        /// </summary>
        public int Brightness => _service.Brightness;

        /// <summary>
        /// Event invoked when LED's brightness has changed.
        /// </summary>
        public event EventHandler<LedEventArgs> LedChanged;

        #endregion

        #region methods

        /// <summary>
        /// Default class constructor.
        /// </summary>
        public Led()
        {
            _service = DependencyService.Get<ILed>();

            _service.StartListening();

            _service.LedChanged += (s, e) => { OnLedChanged(e); };
        }

        /// <summary>
        /// Invokes LedChanged event.
        /// </summary>
        /// <param name="e">Arguments passed with event.</param>
        protected virtual void OnLedChanged(LedEventArgs e)
        {
            LedChanged?.Invoke(this, e);
        }

        #endregion
    }
}
```



The **Led** model class provides LED information describing current and maximum brightness. It also notifies application about LED parameters changes.



To access the Tizen.System.Led API it uses the DependencyService, which finds the **LedService** class (from platform/profile specific part of the project) implementing the **ILed** interface.

```csharp
using System;
using SystemInfo.Model.Led;
using SystemInfo.Tizen.Wearable.Service;
using Led = Tizen.System.Led;

[assembly: Xamarin.Forms.Dependency(typeof(LedService))]
namespace SystemInfo.Tizen.Wearable.Service
{
    /// <summary>
    /// Provides methods that allow to obtain information about device's LED.
    /// </summary>
    public class LedService : ILed
    {
        #region properties

        /// <summary>
        /// LED's max brightness.
        /// </summary>
        public int MaxBrightness => Led.MaxBrightness;

        /// <summary>
        /// LED's brightness.
        /// </summary>
        public int Brightness => Led.Brightness;

        /// <summary>
        /// Event invoked when LED's brightness has changed.
        /// </summary>
        public event EventHandler<LedEventArgs> LedChanged;

        #endregion

        #region methods

        /// <summary>
        /// Starts observing LED's brightness for changes.
        /// </summary>
        /// <remarks>
        /// Event LedChanged will be never invoked before calling this method.
        /// </remarks>
        public void StartListening()
        {
            Led.BrightnessChanged += (s, e) => { LedChanged?.Invoke(s, new LedEventArgs(e.Brightness)); };
        }

        #endregion
    }
}
```

The  **LedService** class provides two public properties ( **Brightness** and **MaxBrightness** ), each of which provides proper value directly from Tizen.System.Led object.



When the **StartListening** method is executed, the application attaches handler to the **Tizen.System.Led.BrightnessChanged** event. When this event is handled, the application invokes the **LedChanged** event providing an instance of the **LedEventArgs** class, which contains current value of the LED brightness.

```csharp
namespace SystemInfo.Model.Led
{
    /// <summary>
    /// Class that is passed with LedChanged event.
    /// </summary>
    public class LedEventArgs
    {
        #region properties

        /// <summary>
        /// Gets LED's brightness.
        /// </summary>
        public int Brightness { get; }

        #endregion

        #region methods

        /// <summary>
        /// Class constructor that allows to set LED's brightness.
        /// </summary>
        /// <param name="brightness">LED's brightness.</param>
        public LedEventArgs(int brightness)
        {
            Brightness = brightness;
        }

        #endregion
    }
}
```

## 7. Summary

On the previous pages of this chapter we looked at the application structure.



Now, it will be easier to expand the application's functionality with the ability of displaying information provided by the Tizen.System.Battery API.



To start development go to the next chapter.

# II. BATTERY PROPERTY

## 1. Goal

In this chapter we will extend the application functionality with the ability of displaying information provided by the Tizen.System.Battery API.



The task requires making changes to the existing files responsible for:



At the end of this chapter the application you develop should support displaying battery properties.

<img src="/assets/images/tutorials/107/BatteryProperty_step1_1.PNG" style="undefined"/>

## 2. Battery Model

We have to implement  **SystemInfo/Model/Battery/Battery**  class, which allows the application to use properties describing battery state.



This class will access battery service using the **DependencyService** and **SystemInfo/Model/Battery/IBattery** interface, so that we also have to implement this interface as well as two other classes ( **SystemInfo/Model/Battery/BatteryEventArgs** and **SystemInfo/Model/Battery/BatteryLevelStatus** ), which are used by it.



Step 1: Implement **BatteryLevelStatus** enum that defines all possible battery statuses.

<highlight>8-31</highlight>

```csharp
namespace SystemInfo.Model.Battery
{
    /// <summary>
    /// Enumerator that contains all statuses of battery.
    /// </summary>
    public enum BatteryLevelStatus
    {
        /// <summary>
        /// Battery is empty.
        /// </summary>
        Empty = 0,

        /// <summary>
        /// Battery level is critical.
        /// </summary>
        Critical = 1,

        /// <summary>
        /// Battery level is low.
        /// </summary>
        Low = 2,

        /// <summary>
        /// Battery level is high.
        /// </summary>
        High = 3,

        /// <summary>
        /// Battery is full.
        /// </summary>
        Full = 4
    }
}

```



Step 2: Implement **BatteryEventArgs** class the instance of which is sent with event invoked when some information about battery are changed.

<highlight>8-42</highlight>

```csharp
namespace SystemInfo.Model.Battery
{
    /// <summary>
    /// Class that is passed with BatteryInfoChanged event.
    /// </summary>
    public class BatteryEventArgs : System.EventArgs
    {
        #region properties

        /// <summary>
        /// Gets battery level.
        /// </summary>
        public int BatteryLevel { get; }

        /// <summary>
        /// Gets charging status.
        /// </summary>
        public bool IsCharging { get; }

        /// <summary>
        /// Gets battery level status.
        /// </summary>
        public BatteryLevelStatus BatteryLevelStatus { get; }

        #endregion

        #region methods

        /// <summary>
        /// Class constructor that allows to set values describing battery information.
        /// </summary>
        /// <param name="batteryLevel">Battery level.</param>
        /// <param name="isCharging">Charging status.</param>
        /// <param name="batteryLevelStatus">Battery level status.</param>
        public BatteryEventArgs(int batteryLevel, bool isCharging, BatteryLevelStatus batteryLevelStatus)
        {
            BatteryLevel = batteryLevel;
            IsCharging = isCharging;
            BatteryLevelStatus = batteryLevelStatus;
        }

        #endregion
    }
}

```

The BatteryEventArgs class defines three properties describing battery state.



Step 3: Fill in **IBattery** interface that defines all necessary properties and methods to get information about battery.

<highlight>1, 10-44</highlight>

```csharp
using System;

namespace SystemInfo.Model.Battery
{
    /// <summary>
    /// Interface that contains all necessary methods to get information about battery.
    /// </summary>
    public interface IBattery
    {
        #region properties

        /// <summary>
        /// Gets charging status.
        /// </summary>
        bool IsCharging { get; }

        /// <summary>
        /// Gets battery level.
        /// </summary>
        int BatteryLevel { get; }

        /// <summary>
        /// Gets battery level status.
        /// </summary>
        BatteryLevelStatus BatteryLevelStatus { get; }

        /// <summary>
        /// Event invoked when some information about battery was changed.
        /// </summary>
        event EventHandler<BatteryEventArgs> BatteryInfoChanged;

        #endregion

        #region methods

        /// <summary>
        /// Starts observing battery information for changes.
        /// </summary>
        /// <remarks>
        /// Event BatteryInfoChanged will be never invoked before calling this method.
        /// </remarks>
        void StartListening();

        #endregion
    }
}

```



Step 4: Define **\_service** private field in the  **Battery** class. It will store a reference to the class implementing **IBattery** interface.

<highlight>8-16</highlight>

```csharp
namespace SystemInfo.Model.Battery
{
    /// <summary>
    /// Class that holds information about battery.
    /// </summary>
    public class Battery
    {
        #region fields

        /// <summary>
        /// Service that provides information about battery.
        /// </summary>
        private readonly IBattery _service;

        #endregion

        #region methods

        /// <summary>
        /// Default class constructor.
        /// </summary>
        public Battery()
        {
        }

        #endregion
    }
}

```



Step 5: Extend the  **Battery** class by defining four public properties.

<highlight>1, 18-41</highlight>

```csharp
using System;

namespace SystemInfo.Model.Battery
{
    /// <summary>
    /// Class that holds information about battery.
    /// </summary>
    public class Battery
    {
        #region fields

        /// <summary>
        /// Service that provides information about battery.
        /// </summary>
        private readonly IBattery _service;

        #endregion

        #region properties

        /// <summary>
        /// Event invoked when some information about battery was changed.
        /// </summary>
        public event EventHandler<BatteryEventArgs> BatteryChanged;

        /// <summary>
        /// Gets battery level.
        /// </summary>
        public int Level => _service.BatteryLevel;

        /// <summary>
        /// Gets charging status of battery.
        /// </summary>
        public bool IsCharging => _service.IsCharging;

        /// <summary>
        /// Gets battery level status.
        /// </summary>
        public BatteryLevelStatus BatteryLevelStatus => _service.BatteryLevelStatus;

        #endregion

        #region methods

        /// <summary>
        /// Default class constructor.
        /// </summary>
        public Battery()
        {
        }

        #endregion
    }
}

```



Step 6: Extend the Battery class by implementing its constructor and a handler of the **BatteryInfoChanged** event.

<highlight>2, 51-54, 56-64</highlight>

```csharp
using System;
using Xamarin.Forms;

namespace SystemInfo.Model.Battery
{
    /// <summary>
    /// Class that holds information about battery.
    /// </summary>
    public class Battery
    {
        #region fields

        /// <summary>
        /// Service that provides information about battery.
        /// </summary>
        private readonly IBattery _service;

        #endregion

        #region properties

        /// <summary>
        /// Event invoked when some information about battery was changed.
        /// </summary>
        public event EventHandler<BatteryEventArgs> BatteryChanged;

        /// <summary>
        /// Gets battery level.
        /// </summary>
        public int Level => _service.BatteryLevel;

        /// <summary>
        /// Gets charging status of battery.
        /// </summary>
        public bool IsCharging => _service.IsCharging;

        /// <summary>
        /// Gets battery level status.
        /// </summary>
        public BatteryLevelStatus BatteryLevelStatus => _service.BatteryLevelStatus;

        #endregion

        #region methods

        /// <summary>
        /// Default class constructor.
        /// </summary>
        public Battery()
        {
            _service = DependencyService.Get<IBattery>();
            _service.StartListening();

            _service.BatteryInfoChanged += (s, e) => { OnBatteryChanged(e); };
        }

        /// <summary>
        /// Invokes BatteryInfoChanged event.
        /// </summary>
        /// <param name="e">Arguments passed with event.</param>
        protected virtual void OnBatteryChanged(BatteryEventArgs e)
        {
            BatteryChanged?.Invoke(this, e);
        }

        #endregion
    }
}

```



## 3. Battery Service

As it was mentioned, the  **SystemInfo/Model/Battery/Battery**  class uses the **DependencyService** mechanism to acces the battery service located in the platform/profile specific part of the project. So let's implement this service.



We have to implement  **SystemInfo.Tizen.Wearable/Service/BatteryService**  class. The class should implement the **IBattery** interface.



We should also extend the **SystemInfo.Tizen.Wearable/Service/EnumMapper** class, which is used by the service. The class creates mapping between platform and portable enumerators.



Step 1: Extend the **EnumMapper** class so that it could map **Tizen.System.Battery** enumerators to those used in the portable part of the project.

<highlight>18-23, 46-54, 75-84</highlight>

```csharp
using System.Collections.Generic;
using SystemInfo.Model.Settings;
using Tizen.System;

namespace SystemInfo.Tizen.Wearable.Service
{
    /// <summary>
    /// Class that creates mapping between platform and portable enumerators.
    /// </summary>
    public static class EnumMapper
    {
        #region fields

        /// <summary>
        /// Dictionary of display states.
        /// </summary>
        private static readonly Dictionary<DisplayState, Model.Display.DisplayState> DisplayStateDictionary;

        /// <summary>
        /// Dictionary of battery level statuses.
        /// </summary>
        private static readonly Dictionary<BatteryLevelStatus, Model.Battery.BatteryLevelStatus>
            BatteryLevelStatusDictionary;

        /// <summary>
        /// Dictionary of font sizes.
        /// </summary>
        private static readonly Dictionary<SystemSettingsFontSize, Model.Settings.FontSize> FontSizeDictionary;

        #endregion

        #region methods

        /// <summary>
        /// Default class constructor.
        /// Initializes dictionaries used for mapping.
        /// </summary>
        static EnumMapper()
        {
            DisplayStateDictionary = new Dictionary<DisplayState, Model.Display.DisplayState>
            {
                {DisplayState.Normal, Model.Display.DisplayState.Normal},
                {DisplayState.Dim, Model.Display.DisplayState.Dim},
                {DisplayState.Off, Model.Display.DisplayState.Off}
            };

            BatteryLevelStatusDictionary = new Dictionary<BatteryLevelStatus, Model.Battery.BatteryLevelStatus>
            {
                {BatteryLevelStatus.Empty, Model.Battery.BatteryLevelStatus.Empty},
                {BatteryLevelStatus.Critical, Model.Battery.BatteryLevelStatus.Critical},
                {BatteryLevelStatus.Low, Model.Battery.BatteryLevelStatus.Low},
                {BatteryLevelStatus.High, Model.Battery.BatteryLevelStatus.High},
                {BatteryLevelStatus.Full, Model.Battery.BatteryLevelStatus.Full}
            };

            FontSizeDictionary = new Dictionary<SystemSettingsFontSize, FontSize>
            {
                {SystemSettingsFontSize.Small, FontSize.Small},
                {SystemSettingsFontSize.Normal, FontSize.Normal},
                {SystemSettingsFontSize.Large, FontSize.Large},
                {SystemSettingsFontSize.Huge, FontSize.Huge},
                {SystemSettingsFontSize.Giant, FontSize.Giant}
            };
        }

        /// <summary>
        /// Returns unified display state, common for all supported platform.
        /// </summary>
        /// <param name="displayState">Platform depended display state.</param>
        /// <returns>Common for all supported platform display state.</returns>
        public static Model.Display.DisplayState DisplayStateMapper(DisplayState displayState)
        {
            return DisplayStateDictionary[displayState];
        }

        /// <summary>
        /// Returns unified battery level state, common for all supported platform.
        /// </summary>
        /// <param name="batteryLevelStatus">Platform depended battery level state.</param>
        /// <returns>Common for all supported platform battery level state.</returns>
        public static Model.Battery.BatteryLevelStatus BatteryLevelStatusMapper(BatteryLevelStatus batteryLevelStatus)
        {
            return BatteryLevelStatusDictionary[batteryLevelStatus];
        }

        /// <summary>
        /// Returns unified font size, common for all supported platform.
        /// </summary>
        /// <param name="systemSettingsFontSize">Platform depended font size.</param>
        /// <returns>Common for all supported platform font size.</returns>
        public static FontSize FontSizeMapper(SystemSettingsFontSize systemSettingsFontSize)
        {
            return FontSizeDictionary[systemSettingsFontSize];
        }

        #endregion
    }
}

```



Step 2: Extend **BatteryService**  class by implementing the **IBattery** interface.

<highlight>1-2, 4, 12, 14-77</highlight>

```csharp
using System;
using SystemInfo.Model.Battery;
using SystemInfo.Tizen.Wearable.Service;
using Battery = Tizen.System.Battery;

[assembly: Xamarin.Forms.Dependency(typeof(BatteryService))]
namespace SystemInfo.Tizen.Wearable.Service
{
    /// <summary>
    /// Provides methods that allow to obtain information about device's battery.
    /// </summary>
    public class BatteryService : IBattery
    {
        #region properties

        /// <summary>
        /// Gets battery level.
        /// </summary>
        public int BatteryLevel => Battery.Percent;

        /// <summary>
        /// Gets charging status.
        /// </summary>
        public bool IsCharging => Battery.IsCharging;

        /// <summary>
        /// Gets battery level status.
        /// </summary>
        public BatteryLevelStatus BatteryLevelStatus => EnumMapper.BatteryLevelStatusMapper(Battery.Level);

        /// <summary>
        /// Event invoked when some information about battery was changed.
        /// </summary>
        public event EventHandler<BatteryEventArgs> BatteryInfoChanged;

        #endregion

        #region methods

        /// <summary>
        /// Starts observing battery information for changes.
        /// </summary>
        /// <remarks>
        /// Event BatteryInfoChanged will be never invoked before calling this method.
        /// </remarks>
        public void StartListening()
        {
            Battery.PercentChanged += (s, e) =>
            {
                var batteryEventArgs = new BatteryEventArgs(e.Percent, IsCharging, BatteryLevelStatus);
                OnBatteryChanged(batteryEventArgs);
            };

            Battery.ChargingStateChanged += (s, e) =>
            {
                var batteryEventArgs = new BatteryEventArgs(BatteryLevel, e.IsCharging, BatteryLevelStatus);
                OnBatteryChanged(batteryEventArgs);
            };

            Battery.LevelChanged += (s, e) =>
            {
                var batteryEventArgs = new BatteryEventArgs(BatteryLevel, IsCharging,
                    EnumMapper.BatteryLevelStatusMapper(e.Level));
                OnBatteryChanged(batteryEventArgs);
            };
        }

        /// <summary>
        /// Battery property change handler.
        /// </summary>
        /// <param name="e">Event parameters.</param>
        protected virtual void OnBatteryChanged(BatteryEventArgs e)
        {
            BatteryInfoChanged?.Invoke(this, e);
        }

        #endregion
    }
}

```





## 4. Battery View Model

We have to implement view model class, which provides abstraction of the battery view exposing public properties and commands.



We will modify the **SystemInfo/ViewModel/BatteryViewModel** class of the project.



Step 1: Create **Properties** private field containing an array of strings, describing names of the battery properties, which values should be displayed by the application.

<highlight>8-16</highlight>

```csharp
​namespace SystemInfo.ViewModel
{
    /// <summary>
    /// ViewModel class for battery page.
    /// </summary>
    public class BatteryViewModel : ViewModelBase
    {
        #region fields

        /// <summary>
        /// Properties of device's battery.
        /// </summary>
        public static readonly string[] Properties = { "Percent", "Is Charging", "State" };

        #endregion

        #region methods

        /// <summary>
        /// Default class constructor.
        /// </summary>
        public BatteryViewModel()
        {
        }

        #endregion
    }
}

```



Step 2: Create **\_battery** private field that will store an instance of the battery model class.

<highlight>1, 16-20</highlight>

```csharp
using SystemInfo.Model.Battery;

namespace SystemInfo.ViewModel
{
    /// <summary>
    /// ViewModel class for battery page.
    /// </summary>
    public class BatteryViewModel : ViewModelBase
    {
        #region fields

        /// <summary>
        /// Properties of device's battery.
        /// </summary>
        public static readonly string[] Properties = { "Percent", "Is Charging", "State" };

        /// <summary>
        /// Data source.
        /// </summary>
        private readonly Battery _battery;

        #endregion

        #region methods

        /// <summary>
        /// Default class constructor.
        /// </summary>
        public BatteryViewModel()
        {
        }

        #endregion
    }
}

```



Step 3: Create **ItemList** public property and its private **\_itemList**  backing field. The ItemList property will be used as item source for the  **CircleListView**  element on the  **BatteryPage** .

<highlight>2, 22-26, 29-41</highlight>

```csharp
using SystemInfo.Model.Battery;​
using SystemInfo.Utils;

namespace SystemInfo.ViewModel
{
    /// <summary>
    /// ViewModel class for battery page.
    /// </summary>
    public class BatteryViewModel : ViewModelBase
    {
        #region fields

        /// <summary>
        /// Properties of device's battery.
        /// </summary>
        public static readonly string[] Properties = { "Percent", "Is Charging", "State" };

        /// <summary>
        /// Data source.
        /// </summary>
        private readonly Battery _battery;

        /// <summary>
        /// Local storage of collection of battery's properties.
        /// </summary>
        private ListItem _itemList;

        #endregion

        #region properties

        /// <summary>
        /// Gets or sets collection of battery's properties.
        /// </summary>
        public ListItem ItemList
        {
            get => _itemList;
            set => SetProperty(ref _itemList, value);
        }

        #endregion

        #region methods

        /// <summary>
        /// Default class constructor.
        /// </summary>
        public BatteryViewModel()
        {
        }

        #endregion
    }
}

```



Step 4: Extend the constructor by creating an instance of the **Battery** model class and adding handler of the provided **BatteryChanged** event.

<highlight>8-15</highlight>

```csharp
#region methods

/// <summary>
/// Default class constructor.
/// </summary>
public BatteryViewModel()
{
    _battery = new Battery();

    _battery.BatteryChanged += (s, e) =>
    {
        ItemList["Percent"] = e.BatteryLevel.ToString();
        ItemList["Is Charging"] = e.IsCharging.ToString();
        ItemList["State"] = e.BatteryLevelStatus.ToString();
    };
}

#endregion

```

Defined handler function ensures that the content of the list displayed on the battery page is updated every time the event occurs.



Step 5: Implement **CreateItems** method and execute it in the class constructor to initialize data that are necessary when the batery page is displayed.

<highlight>9, 18-33</highlight>

```csharp
#region methods

/// <summary>
/// Default class constructor.
/// </summary>
public BatteryViewModel()
{
    _battery = new Battery();
    ItemList = CreateItems();

    _battery.BatteryChanged += (s, e) =>
    {
        ItemList["Percent"] = e.BatteryLevel.ToString();
        ItemList["Is Charging"] = e.IsCharging.ToString();
        ItemList["State"] = e.BatteryLevelStatus.ToString();
    };
}

/// <summary>
/// Creates item list with battery's properties.
/// </summary>
/// <returns>List of list's items.</returns>
private ListItem CreateItems()
{
    string[] initialValues =
    {
        _battery.Level.ToString(), _battery.IsCharging.ToString(), _battery.BatteryLevelStatus.ToString()
    };

    ListItemType[] itemTypes = { ListItemType.WithProgress, ListItemType.Standard, ListItemType.Standard };

    return ListUtils.CreateItemsList(Properties, initialValues, itemTypes);
}

#endregion

```

## 5. Battery View

Once the view model is done, we can start implementing the view of the battery page.



But one more small change is needed in the view model. We need to update the **Properties** array of the **SystemInfo/ViewModel/PropertyViewModel** class by adding **Battery** string as the first element.



Next we will update the **SystemInfo/Utils/PageProvider** class and  **SystemInfo.Tizen.Wearable/View/PageResolver** class which implements **IPageResolver** interface.



Finally, we will extend the  **SystemInfo.Tizen.Wearable/View/BatteryPage.xaml** file, responsible for battery page layout.



Step 1: Update the **Properties** array of the **SystemInfo/ViewModel/PropertyViewModel** class.

<highlight>17</highlight>

```csharp
using System.Collections.ObjectModel;
using SystemInfo.Utils;
using SystemInfo.ViewModel.List;

namespace SystemInfo.ViewModel
{
    /// <summary>
    /// ViewModel class for property page.
    /// </summary>
    public class PropertyViewModel : ViewModelBase
    {
        #region fields

        /// <summary>
        /// List of content of property page.
        /// </summary>
        public static readonly string[] Properties = { "Battery", "Display", "LED", "Vibrator", "USB" };

        /// <summary>
        /// Local storage of property page content.
        /// </summary>
        private ObservableCollection<ItemViewModel> _propertiesCollection;

        #endregion

        #region properties

        /// <summary>
        /// Gets or sets property page content.
        /// </summary>
        public ObservableCollection<ItemViewModel> PropertiesCollection
        {
            get => _propertiesCollection;
            set => SetProperty(ref _propertiesCollection, value);
        }

        #endregion

        #region methods

        /// <summary>
        /// Default class constructor.
        /// </summary>
        public PropertyViewModel()
        {
            PropertiesCollection = ListUtils.CreateItemsListWithNavigation(Properties);
        }

        #endregion
    }
}

```



Step 2: Update the **SystemInfo.Tizen.Wearable/View/PageResolver** class ...

<highlight>19-23, 63-67</highlight>

```csharp
using SystemInfo.Tizen.Wearable.View;
using SystemInfo.View;
using Xamarin.Forms;

[assembly: Dependency(typeof(PageResolver))]
namespace SystemInfo.Tizen.Wearable.View
{
    /// <summary>
    /// Class that provides application with platform depended views.
    /// </summary>
    public class PageResolver : IPageResolver
    {
        #region fields

        /// <summary>
        /// Local storage of MainPage.
        /// </summary>
        private MainPage _mainPage;

        /// <summary>
        /// Local storage of BatteryPage.
        /// </summary>
        private BatteryPage _batteryPage;

        /// <summary>
        /// Local storage of CapabilitiesPage.
        /// </summary>
        private CapabilitiesPage _capabilitiesPage;

        /// <summary>
        /// Local storage of DisplayPage.
        /// </summary>
        private DisplayPage _displayPage;

        /// <summary>
        /// Local storage of LedPage.
        /// </summary>
        private LedPage _ledPage;

        /// <summary>
        /// Local storage of SettingsPage.
        /// </summary>
        private SettingsPage _settingsPage;

        /// <summary>
        /// Local storage of UsbPage.
        /// </summary>
        private UsbPage _usbPage;

        /// <summary>
        /// Local storage of VibratorPage.
        /// </summary>
        private VibratorPage _vibratorPage;

        #endregion

        #region Properties

        /// <summary>
        /// Gets MainPage.
        /// </summary>
        public Page MainPage => _mainPage ?? (_mainPage = new MainPage());

        /// <summary>
        /// Gets BatteryPage.
        /// </summary>
        public Page BatteryPage => _batteryPage ?? (_batteryPage = new BatteryPage());

        /// <summary>
        /// Gets CapabilitiesPage.
        /// </summary>
        public Page CapabilitiesPage => _capabilitiesPage ?? (_capabilitiesPage = new CapabilitiesPage());

        /// <summary>
        /// Gets DisplayPage.
        /// </summary>
        public Page DisplayPage => _displayPage ?? (_displayPage = new DisplayPage());

        /// <summary>
        /// Gets LedPage.
        /// </summary>
        public Page LedPage => _ledPage ?? (_ledPage = new LedPage());

        /// <summary>
        /// Gets SettingsPage.
        /// </summary>
        public Page SettingsPage => _settingsPage ?? (_settingsPage = new SettingsPage());

        /// <summary>
        /// Gets UsbPage.
        /// </summary>
        public Page UsbPage => _usbPage ?? (_usbPage = new UsbPage());

        /// <summary>
        /// Gets VibratorPage.
        /// </summary>
        public Page VibratorPage => _vibratorPage ?? (_vibratorPage = new VibratorPage());

        #endregion
    }
}

```

... and  **SystemInfo/View/IPageResolver** interface.

<highlight>16-20</highlight>

```csharp
using Xamarin.Forms;

namespace SystemInfo.View
{
    /// <summary>
    /// Interface that contains all pages, which have different layout on different platforms.
    /// </summary>
    public interface IPageResolver
    {
        #region properties

        /// <summary>
        /// Main page of application.
        /// </summary>
        Page MainPage { get; }

        /// <summary>
        /// Page that contains information about device's battery.
        /// </summary>
        Page BatteryPage { get; }

        /// <summary>
        /// Page that contains information about device's capabilities.
        /// </summary>
        Page CapabilitiesPage { get; }

        /// <summary>
        /// Page that contains information about device's display.
        /// </summary>
        Page DisplayPage { get; }

        /// <summary>
        /// Page that contains information about device's LEDs.
        /// </summary>
        Page LedPage { get; }

        /// <summary>
        /// Page that contains information about device's settings.
        /// </summary>
        Page SettingsPage { get; }

        /// <summary>
        /// Page that contains information about device's USB.
        /// </summary>
        Page UsbPage { get; }

        /// <summary>
        /// Page that contains information about device's vibrators.
        /// </summary>
        Page VibratorPage { get; }

        #endregion
    }
}

```



Step 3: Update the **CreatePage** method in the  **SystemInfo/Utils/PageProvider** class.

<highlight>22-23</highlight>

```csharp
using SystemInfo.View;
using Xamarin.Forms;

namespace SystemInfo.Utils
{
    /// <summary>
    /// Helper class that provides application's pages.
    /// </summary>
    public static class PageProvider
    {
        #region methods

        /// <summary>
        /// Method that provides platform-specific pages.
        /// </summary>
        /// <param name="s">Title of page.</param>
        /// <returns>Returns page by its title. In case of unsupported title empty ContentPage will be returned.</returns>
        public static Page CreatePage(string s)
        {
            switch (s)
            {
                case "Battery":
                    return DependencyService.Get<IPageResolver>().BatteryPage;
                case "Display":
                    return DependencyService.Get<IPageResolver>().DisplayPage;
                case "USB":
                    return DependencyService.Get<IPageResolver>().UsbPage;
                case "Capabilities":
                    return DependencyService.Get<IPageResolver>().CapabilitiesPage;
                case "Settings":
                    return DependencyService.Get<IPageResolver>().SettingsPage;
                case "LED":
                    return DependencyService.Get<IPageResolver>().LedPage;
                case "Vibrator":
                    return DependencyService.Get<IPageResolver>().VibratorPage;
                default:
                    return new ContentPage { Title = "Default " + s };
            }
        }

        #endregion
    }
}

```



Step 4: Extend the **BatteryPage.xaml** file by defining the BingingContext.

<highlight>4, 7-10</highlight>

```xml
<?xml version="1.0" encoding="utf-8" ?>
<w:CirclePage xmlns="http://xamarin.com/schemas/2014/forms"
              xmlns:x="http://schemas.microsoft.com/winfx/2009/xaml"
              xmlns:viewModel="clr-namespace:SystemInfo.ViewModel;assembly=SystemInfo"
              xmlns:w="clr-namespace:Tizen.Wearable.CircularUI.Forms;assembly=Tizen.Wearable.CircularUI.Forms"
              x:Class="SystemInfo.Tizen.Wearable.View.BatteryPage">

    <w:CirclePage.BindingContext>
        <viewModel:BatteryViewModel />
    </w:CirclePage.BindingContext>

</w:CirclePage>

```



Step 5: Extend the **BatteryPage.xaml** file by defining the Resources.

<highlight>5-7, 14-37</highlight>

```xml
<?xml version="1.0" encoding="utf-8" ?>
<w:CirclePage xmlns="http://xamarin.com/schemas/2014/forms"
              xmlns:x="http://schemas.microsoft.com/winfx/2009/xaml"
              xmlns:viewModel="clr-namespace:SystemInfo.ViewModel;assembly=SystemInfo"
              xmlns:utils="clr-namespace:SystemInfo.Utils;assembly=SystemInfo"
              xmlns:converter="clr-namespace:SystemInfo.Converter;assembly=SystemInfo"
              xmlns:control="clr-namespace:SystemInfo.Tizen.Wearable.Control;assembly=SystemInfo.Tizen.Wearable"
              xmlns:w="clr-namespace:Tizen.Wearable.CircularUI.Forms;assembly=Tizen.Wearable.CircularUI.Forms"
              x:Class="SystemInfo.Tizen.Wearable.View.BatteryPage">

    <w:CirclePage.BindingContext>
        <viewModel:BatteryViewModel />
    </w:CirclePage.BindingContext>

    <w:CirclePage.Resources>
        <ResourceDictionary>
            <converter:NumberToDisplayPercentConverter x:Key="NumberToDisplayPercentConverter" />

            <DataTemplate x:Key="StandardTemplate">
                <control:TizenTextCell Text="{Binding Title}"
                                       Command="{Binding OnTap}"
                                       Detail="{Binding Description}" />
            </DataTemplate>

            <DataTemplate x:Key="ProgressBarTemplate">
                <control:TizenTextCell Text="{Binding Title}"
                                       Command="{Binding OnTap}"
                                       Detail="{Binding Description,
                                           Converter={StaticResource NumberToDisplayPercentConverter}}" />
            </DataTemplate>

            <utils:ListItemTemplateSelector x:Key="ListItemTemplateSelector"
                                            StandardTemplate="{StaticResource StandardTemplate}"
                                            ProgressBarTemplate="{StaticResource ProgressBarTemplate}" />
        </ResourceDictionary>
    </w:CirclePage.Resources>

</w:CirclePage>

```



Step 6: Extend the **BatteryPage.xaml** file by defining the page content.

<highlight>10-11, 39-55</highlight>

```xml
<?xml version="1.0" encoding="utf-8" ?>
<w:CirclePage xmlns="http://xamarin.com/schemas/2014/forms"
              xmlns:x="http://schemas.microsoft.com/winfx/2009/xaml"
              xmlns:viewModel="clr-namespace:SystemInfo.ViewModel;assembly=SystemInfo"
              xmlns:utils="clr-namespace:SystemInfo.Utils;assembly=SystemInfo"
              xmlns:converter="clr-namespace:SystemInfo.Converter;assembly=SystemInfo"
              xmlns:control="clr-namespace:SystemInfo.Tizen.Wearable.Control;assembly=SystemInfo.Tizen.Wearable"
              xmlns:w="clr-namespace:Tizen.Wearable.CircularUI.Forms;assembly=Tizen.Wearable.CircularUI.Forms"
              x:Class="SystemInfo.Tizen.Wearable.View.BatteryPage"
              NavigationPage.HasNavigationBar="False"
              RotaryFocusObject="{x:Reference listView}">

    <w:CirclePage.BindingContext>
        <viewModel:BatteryViewModel />
    </w:CirclePage.BindingContext>

    <w:CirclePage.Resources>
        <ResourceDictionary>
            <converter:NumberToDisplayPercentConverter x:Key="NumberToDisplayPercentConverter" />

            <DataTemplate x:Key="StandardTemplate">
                <control:TizenTextCell Text="{Binding Title}"
                                       Command="{Binding OnTap}"
                                       Detail="{Binding Description}" />
            </DataTemplate>

            <DataTemplate x:Key="ProgressBarTemplate">
                <control:TizenTextCell Text="{Binding Title}"
                                       Command="{Binding OnTap}"
                                       Detail="{Binding Description,
                                           Converter={StaticResource NumberToDisplayPercentConverter}}" />
            </DataTemplate>

            <utils:ListItemTemplateSelector x:Key="ListItemTemplateSelector"
                                            StandardTemplate="{StaticResource StandardTemplate}"
                                            ProgressBarTemplate="{StaticResource ProgressBarTemplate}" />
        </ResourceDictionary>
    </w:CirclePage.Resources>

    <w:CirclePage.Content>
        <w:CircleListView x:Name="listView"
                          Header="Battery"
                          ItemsSource="{Binding ItemList}"
                          ItemTemplate="{StaticResource ListItemTemplateSelector}">
            <w:CircleListView.HeaderTemplate>
                <DataTemplate>
                    <Label Text="{Binding .}"
                           FontAttributes="Bold"
                           TextColor="Aqua"
                           FontSize="13"
                           HorizontalTextAlignment="Center" />
                </DataTemplate>
            </w:CircleListView.HeaderTemplate>
        </w:CircleListView>
    </w:CirclePage.Content>

</w:CirclePage>

```



Right now the application can be run on the emulator or target device.

<img src="/assets/images/tutorials/107/BatteryProperty_BatteryView_1.PNG" style="undefined"/>

The task has been completed.



The application's main page displays the Battery property as the first element of the list of system properties. When you tap the Battery element, the application displays page containing battery specific properties.

<img src="/assets/images/tutorials/107/BatteryProperty_BatteryView_2.PNG" style="height:544px; width:400px"/>
