---
layout: ../../layouts/tutorial/TextTutorial.astro
title: "[Korean] Cross Platform TV Application Development (2/2)"
description: "This tutorial describes the process of developing a CrossPlatform Application that works with both Tizen and Android using Xamarin.Forms.\nIt is the second of two tutorials, and it implements the function to play video of VideoPlayer."
created: "2017/10/04"
modified: "undefined"
profile: ["tv"]
type: "dotnet"
level: 2
state: "open"
thumbnail: "/assets/images/tutorials/97/video2.png"
---

# Introduction

## 1. VideoPlayerLite 소개

이번 강의에선 **VideoPlayerLite** 의 남은 부분에 대한 구현을 다룹니다.

**PlayerPage** 와 **비디오 재생에 관련된 부분** 들을 구현해볼 예정입니다.

<img src="/assets/images/tutorials/97/1-1.png" style="height:563px; width:1000px"/>

<img src="/assets/images/tutorials/85/1.png" style="height:523px; width:1162px"/>

이 어플리케이션에 대한 더 자세한 정보나 이전 강의에서 다루는 부분은 아래의 링크를 참조바랍니다.

[Cross Platform TV Application Development (1/2)](http://tizenappschool.org/tutorial//95)

# Implementing PlayerPage

## 1. PlayerPage 구현 (1/2)

<img src="/assets/images/tutorials/85/2.png" style="height:492px; width:1162px"/>

아래의 그림은 **PlayerPage** 의 구조를 나타냅니다.

재생중인 비디오의 타이틀과 재생 시간 등을 나타내기 위한 **Label** , 그리고 재생화면을 위한 **MediaRenderingView** 로 구성됩니다.

<img src="/assets/images/tutorials/97/2-1.png" style="height:390px; width:678px"/>

**MediaRenderingView** 는 후에 구현하도록 하고 먼저 다른 부분들을 구성해보도록 하겠습니다.

**Step 1: ContentPage 추가**

**Views** 폴더에 " **PlayerPage"** 라는 이름의  **ContentPage** 를 추가합니다.

<img src="/assets/images/tutorials/97/2-2.png" style="height:399px; width:230px"/>

[PlayerPage.xaml]

```xml
<?xml version="1.0" encoding="utf-8" ?>
<ContentPage xmlns="http://xamarin.com/schemas/2014/forms"
             xmlns:x="http://schemas.microsoft.com/winfx/2009/xaml"
             x:Class="VideoPlayerLite.Views.PlayerPage">
    <ContentPage.Content>
        <StackLayout>
            <Label Text="Welcome to Xamarin Forms!" />
        </StackLayout>
    </ContentPage.Content>
</ContentPage>
```

[PlayerPage.xaml.cs]

```csharp
using Xamarin.Forms;
using Xamarin.Forms.Xaml;

namespace VideoPlayerLite.Views
{
    [XamlCompilation(XamlCompilationOptions.Compile)]
    public partial class PlayerPage : ContentPage
    {
        public PlayerPage()
        {
            InitializeComponent();
        }
    }
}
```

**Step 2: App의 MainPage를 NavigationPage로 변경**

각 Page간 전환을 위해 App의 **MainPage** 를 **NavigationPage** 로 바꿉니다.

**NavigationPage** 는 여러 페이지로 된 스택에서 페이지 간 탐색을 위한 페이지로,

**PushAsync** , **PopAsync** 두 메소드를 이용하여 다른 페이지로 이동할 수 있게 됩니다.

[Xamarin.Forms.NavigationPage](https://developer.xamarin.com/api/type/Xamarin.Forms.NavigationPage/)

[App.xaml.cs]

<highlight>12</highlight>

```csharp
using VideoPlayerLite.Views;
using Xamarin.Forms;

namespace VideoPlayerLite
{
    public partial class App : Application
    {
        public App()
        {
            InitializeComponent();

            MainPage = new NavigationPage(new LibraryPage());
        }

        protected override void OnStart()
        {
            // Handle when your app starts
        }

        protected override void OnSleep()
        {
            // Handle when your app sleeps
        }

        protected override void OnResume()
        {
            // Handle when your app resumes
        }
    }
}

```

LibraryPage와 PlayerPage의  **NavigationPage.HasNavigationBar** 속성을 " **False** "로 설정합니다.

[LibraryPage.xaml]

<highlight>8</highlight>

```xml
<?xml version="1.0" encoding="utf-8" ?>
<ContentPage xmlns="http://xamarin.com/schemas/2014/forms"
             xmlns:x="http://schemas.microsoft.com/winfx/2009/xaml"
             xmlns:ViewModels="clr-namespace:VideoPlayerLite.ViewModels"
             x:Class="VideoPlayerLite.Views.LibraryPage"
             VideoList="{Binding VideoList}"
             UpdateVideoListCommand="{Binding UpdateVideoListCommand}"
             NavigationPage.HasNavigationBar="False">
    ...
</ContentPage>

```

[PlayerPage.xaml]

<highlight>5</highlight>

```xml
<?xml version="1.0" encoding="utf-8" ?>
<ContentPage xmlns="http://xamarin.com/schemas/2014/forms"
             xmlns:x="http://schemas.microsoft.com/winfx/2009/xaml"
             x:Class="VideoPlayerLite.Views.PlayerPage"
             NavigationPage.HasNavigationBar="False">
    ...
</ContentPage>

```

<br/> 

**Step 3: 불필요한 코드 제거**

먼저, **PlayerPage** 에서 불필요한 **StackLayout** 과 **Label** 들을 제거합니다.

[PlayerPage.xaml]

<highlight>7-9</highlight>

```xml
<?xml version="1.0" encoding="utf-8" ?>
<ContentPage xmlns="http://xamarin.com/schemas/2014/forms"
             xmlns:x="http://schemas.microsoft.com/winfx/2009/xaml"
             x:Class="VideoPlayerLite.Views.PlayerPage"
             NavigationPage.HasNavigationBar="False">
    <ContentPage.Content>
        <StackLayout>
            <Label Text="Welcome to Xamarin Forms!" />
        </StackLayout>
    </ContentPage.Content>
</ContentPage>

```

**Step 4: PlayerPage에 Label 추가**

비디오의 **타이틀** 과 **재생시간** , **전체시간** 을 표시하기 위한 **Label** 을 추가합니다.

[PlayerPage.xaml]

<highlight>7-15</highlight>

```xml
<?xml version="1.0" encoding="utf-8" ?>
<ContentPage xmlns="http://xamarin.com/schemas/2014/forms"
             xmlns:x="http://schemas.microsoft.com/winfx/2009/xaml"
             x:Class="VideoPlayerLite.Views.PlayerPage"
             NavigationPage.HasNavigationBar="false">
    <ContentPage.Content>
        <RelativeLayout>
            <Label x:Name="ItemTitle"
                   RelativeLayout.HeightConstraint="{ConstraintExpression Type=RelativeToParent, Property=Height, Factor=0.046}"
                   RelativeLayout.WidthConstraint="{ConstraintExpression Type=RelativeToParent, Property=Width, Factor=0.9}"
                   RelativeLayout.YConstraint="{ConstraintExpression Type=RelativeToParent, Property=Height, Factor=0.06}"
                   RelativeLayout.XConstraint="{ConstraintExpression Type=RelativeToParent, Property=Width, Factor=0.05}"
                   FontSize="Medium"
                   Text="Title"/>
        </RelativeLayout>
    </ContentPage.Content>
</ContentPage>

```

<highlight>9-19</highlight>

```xml
<?xml version="1.0" encoding="utf-8" ?>
<ContentPage xmlns="http://xamarin.com/schemas/2014/forms"
             xmlns:x="http://schemas.microsoft.com/winfx/2009/xaml"
             x:Class="VideoPlayerLite.Views.PlayerPage"
             NavigationPage.HasNavigationBar="false">
    <ContentPage.Content>
        <RelativeLayout>
            ...
            <StackLayout RelativeLayout.HeightConstraint="{ConstraintExpression Type=RelativeToParent, Property=Height, Factor=0.045}"
                         RelativeLayout.WidthConstraint="{ConstraintExpression Type=RelativeToParent, Property=Width, Factor=0.127}"
                         RelativeLayout.YConstraint="{ConstraintExpression Type=RelativeToParent, Property=Height, Factor=0.911}"
                         RelativeLayout.XConstraint="{ConstraintExpression Type=RelativeToParent, Property=Width, Factor=0.05}"
                         Orientation="Horizontal">
                <Label x:Name="ItemPosition"
                       Text="00:00"/>
                <Label Text=" / " />
                <Label x:Name="Duration"
                       Text="00:00"/>
            </StackLayout>
        </RelativeLayout>
    </ContentPage.Content>
</ContentPage>

```

**Step 5: PlayerPage에 Grid 추가**

세 개의 **Button** 을 포함하는 **Grid** 를 추가합니다.

이 **Button** 들은 비디오 **재생을 제어** 하는 역할을 수행합니다.

[PlayerPage.xaml]

<highlight>9-32</highlight>

```xml
<?xml version="1.0" encoding="utf-8" ?>
<ContentPage xmlns="http://xamarin.com/schemas/2014/forms"
             xmlns:x="http://schemas.microsoft.com/winfx/2009/xaml"
             x:Class="VideoPlayerLite.Views.PlayerPage"
             NavigationPage.HasNavigationBar="false">
    <ContentPage.Content>
        <RelativeLayout>
            ...
            <Grid x:Name="ControlPad"
                  RelativeLayout.HeightConstraint="{ConstraintExpression Type=RelativeToParent, Property=Height, Factor=0.134}"
                  RelativeLayout.WidthConstraint="{ConstraintExpression Type=RelativeToParent, Property=Width, Factor=0.225}"
                  RelativeLayout.YConstraint="{ConstraintExpression Type=RelativeToParent, Property=Height, Factor=0.866}"
                  RelativeLayout.XConstraint="{ConstraintExpression Type=RelativeToParent, Property=Width, Factor=0.388}">
                <Grid.ColumnDefinitions>
                    <ColumnDefinition Width="*"/>
                    <ColumnDefinition Width="*"/>
                    <ColumnDefinition Width="*"/>
                </Grid.ColumnDefinitions>
                <Grid.RowDefinitions>
                    <RowDefinition Height="*"/>
                </Grid.RowDefinitions>

                <Button x:Name="PlayPauseButton"
                        Grid.Row="0"
                        Grid.Column="1"/>
                <Button x:Name="PrevButton"
                        Grid.Row="0"
                        Grid.Column="0"/>
                <Button x:Name="NextButton"
                        Grid.Row="0"
                        Grid.Column="2"/>
            </Grid>
        </RelativeLayout>
    </ContentPage.Content>
</ContentPage>

```

## 2. PlayerPage 구현 (2/2)

<img src="/assets/images/tutorials/85/7.png" style="height:492px; width:1162px"/>

이제 비디오 재생화면을 표시하기 위한 **MediaRenderingView** 를 만들어야 합니다.

**Xamarin** 은 비디오 재생에 관한 기능을 제공해주지 않기 때문에, 임의의 **View** 를 만들고 각 플랫폼에서 **CustomRenderer** 로 구현해주어야 합니다.

**Step 1: MediaRenderingView 생성**

**Views** 폴더에 " **MediaRenderingView** "라는 이름의 **ContentView** 하나를 생성합니다.

<img src="/assets/images/tutorials/97/7-1.png" style="height:366px; width:291px"/>

**XAML** 과 **code-behind** 에서 **ContentView** 를 **View** 로 바꿉니다.

[MediaRenderingView.xaml]

```xml
<?xml version="1.0" encoding="UTF-8"?>
<View xmlns="http://xamarin.com/schemas/2014/forms"
      xmlns:x="http://schemas.microsoft.com/winfx/2009/xaml"
      x:Class="VideoPlayerLite.Views.MediaRenderingView">
</View>
```

[MediaRenderingView.xaml.cs]

```csharp
namespace VideoPlayerLite.Views
{
	public partial class MediaRenderingView : View
    {
		public MediaRenderingView ()
		{
			InitializeComponent ();
		}
	}
}
```

**Step 2: PlayerPage에 MediaRenderingView 추가**

**PlayerPage** 에 **Views** 네임스페이스를 선언하고 **MediaRenderingView** 를 추가합니다.

[PlayerPage.xaml]

<highlight>4,20-21</highlight>

```xml
<?xml version="1.0" encoding="utf-8" ?>
<ContentPage xmlns="http://xamarin.com/schemas/2014/forms"
             xmlns:x="http://schemas.microsoft.com/winfx/2009/xaml"
             xmlns:Views="clr-namespace:VideoPlayerLite.Views"
             xmlns:ViewModels="clr-namespace:VideoPlayerLite.ViewModels"
             xmlns:Models="clr-namespace:VideoPlayerLite.Models"
             x:Class="VideoPlayerLite.Views.PlayerPage"
             NavigationPage.HasNavigationBar="false"
             FetchVideoCommand="{Binding FetchSelectedVideoCommand}">
    <ContentPage.BindingContext>
        <ViewModels:PlayerPageViewModel/>
    </ContentPage.BindingContext>
    <ContentPage.Resources>
        <ResourceDictionary>
            <Models:DurationConverter x:Key="DurationConverter"/>
        </ResourceDictionary>
    </ContentPage.Resources>
    <ContentPage.Content>
        <RelativeLayout>
            <Views:MediaRenderingView RelativeLayout.HeightConstraint="{ConstraintExpression Type=RelativeToParent, Property=Height, Factor=1}"
                                      RelativeLayout.WidthConstraint="{ConstraintExpression Type=RelativeToParent, Property=Width, Factor=1}"/>
            ...
        </RelativeLayout>
    </ContentPage.Content>
</ContentPage>

```

[코드 스냅샷](https://tizenschool.org/assets/images/tutorials/97/Lect3_Snapshot04_Add_MediaRenderingView.zip)

## 3. MediaItemProvider 수정

모든 **Xamarin.Forms** 컨트롤에는 네이티브 컨트롤의 인스턴스를 만드는 각 플랫폼에 대한 **Renderer** 가 있습니다.

텍스트 편집을 위한 **Entry** 컨트롤의 예를 들면 **Tizen** 의 **Entry** , **iOS** 의  **UITextField** , **Android** 의 **EditText** 에 대응되어 **EntryRenderer** 가 구현되어 있습니다.

<img src="/assets/images/tutorials/97/8-1.png" style="height:309px; width:808px"/>

**CustomRenderer** 는

사용자 임의로 텍스트의 색을 바꾸는 등 작은 스타일 변경이나

동작을 추가, 변경하는 등 정교한 변경에 사용할 수 있습니다.

<img src="/assets/images/tutorials/97/8-2.png" style="height:187px; width:800px"/>

이 강의에서는 **MediaRenderingView(Element)** 를 **Tizen의 MediaView(Control)** 나,

**Android의 VideoView(Control)** 의 인스턴스로 변경하기 위해 **CustomRenderer** 를 사용할 예정입니다.

<img src="/assets/images/tutorials/85/8.png" style="height:307px; width:771px"/>

CustomRenderer에 대한 보다 자세한 정보는 아래 링크를 참조바랍니다.

[Introduction to Custom Renderers](https://developer.xamarin.com/guides/xamarin-forms/application-fundamentals/custom-renderer/introduction/)

## 4. ItemViewModel 수정

<img src="/assets/images/tutorials/85/9.png" style="height:492px; width:1162px"/>

이제 **Custom Renderer** 를 만들고 그 세부 구현을 해보도록 하겠습니다.

**Step 1: MediaRenderingViewRenderer 생성**

각 플랫폼 프로젝트에 **Renderers** 폴더를 만들고 " **MediaRenderingViewRenderer"** 라는 이름의 \*\*\*\* 클래스를 추가합니다.

<img src="/assets/images/tutorials/97/9-1.png" style="height:309px; width:284px"/>
 

**Step 2: ExportRenderer 속성 추가**

각 플랫폼의 **Custom Renderer** 클래스는 **ExportRenderer** 속성을 통해 **MediaRenderingView** 의 **Renderer** 로서 등록해야합니다.

이 속성은 두 파라메터를 필요로 합니다.

- 그리고자 하는 **Xamarin.Forms 컨트롤** 의 타입 이름( **MediaRenderingView** ), 각 플랫폼의 **Custom Renderer** 의 타입 이름( **MediaRenderingViewRenderer** )

[MediaRenderingViewRenderer.cs]

<highlight>5</highlight>

```csharp
using VideoPlayerLite.Tizen.Tizen.TV.Renderer;
using VideoPlayerLite.Views;
using Xamarin.Forms.Platform.Tizen;

[assembly: ExportRenderer(typeof(MediaRenderingView), typeof(MediaRenderingViewRenderer))]
namespace VideoPlayerLite.Tizen.Tizen.TV.Renderer
{
    class MediaRenderingViewRenderer
    {
    }
}

```

**Step 3: ViewRenderer 상속**

**MediaRenderingViewRenderer** 는 **ViewRenderer** 를 상속받아 구현합니다.

그리고 **Renderer** 가 그릴 대상인 **View** , 여기서는 **Element** 가 변경 되었을 때 불려지는 **OnElementChanged** 와

그 **Element** 의 프로퍼티가 변경되었을 때 불려지는 **OnElementPropertyChanged** 를 **override** 합니다.

[MediaRenderingViewRenderer.cs]

<highlight>10,12-15,17-20</highlight>

```csharp
using System.ComponentModel;
using Tizen.Multimedia;
using VideoPlayerLite.Tizen.Tizen.TV.Renderer;
using VideoPlayerLite.Views;
using Xamarin.Forms.Platform.Tizen;

[assembly: ExportRenderer(typeof(MediaRenderingView), typeof(MediaRenderingViewRenderer))]
namespace VideoPlayerLite.Tizen.Tizen.TV.Renderer
{
    public class MediaRenderingViewRenderer : ViewRenderer<MediaRenderingView, MediaView>
    {
        protected override void OnElementChanged(ElementChangedEventArgs<MediaRenderingView> e)
        {
            base.OnElementChanged(e);
        }

        protected override void OnElementPropertyChanged(object sender, PropertyChangedEventArgs e)
        {
            base.OnElementPropertyChanged(sender, e);
        }
    }
}

```

**Step 4. 네이티브 컨트롤 변경**

**OnElementChanged** 내부에서 **SetNativeControl** 메소드를 통해 **네이티브 컨트롤** 을 **MediaView** 로 바꿔줍니다.

이것을 통해 기존의 **View** 대신 **MediaView** 가 **MediaRenderingView** 를 통해 보여지게 됩니다.

[MediaRenderingViewRenderer.cs]

<highlight>16-19</highlight>

```csharp
using System.ComponentModel;
using Tizen.Multimedia;
using VideoPlayerLite.Tizen.Tizen.TV.Renderer;
using VideoPlayerLite.Views;
using Xamarin.Forms.Platform.Tizen;

[assembly: ExportRenderer(typeof(MediaRenderingView), typeof(MediaRenderingViewRenderer))]
namespace VideoPlayerLite.Tizen.Tizen.TV.Renderer
{
    public class MediaRenderingViewRenderer : ViewRenderer<MediaRenderingView, MediaView>
    {
        protected override void OnElementChanged(ElementChangedEventArgs<MediaRenderingView> e)
        {
            base.OnElementChanged(e);

            if (Control == null)
            {
                SetNativeControl(new MediaView(Forms.Context.MainWindow));
            }
        }

        protected override void OnElementPropertyChanged(object sender, PropertyChangedEventArgs e)
        {
            base.OnElementPropertyChanged(sender, e);
        }
    }
}

```

[코드 스냅샷](https://tizenschool.org/assets/images/tutorials/97/Lect3_Snapshot05_Add_MediaRenderingViewRenderer.zip)

## 4. PlayerPageViewModel 생성

<img src="/assets/images/tutorials/85/3.png" style="height:492px; width:1162px"/>

**PlayerPage** 에서 비디오를 재생하기 위해서는 **선택된 비디오에 대한 정보를 저장** 하고 있어야 합니다.

**MediaItemProvider** 는 각 **ViewModel에서 접근이 가능** 하므로 비디오에 대한 정보를 저장하기에 알맞습니다.

**Step 1: SelectedItem 프로퍼티 추가**

**LibraryPage** 에서 선택한 비디오의 정보를 저장하기 위해 **MediaItemProvider** 에 **SelectedItem** 프로퍼티를 추가합니다.

[MediaItemProvider.cs]

<highlight>15,17-24</highlight>

```csharp
using System;
using System.Collections.Generic;
using System.Threading.Tasks;
using Xamarin.Forms;

namespace VideoPlayerLite.Models
{
    public sealed class MediaItemProvider
    {
        ...

        private IEnumerable<MediaItem> itemList;
        public IEnumerable<MediaItem> ItemList { get => itemList; }

        private MediaItem selectedItem;

        public MediaItem SelectedItem
        {
            get => selectedItem;
            set
            {
                selectedItem = value;
            }
        }

        private MediaItemProvider()
        {
            if (DependencyService.Get<IMediaContentAPIs>() != null)
            {
                mediaContentAPIs = DependencyService.Get<IMediaContentAPIs>();
            }
        }

        ...
    }
}


```

**Step 2: 비디오 변경을 위한 메소드 추가**

선택된 비디오를 변경하기 위한 **MoveToPrev** , **MoveToNext** 메소드를 추가합니다.

해당 메소드들은 **PlayerPage** 의 Button들 중 **PrevButton** , **NextButton** 이 클릭 되었을 때

**Command** 를 통해 호출되어 현재 선택된 비디오를 **이전, 다음 비디오로 변경하는 역할** 을 수행합니다.

[MediaItemProvider.cs]

<highlight>15,23,27-37,39-49</highlight>

```csharp
using System;
using System.Collections.Generic;
using System.Linq;
using System.Threading.Tasks;
using Xamarin.Forms;

namespace VideoPlayerLite.Models
{
    public sealed class MediaItemProvider
    {

        ...

        private MediaItem selectedItem;
        private int selectedItemIndex;

        public MediaItem SelectedItem
        {
            get => selectedItem;
            set
            {
                selectedItem = value;
                selectedItemIndex = itemList.ToList().IndexOf(selectedItem);
            }
        }

        public MediaItem MoveToNext()
        {
            selectedItemIndex++;

            if (selectedItemIndex == itemList.Count())
            {
                selectedItemIndex = 0;
            }

            return selectedItem = itemList.ElementAt(selectedItemIndex);
        }

        public MediaItem MoveToPrev()
        {
            selectedItemIndex--;

            if (selectedItemIndex < 0)
            {
                selectedItemIndex = itemList.Count() - 1;
            }

            return selectedItem = itemList.ElementAt(selectedItemIndex);
        }

        private MediaItemProvider()
        {
            if (DependencyService.Get<IMediaContentAPIs>() != null)
            {
                mediaContentAPIs = DependencyService.Get<IMediaContentAPIs>();
            }
        }

        ...
    }
}

```

## 5. View/ViewModel 간 Binding 설정

<img src="/assets/images/tutorials/85/15.png" style="height:492px; width:1162px"/>

이제 **PlayerPage** 의 세 **Button** 들을 보다 자세하게 구현해보도록 하겠습니다.

**Step 1: PlayerButton 생성**

**Views** 폴더에 " **PlayerButton** "이라는 이름의  **ContentView** 를 추가해줍니다.

<img src="/assets/images/tutorials/97/15-1.png" style="height:383px; width:290px"/>

**XAML** 과 **code-behind** 에서 **ContentView** 를 **RelativeLayout** 으로 변경합니다.

[PlayerButton.xaml]

```xml
<?xml version="1.0" encoding="UTF-8"?>
<RelativeLayout xmlns="http://xamarin.com/schemas/2014/forms"
                xmlns:x="http://schemas.microsoft.com/winfx/2009/xaml"
                x:Class="VideoPlayerLite.Views.PlayerButton">
</RelativeLayout>
```

[PlayerButton.xaml.cs]

```csharp
using Xamarin.Forms;
using Xamarin.Forms.Xaml;

namespace VideoPlayerLite.Views
{
    [XamlCompilation(XamlCompilationOptions.Compile)]
	public partial class PlayerButton : RelativeLayout
    {
		public PlayerButton ()
		{
			InitializeComponent ();
		}
	}
}
```

**Step 2: PlayerButton Layout 구성**

**PlayerButton** 은 배경, 아이콘, 그림자를 위한 **Image** 와 Focused, Clicked 이벤트를 처리해주기 위한 **Button** 이 필요합니다.

**이미지 리소스** 는 각 플랫폼의 **리소스 폴더** ( **Tizen - res, Android -Resources\Drawable** )에 넣어 사용하면 됩니다.

[PlayerButton.xaml]

<highlight>5-26</highlight>

```xml
<?xml version="1.0" encoding="utf-8" ?>
<RelativeLayout xmlns="http://xamarin.com/schemas/2014/forms"
                xmlns:x="http://schemas.microsoft.com/winfx/2009/xaml"
                x:Class="VideoPlayerLite.Views.PlayerButton">
    <Image x:Name="Shadow"
           RelativeLayout.HeightConstraint="{ConstraintExpression Type=RelativeToParent, Property=Height, Factor=1}"
           RelativeLayout.WidthConstraint="{ConstraintExpression Type=RelativeToParent, Property=Width, Factor=1}"
           RelativeLayout.YConstraint="{ConstraintExpression Type=RelativeToParent, Property=Height, Factor=0.0}"
           RelativeLayout.XConstraint="{ConstraintExpression Type=RelativeToParent, Property=Width, Factor=0.0}"
           Source="btn_viewer_control_focused_shadow.png"/>
    <Image x:Name="FocusBackground"
           RelativeLayout.HeightConstraint="{ConstraintExpression Type=RelativeToParent, Property=Height, Factor=0.67}"
           RelativeLayout.WidthConstraint="{ConstraintExpression Type=RelativeToParent, Property=Width, Factor=0.67}"
           RelativeLayout.YConstraint="{ConstraintExpression Type=RelativeToParent, Property=Height, Factor=0.17}"
           RelativeLayout.XConstraint="{ConstraintExpression Type=RelativeToParent, Property=Width, Factor=0.17}"
           Source="btn_viewer_control_focused.png"
           Opacity="0.2"/>
    <Image x:Name="Icon"
           RelativeLayout.HeightConstraint="{ConstraintExpression Type=RelativeToParent, Property=Height, Factor=0.458}"
           RelativeLayout.WidthConstraint="{ConstraintExpression Type=RelativeToParent, Property=Width, Factor=0.458}"
           RelativeLayout.YConstraint="{ConstraintExpression Type=RelativeToParent, Property=Height, Factor=0.27}"
           RelativeLayout.XConstraint="{ConstraintExpression Type=RelativeToParent, Property=Width, Factor=0.27}"/>
    <Button x:Name="ControlButton"
            RelativeLayout.HeightConstraint="{ConstraintExpression Type=RelativeToView, ElementName=FocusBackground, Factor=1}"
            RelativeLayout.WidthConstraint="{ConstraintExpression Type=RelativeToView, ElementName=FocusBackground, Factor=1}"
            Opacity="0"/>
</RelativeLayout>

```

PlayerButton이 포커스되었을 때 배경, 그림자 이미지가 보이도록 하기 위해

**ControlButton** 의 **IsFocused** 와 **FocusBackground** , **Shadow Image** 의 **IsVisible** 을 바인딩합니다.

[PlayerButton.xaml]

<highlight>11,19</highlight>

```xml
<?xml version="1.0" encoding="UTF-8"?>
<RelativeLayout xmlns="http://xamarin.com/schemas/2014/forms"
                xmlns:x="http://schemas.microsoft.com/winfx/2009/xaml"
                x:Class="VideoPlayerLite.Views.PlayerButton">
    <Image x:Name="Shadow"
           RelativeLayout.HeightConstraint="{ConstraintExpression Type=RelativeToParent, Property=Height, Factor=1}"
           RelativeLayout.WidthConstraint="{ConstraintExpression Type=RelativeToParent, Property=Width, Factor=1}"
           RelativeLayout.YConstraint="{ConstraintExpression Type=RelativeToParent, Property=Height, Factor=0.0}"
           RelativeLayout.XConstraint="{ConstraintExpression Type=RelativeToParent, Property=Width, Factor=0.0}"
           Source="btn_viewer_control_focused_shadow.png"
           IsVisible="{Binding Path=IsFocused, Source={x:Reference Name=ControlButton}}"/>
    <Image x:Name="FocusBackground"
           RelativeLayout.HeightConstraint="{ConstraintExpression Type=RelativeToParent, Property=Height, Factor=0.67}"
           RelativeLayout.WidthConstraint="{ConstraintExpression Type=RelativeToParent, Property=Width, Factor=0.67}"
           RelativeLayout.YConstraint="{ConstraintExpression Type=RelativeToParent, Property=Height, Factor=0.17}"
           RelativeLayout.XConstraint="{ConstraintExpression Type=RelativeToParent, Property=Width, Factor=0.17}"
           Source="btn_viewer_control_focused.png"
           Opacity="0.2"
           IsVisible="{Binding Path=IsFocused, Source={x:Reference Name=ControlButton}}"/>
    <Image x:Name="Icon"
           RelativeLayout.HeightConstraint="{ConstraintExpression Type=RelativeToParent, Property=Height, Factor=0.458}"
           RelativeLayout.WidthConstraint="{ConstraintExpression Type=RelativeToParent, Property=Width, Factor=0.458}"
           RelativeLayout.YConstraint="{ConstraintExpression Type=RelativeToParent, Property=Height, Factor=0.27}"
           RelativeLayout.XConstraint="{ConstraintExpression Type=RelativeToParent, Property=Width, Factor=0.27}"/>
    <Button x:Name="ControlButton"
            RelativeLayout.HeightConstraint="{ConstraintExpression Type=RelativeToView, ElementName=FocusBackground, Factor=1}"
            RelativeLayout.WidthConstraint="{ConstraintExpression Type=RelativeToView, ElementName=FocusBackground, Factor=1}"
            Opacity="0"/>
</RelativeLayout>

```

그리고 **ControlButton** 이 클릭되었을 때 해당 기능을 수행하도록 하기 위해 **Command** 에 **ControlButtonCommand** 를 바인딩합니다.

[PlayerButton.xaml]

<highlight>29</highlight>

```xml
<?xml version="1.0" encoding="UTF-8"?>
<RelativeLayout xmlns="http://xamarin.com/schemas/2014/forms"
                xmlns:x="http://schemas.microsoft.com/winfx/2009/xaml"
                x:Class="VideoPlayerLite.Views.PlayerButton">
    <Image x:Name="Shadow"
           RelativeLayout.HeightConstraint="{ConstraintExpression Type=RelativeToParent, Property=Height, Factor=1}"
           RelativeLayout.WidthConstraint="{ConstraintExpression Type=RelativeToParent, Property=Width, Factor=1}"
           RelativeLayout.YConstraint="{ConstraintExpression Type=RelativeToParent, Property=Height, Factor=0.0}"
           RelativeLayout.XConstraint="{ConstraintExpression Type=RelativeToParent, Property=Width, Factor=0.0}"
           Source="btn_viewer_control_focused_shadow.png"
           IsVisible="{Binding Path=IsFocused, Source={x:Reference Name=ControlButton}}"/>
    <Image x:Name="FocusBackground"
           RelativeLayout.HeightConstraint="{ConstraintExpression Type=RelativeToParent, Property=Height, Factor=0.67}"
           RelativeLayout.WidthConstraint="{ConstraintExpression Type=RelativeToParent, Property=Width, Factor=0.67}"
           RelativeLayout.YConstraint="{ConstraintExpression Type=RelativeToParent, Property=Height, Factor=0.17}"
           RelativeLayout.XConstraint="{ConstraintExpression Type=RelativeToParent, Property=Width, Factor=0.17}"
           Source="btn_viewer_control_focused.png"
           Opacity="0.2"
           IsVisible="{Binding Path=IsFocused, Source={x:Reference Name=ControlButton}}"/>
    <Image x:Name="Icon"
           RelativeLayout.HeightConstraint="{ConstraintExpression Type=RelativeToParent, Property=Height, Factor=0.458}"
           RelativeLayout.WidthConstraint="{ConstraintExpression Type=RelativeToParent, Property=Width, Factor=0.458}"
           RelativeLayout.YConstraint="{ConstraintExpression Type=RelativeToParent, Property=Height, Factor=0.27}"
           RelativeLayout.XConstraint="{ConstraintExpression Type=RelativeToParent, Property=Width, Factor=0.27}"/>
    <Button x:Name="ControlButton"
            RelativeLayout.HeightConstraint="{ConstraintExpression Type=RelativeToView, ElementName=FocusBackground, Factor=1}"
            RelativeLayout.WidthConstraint="{ConstraintExpression Type=RelativeToView, ElementName=FocusBackground, Factor=1}"
            Opacity="0"
            Command="{Binding ControlButtonCommand}"/>
</RelativeLayout>

```

**Step 3: PlayerButton 프로퍼티 추가**

**PlayerButton** 의 **Icon** Image의 **Source** 를 변경하기 위해 **ButtonImage** 프로퍼티를 추가합니다.

[PlayerButton.xaml.cs]

<highlight>9-17</highlight>

```csharp
using Xamarin.Forms;
using Xamarin.Forms.Xaml;

namespace VideoPlayerLite.Views
{
    [XamlCompilation(XamlCompilationOptions.Compile)]
    public partial class PlayerButton : RelativeLayout
    {
        public string ButtonImage
        {
            get => Icon.Source.ToString();
            set
            {
                Icon.Source = value;
                InvokePropertyChanged();
            }
        }

        public PlayerButton()
        {
            InitializeComponent();
        }
    }
}

```

**PlayerButton** 이 클릭되었을 때 어떤 버튼이 클릭되었는지 구분을 위해 **ButtonName** 프로퍼티를 추가합니다.

이 프로퍼티는 이전에 바인딩한 **ControlButtonCommand** 의 **CommandParameter** 로 전달됩니다.

[PlayerButton.xaml.cs]

<highlight>19-23</highlight>

```csharp
using Xamarin.Forms;
using Xamarin.Forms.Xaml;

namespace VideoPlayerLite.Views
{
    [XamlCompilation(XamlCompilationOptions.Compile)]
    public partial class PlayerButton : RelativeLayout
    {
        public string ButtonImage
        {
            get => Icon.Source.ToString();
            set
            {
                Icon.Source = value;
                InvokePropertyChanged();
            }
        }

        public string ButtonName
        {
            get => ControlButton.CommandParameter.ToString();
            set => ControlButton.CommandParameter = value;
        }

        public PlayerButton()
        {
            InitializeComponent();
        }
    }
}

```

**PlayerButton** 에 설정한 **Clicked** 이벤트 핸들러가 **ControlButton** 이 클릭되었을 때 **Invoke** 되도록 해줍니다.

이로서 **PlayerPage** 에서 **PlayerButton** 이 클릭 되었을 때 처리가 가능해집니다.

[PlayerButton.xaml.cs]

<highlight>10,32</highlight>

```csharp
using System;
using Xamarin.Forms;
using Xamarin.Forms.Xaml;

namespace VideoPlayerLite.Views
{
    [XamlCompilation(XamlCompilationOptions.Compile)]
    public partial class PlayerButton : RelativeLayout
    {
        public event EventHandler Clicked;

        public string ButtonImage
        {
            get => Icon.Source.ToString();
            set
            {
                Icon.Source = value;
                InvokePropertyChanged();
            }
        }

        public string ButtonName
        {
            get => ControlButton.CommandParameter.ToString();
            set => ControlButton.CommandParameter = value;
        }

        public PlayerButton()
        {
            InitializeComponent();

            ControlButton.Clicked += (s, e) => Clicked?.Invoke(this, EventArgs.Empty);
        }
    }
}

```

**Step 4: 기존의 Button을 PlayerButton으로 대체**

**PlayerPage** 내 **ControlPad** Grid에 있던 기존의 **Button** 들을 **PlayerButton** 으로 대체합니다.

[PlayerPage.xaml]

<highlight>35-49</highlight>

```xml
<?xml version="1.0" encoding="utf-8" ?>
<ContentPage xmlns="http://xamarin.com/schemas/2014/forms"
             xmlns:x="http://schemas.microsoft.com/winfx/2009/xaml"
             xmlns:Views="clr-namespace:VideoPlayerLite.Views"
             xmlns:ViewModels="clr-namespace:VideoPlayerLite.ViewModels"
             xmlns:Models="clr-namespace:VideoPlayerLite.Models"
             x:Class="VideoPlayerLite.Views.PlayerPage"
             NavigationPage.HasNavigationBar="false"
             FetchVideoCommand="{Binding FetchSelectedVideoCommand}">
    <ContentPage.BindingContext>
        <ViewModels:PlayerPageViewModel/>
    </ContentPage.BindingContext>
    <ContentPage.Resources>
        <ResourceDictionary>
            <Models:DurationConverter x:Key="DurationConverter"/>
        </ResourceDictionary>
    </ContentPage.Resources>
    <ContentPage.Content>
        <RelativeLayout>
            ...
            <Grid x:Name="ControlPad"
                  RelativeLayout.HeightConstraint="{ConstraintExpression Type=RelativeToParent, Property=Height, Factor=0.134}"
                  RelativeLayout.WidthConstraint="{ConstraintExpression Type=RelativeToParent, Property=Width, Factor=0.225}"
                  RelativeLayout.YConstraint="{ConstraintExpression Type=RelativeToParent, Property=Height, Factor=0.866}"
                  RelativeLayout.XConstraint="{ConstraintExpression Type=RelativeToParent, Property=Width, Factor=0.388}">
                <Grid.ColumnDefinitions>
                    <ColumnDefinition Width="*"/>
                    <ColumnDefinition Width="*"/>
                    <ColumnDefinition Width="*"/>
                </Grid.ColumnDefinitions>
                <Grid.RowDefinitions>
                    <RowDefinition Height="*"/>
                </Grid.RowDefinitions>

                <Views:PlayerButton x:Name="PlayPauseButton"
                                    ButtonName="PlayPause"
                                    ButtonImage="btn_viewer_control_pause_normal.png"
                                    Grid.Row="0"
                                    Grid.Column="1"/>
                <Views:PlayerButton x:Name="PrevButton"
                                    ButtonName="Previous"
                                    ButtonImage="btn_viewer_control_previous_normal.png"
                                    Grid.Row="0"
                                    Grid.Column="0"/>
                <Views:PlayerButton x:Name="NextButton"
                                    ButtonName="Next"
                                    ButtonImage="btn_viewer_control_next_normal.png"
                                    Grid.Row="0"
                                    Grid.Column="2"/>
            </Grid>
        </RelativeLayout>
    </ContentPage.Content>
</ContentPage>

```

# Implementing MediaRenderingView

## 1. MediaRenderingView 생성

<img src="/assets/images/tutorials/85/5.png" style="height:492px; width:1162px"/>

**PlayerPageViewModel** 은 **PlayerPage** 와 **Binding** 되어 **LibraryPage** 에서 선택한 비디오에 대한 정보를 가져오거나

이전, 이후의 비디오를 재생할 수 있도록 해줍니다.

**Step 1: PlayerPageViewModel 생성**

먼저 **ViewModels** 폴더에 " **PlayerPageViewModel"** 라는 이름의 클래스를 추가하고, **ViewModelBase** 를 **상속** 받습니다.

<img src="/assets/images/tutorials/97/5-1.png" style="height:345px; width:291px"/>

[PlayerPageViewModel.cs]

<highlight>3</highlight>

```csharp
namespace VideoPlayerLite.ViewModels
{
    public class PlayerPageViewModel : ViewModelBase
    {
    }
}

```

**Step 2: SelectedVideo 프로퍼티 추가**

현재 선택된 비디오에 대한 정보를 **PlayerPage** 에 알려주기 위해서 **PlayerPageViewModel** 에 **SelectedVideo** 프로퍼티를 추가합니다.

[PlayerPageViewModel.cs]

<highlight>7,9-17</highlight>

```csharp
using VideoPlayerLite.Models;

namespace VideoPlayerLite.ViewModels
{
    public class PlayerPageViewModel : ViewModelBase
    {
        private MediaItem selectedVideo;

        public MediaItem SelectedVideo
        {
            get { return selectedVideo; }
            set
            {
                selectedVideo = value;
                InvokePropertyChanged();
            }
        }
    }
}

```

**Step 3: Add two Commands**

**MediaItemProvider** 로 부터 선택된 비디오 정보를 가져오기 위해  **FetchSelectedVideoCommand** 를 추가합니다.

<img src="/assets/images/tutorials/97/5-2_.png" style="height:406px; width:605px"/>

[PlayerPageViewModel.cs]

<highlight>20,22-30,32-35</highlight>

```csharp
using VideoPlayerLite.Models;
using Xamarin.Forms;

namespace VideoPlayerLite.ViewModels
{
    public class PlayerPageViewModel : ViewModelBase
    {
        private MediaItem selectedVideo;

        public MediaItem SelectedVideo
        {
            get { return selectedVideo; }
            set
            {
                selectedVideo = value;
                InvokePropertyChanged();
            }
        }

        private Command fetchSelectedVideoCommand;

        public Command FetchSelectedVideoCommand
        {
            get => fetchSelectedVideoCommand;
            set
            {
                fetchSelectedVideoCommand = value;
                InvokePropertyChanged();
            }
        }

        public PlayerPageViewModel()
        {
            FetchSelectedVideoCommand = new Command(() => SelectedVideo = MediaItemProvider.Instance.SelectedItem);
        }
    }
}

```

그리고 현재 비디오를 **PlayerPage** 버튼의 이벤트를 통해 이전, 다음 비디오로 바꾸기 위해서  **ControllButtonCommand** 를 추가합니다.

[PlayerPageViewModel.cs]

<highlight>8,9,35,37-45,51-61</highlight>

```csharp
using VideoPlayerLite.Models;
using Xamarin.Forms;

namespace VideoPlayerLite.ViewModels
{
    public class PlayerPageViewModel : ViewModelBase
    {
        private static readonly string NEXT_BUTTON = "Next";
        private static readonly string PREV_BUTTON = "Previous";

        private MediaItem selectedVideo;

        public MediaItem SelectedVideo
        {
            get { return selectedVideo; }
            set
            {
                selectedVideo = value;
                InvokePropertyChanged();
            }
        }

        private Command fetchSelectedVideoCommand;

        public Command FetchSelectedVideoCommand
        {
            get => fetchSelectedVideoCommand;
            set
            {
                fetchSelectedVideoCommand = value;
                InvokePropertyChanged();
            }
        }

        private Command controlButtonCommand;

        public Command ControlButtonCommand
        {
            get => controlButtonCommand;
            set
            {
                controlButtonCommand = value;
                InvokePropertyChanged();
            }
        }

        public PlayerPageViewModel()
        {
            FetchSelectedVideoCommand = new Command(() => SelectedVideo = MediaItemProvider.Instance.SelectedItem);

            ControlButtonCommand = new Command<string>((buttonName) =>
            {
                if (buttonName == PREV_BUTTON)
                {
                    SelectedVideo = MediaItemProvider.Instance.MoveToPrev();
                }
                else if (buttonName == NEXT_BUTTON)
                {
                    SelectedVideo = MediaItemProvider.Instance.MoveToNext();
                }
            });
        }
    }
}

```

## 2. CustomRenderer 소개

<img src="/assets/images/tutorials/85/4.png" style="height:492px; width:1162px"/>

선택된 비디오에 대한 정보를 저장하기 위해 **ItemViewModel** 역시 약간의 수정이 필요합니다.

**Step 1: Add SetNewVideoCommand**

**<img src="/assets/images/tutorials/97/4-1_.png" style="height:406px; width:605px"/>**

먼저, **ItemViewModel** 에 **SetNewVideoCommand** 를 추가합니다.

**SetNewVideoCommand** 는 **LibraryPage** 에서 한 **ItemView** 가 클릭되었을 때 해당 비디오에 대한 정보를 **MediaItemProvider** 에 저장하는 역할을 합니다.

[ItemViewModel.cs]

<highlight>20,22-30,35</highlight>

```csharp
using VideoPlayerLite.Models;
using Xamarin.Forms;

namespace VideoPlayerLite.ViewModels
{
    public class ItemViewModel : ViewModelBase
    {
        private MediaItem videoItem;

        public MediaItem VideoItem
        {
            get => videoItem;
            set
            {
                videoItem = value;
                InvokePropertyChanged();
            }
        }

        private Command setNewVideoCommand;

        public Command SetNewVideoCommand
        {
            get => setNewVideoCommand;
            set
            {
                setNewVideoCommand = value;
                InvokePropertyChanged();
            }
        }

        public ItemViewModel(MediaItem item)
        {
            VideoItem = item;
            SetNewVideoCommand = new Command(() => MediaItemProvider.Instance.SelectedItem = VideoItem);
        }
    }
}

```

**Step 2: SetNewVideoCommand의 Binding 설정**

**ItemView** 내에 있는 **FocusButton** 의 **Command** 와  **SetNewVideoCommand** 를 **Binding** 합니다.

[ItemView.xaml]

<highlight>13</highlight>

```xml
<?xml version="1.0" encoding="utf-8" ?>
<RelativeLayout xmlns="http://xamarin.com/schemas/2014/forms"
                xmlns:x="http://schemas.microsoft.com/winfx/2009/xaml"
                x:Class="VideoPlayerLite.Views.ItemView"
                HorizontalOptions="Start">
    ...

    <Button x:Name="FocusButton"
            RelativeLayout.HeightConstraint="{ConstraintExpression Type=RelativeToView, ElementName=BackgroundView, Property=Height, Factor=0.95}"
            RelativeLayout.WidthConstraint="{ConstraintExpression Type=RelativeToView, ElementName=BackgroundView, Property=Width, Factor=0.96}"
            Opacity="0"
            Clicked="OnItemClicked"
            Command="{Binding SetNewVideoCommand}"/>
</RelativeLayout>

```

## 3. CustomRenderer 생성

이제 **PlayerPageViewModel** 과 **PlayerPage** 를 바인딩하면 선택된 비디오의 타이틀, 전체 시간을 볼 수 있고, 이전, 다음 비디오로 바꿔 볼 수 있을 것 입니다.

**Step 1: FetchVideoCommand BindableProperty 추가**

먼저 **PlayerPage** 에 **FetchVideoCommand**   **BindableProperty** 를 추가합니다.

[PlayerPage.xaml.cs]

<highlight>9,10-13</highlight>

```csharp
using Xamarin.Forms;
using Xamarin.Forms.Xaml;

namespace VideoPlayerLite.Views
{
    [XamlCompilation(XamlCompilationOptions.Compile)]
    public partial class PlayerPage : ContentPage
    {
        public static readonly BindableProperty FetchVideoCommandProperty = BindableProperty.Create("FetchVideoCommand", typeof(Command), typeof(PlayerPage), null);
        public Command FetchVideoCommand
        {
            get => (Command)GetValue(FetchVideoCommandProperty);
        }

        public PlayerPage()
        {
            InitializeComponent();
        }
    }
}


```

**Step 2: OnAppearing를 Override**

**OnAppearing** 을 **override** 하여 페이지가 화면에 나타날때 **FetchVideoCommand** 를 실행하게 합니다.

[PlayerPage.xaml.cs]

<highlight>20-25</highlight>

```csharp
using Xamarin.Forms;
using Xamarin.Forms.Xaml;

namespace VideoPlayerLite.Views
{
    [XamlCompilation(XamlCompilationOptions.Compile)]
    public partial class PlayerPage : ContentPage
    {
        public static readonly BindableProperty FetchVideoCommandProperty = BindableProperty.Create("FetchVideoCommand", typeof(Command), typeof(PlayerPage), null);
        public Command FetchVideoCommand
        {
            get => (Command)GetValue(FetchVideoCommandProperty);
        }

        public PlayerPage()
        {
            InitializeComponent();
        }

        protected override void OnAppearing()
        {
            base.OnAppearing();

            FetchVideoCommand.Execute(null);
        }
    }
}

```

**Step 3: Bind Properties**

**PlayerPage** 의 **BindingContext** 로 **PlayerPageViewModel** 을 설정하여 Binding의 소스로 사용합니다.

[PlayerPage.xaml]

<highlight>4,7-9</highlight>

```xml
<?xml version="1.0" encoding="utf-8" ?>
<ContentPage xmlns="http://xamarin.com/schemas/2014/forms"
             xmlns:x="http://schemas.microsoft.com/winfx/2009/xaml"
             xmlns:ViewModels="clr-namespace:VideoPlayerLite.ViewModels"
             x:Class="VideoPlayerLite.Views.PlayerPage"
             NavigationPage.HasNavigationBar="false">
    <ContentPage.BindingContext>
        <ViewModels:PlayerPageViewModel/>
    </ContentPage.BindingContext>

    ...
</ContentPage>

```

그리고 각 프로퍼티들을 **Binding** 해줍니다.

먼저, **PlayerPage** 의 **FetchVideoCommand** 와 **FetchSelectedVideoCommand** 를 바인딩 해줍니다.

<highlight>7</highlight>

```xml
<?xml version="1.0" encoding="utf-8" ?>
<ContentPage xmlns="http://xamarin.com/schemas/2014/forms"
             xmlns:x="http://schemas.microsoft.com/winfx/2009/xaml"
             xmlns:ViewModels="clr-namespace:VideoPlayerLite.ViewModels"
             x:Class="VideoPlayerLite.Views.PlayerPage"
             NavigationPage.HasNavigationBar="false"
             FetchVideoCommand="{Binding FetchSelectedVideoCommand}">
    <ContentPage.BindingContext>
        <ViewModels:PlayerPageViewModel/>
    </ContentPage.BindingContext>
    <ContentPage.Content>
        ...
    </ContentPage.Content>
</ContentPage>

```

그리고 **ItemTitle** Label의 **Text** 와  **SelectedVideo** 의 **Title** 을 바인딩 해줍니다.

[PlayerPage.xaml]

<highlight>19</highlight>

```xml
<?xml version="1.0" encoding="utf-8" ?>
<ContentPage xmlns="http://xamarin.com/schemas/2014/forms"
             xmlns:x="http://schemas.microsoft.com/winfx/2009/xaml"
             xmlns:ViewModels="clr-namespace:VideoPlayerLite.ViewModels"
             x:Class="VideoPlayerLite.Views.PlayerPage"
             NavigationPage.HasNavigationBar="false"
             FetchVideoCommand="{Binding FetchSelectedVideoCommand}">
    <ContentPage.BindingContext>
        <ViewModels:PlayerPageViewModel/>
    </ContentPage.BindingContext>
    <ContentPage.Content>
        <RelativeLayout>
            <Label x:Name="ItemTitle"
                   RelativeLayout.HeightConstraint="{ConstraintExpression Type=RelativeToParent, Property=Height, Factor=0.046}"
                   RelativeLayout.WidthConstraint="{ConstraintExpression Type=RelativeToParent, Property=Width, Factor=0.9}"
                   RelativeLayout.YConstraint="{ConstraintExpression Type=RelativeToParent, Property=Height, Factor=0.06}"
                   RelativeLayout.XConstraint="{ConstraintExpression Type=RelativeToParent, Property=Width, Factor=0.05}"
                   FontSize="Medium"
                   Text="{Binding SelectedVideo.Title}"/>
            ...
        </RelativeLayout>
    </ContentPage.Content>
</ContentPage>

```

**Duration** **Label** 의 **Text** 와 **SelectedVideo** 의 **Duration** 을 바인딩 해줍니다.

[PlayerPage.xaml]

<highlight>23</highlight>

```xml
<?xml version="1.0" encoding="utf-8" ?>
<ContentPage xmlns="http://xamarin.com/schemas/2014/forms"
             xmlns:x="http://schemas.microsoft.com/winfx/2009/xaml"
             xmlns:ViewModels="clr-namespace:VideoPlayerLite.ViewModels"
             x:Class="VideoPlayerLite.Views.PlayerPage"
             NavigationPage.HasNavigationBar="false"
             FetchVideoCommand="{Binding FetchSelectedVideoCommand}">
    <ContentPage.BindingContext>
        <ViewModels:PlayerPageViewModel/>
    </ContentPage.BindingContext>
    <ContentPage.Content>
        <RelativeLayout>
            ...
            <StackLayout RelativeLayout.HeightConstraint="{ConstraintExpression Type=RelativeToParent, Property=Height, Factor=0.045}"
                         RelativeLayout.WidthConstraint="{ConstraintExpression Type=RelativeToParent, Property=Width, Factor=0.127}"
                         RelativeLayout.YConstraint="{ConstraintExpression Type=RelativeToParent, Property=Height, Factor=0.911}"
                         RelativeLayout.XConstraint="{ConstraintExpression Type=RelativeToParent, Property=Width, Factor=0.05}"
                         Orientation="Horizontal">
                <Label x:Name="ItemPosition"
                       Text="00:00"/>
                <Label Text=" / " />
                <Label x:Name="Duration"
                       Text="{Binding SelectedVideo.Duration}"/>
            </StackLayout>
            ...
        </RelativeLayout>
    </ContentPage.Content>
</ContentPage>

```

마지막으로  **PrevButton** , **NextButton** 의 **Command** 와 **ControlButtonCommand** 를 각각 Binding합니다.

그리고 CommandParameter로 각 "Previous", "Next"를 설정합니다.

[PlayerPage.xaml]

<highlight>34-35,39-40</highlight>

```xml
<?xml version="1.0" encoding="utf-8" ?>
<ContentPage xmlns="http://xamarin.com/schemas/2014/forms"
             xmlns:x="http://schemas.microsoft.com/winfx/2009/xaml"
             xmlns:ViewModels="clr-namespace:VideoPlayerLite.ViewModels"
             x:Class="VideoPlayerLite.Views.PlayerPage"
             NavigationPage.HasNavigationBar="false"
             FetchVideoCommand="{Binding FetchSelectedVideoCommand}">
    <ContentPage.BindingContext>
        <ViewModels:PlayerPageViewModel/>
    </ContentPage.BindingContext>
    <ContentPage.Content>
        <RelativeLayout>
            ...
            <Grid x:Name="ControlPad"
                  RelativeLayout.HeightConstraint="{ConstraintExpression Type=RelativeToParent, Property=Height, Factor=0.134}"
                  RelativeLayout.WidthConstraint="{ConstraintExpression Type=RelativeToParent, Property=Width, Factor=0.225}"
                  RelativeLayout.YConstraint="{ConstraintExpression Type=RelativeToParent, Property=Height, Factor=0.866}"
                  RelativeLayout.XConstraint="{ConstraintExpression Type=RelativeToParent, Property=Width, Factor=0.388}">
                <Grid.ColumnDefinitions>
                    <ColumnDefinition Width="*"/>
                    <ColumnDefinition Width="*"/>
                    <ColumnDefinition Width="*"/>
                </Grid.ColumnDefinitions>
                <Grid.RowDefinitions>
                    <RowDefinition Height="*"/>
                </Grid.RowDefinitions>

                <Button x:Name="PlayPauseButton"
                        Grid.Row="0"
                        Grid.Column="1"/>
                <Button x:Name="PrevButton"
                        Grid.Row="0"
                        Grid.Column="0"
                        Command="{Binding ControlButtonCommand}"
                        CommandParameter="Previous"/>
                <Button x:Name="NextButton"
                        Grid.Row="0"
                        Grid.Column="2"
                        Command="{Binding ControlButtonCommand}"
                        CommandParameter="Next"/>
            </Grid>
        </RelativeLayout>
    </ContentPage.Content>
</ContentPage>

```

이제 어플리케이션을 실행시켜 확인해봅시다.

선택한 비디오의 제목, 전체 재생시간을 확인할 수 있게 되었습니다.

좌, 우측 버튼을 이용해서 이전, 다음 비디오에 대한 정보도 확인할 수 있습니다.

<img src="/assets/images/tutorials/85/6.png" style="height:675px; width:1200px"/>

[코드 스냅샷](https://tizenschool.org/assets/images/tutorials/97/Lect3_Snapshot02_Bind_PlayerPageViewModel.zip)

**Step 4: Converter 추가**

비디오의 전체 재생시간은 현재 밀리초 단위로 저장되어 있습니다.

이를 "분:초" 단위로 쉽게 변환시켜 표시하기 위해서 **Converter** 를 만들어 적용시켜보도록 하겠습니다.

먼저 " **DurationConverter"** 라는 이름의 클래스를 **Models** 폴더에 추가하고 **IValueConverter** 인터페이스를 상속받아 구현하겠습니다.

<img src="/assets/images/tutorials/97/6-1.png" style="height:342px; width:288px"/>

[DurationConverter.cs]

<highlight>7,9-12,14-17</highlight>

```csharp
using System;
using System.Globalization;
using Xamarin.Forms;

namespace VideoPlayerLite.Models
{
    public class DurationConverter : IValueConverter
    {
        public object Convert(object value, Type targetType, object parameter, CultureInfo culture)
        {
            throw new NotImplementedException();
        }

        public object ConvertBack(object value, Type targetType, object parameter, CultureInfo culture)
        {
            throw new NotImplementedException();
        }
    }
}


```

그 중 **Convert** 메소드를 수정하여 밀리초를 "분:초" 형태로 바꾸어 반환하도록 합니다.

[DurationConverter.cs]

<highlight>11</highlight>

```csharp
using System;
using System.Globalization;
using Xamarin.Forms;

namespace VideoPlayerLite.Models
{
    public class DurationConverter : IValueConverter
    {
        public object Convert(object value, Type targetType, object parameter, CultureInfo culture)
        {
            return TimeSpan.FromMilliseconds((int)value).ToString("mm':'ss");
        }

        public object ConvertBack(object value, Type targetType, object parameter, CultureInfo culture)
        {
            throw new NotImplementedException();
        }
    }
}

```

그리고 **DurationConverter** 를 Binding하고 다시 어플리케이션을 실행해 확인해보도록 하겠습니다.

먼저 **PlayerPage** 에 **Models** 네임스페이스를 선언하고, **ResourceDirectory** 에 **DurationConverter** 를 등록합니다.

그리고 전체 시간을 나타내는 **Duration** Label의 **Text** 에 **Converter** 를 바인딩합니다.

[PlayerPage.xaml]

<highlight>5,12-16,29</highlight>

```xml
<?xml version="1.0" encoding="utf-8" ?>
<ContentPage xmlns="http://xamarin.com/schemas/2014/forms"
             xmlns:x="http://schemas.microsoft.com/winfx/2009/xaml"
             xmlns:ViewModels="clr-namespace:VideoPlayerLite.ViewModels"
             xmlns:Models="clr-namespace:VideoPlayerLite.Models"
             x:Class="VideoPlayerLite.Views.PlayerPage"
             NavigationPage.HasNavigationBar="false"
             FetchVideoCommand="{Binding FetchSelectedVideoCommand}">
    <ContentPage.BindingContext>
        <ViewModels:PlayerPageViewModel/>
    </ContentPage.BindingContext>
    <ContentPage.Resources>
        <ResourceDictionary>
            <Models:DurationConverter x:Key="DurationConverter"/>
        </ResourceDictionary>
    </ContentPage.Resources>
    <ContentPage.Content>
        <RelativeLayout>
            ...
            <StackLayout RelativeLayout.HeightConstraint="{ConstraintExpression Type=RelativeToParent, Property=Height, Factor=0.045}"
                         RelativeLayout.WidthConstraint="{ConstraintExpression Type=RelativeToParent, Property=Width, Factor=0.127}"
                         RelativeLayout.YConstraint="{ConstraintExpression Type=RelativeToParent, Property=Height, Factor=0.911}"
                         RelativeLayout.XConstraint="{ConstraintExpression Type=RelativeToParent, Property=Width, Factor=0.05}"
                         Orientation="Horizontal">
                <Label x:Name="ItemPosition"
                       Text="00:00"/>
                <Label Text=" / " />
                <Label x:Name="Duration"
                       Text="{Binding SelectedVideo.Duration, Converter={StaticResource DurationConverter}}"/>
            </StackLayout>
            ...
        </RelativeLayout>
    </ContentPage.Content>
</ContentPage>

```

이전에 밀리초로 나타난 부분이 분:초 형태로 바뀌어 표시되는 것을 보실 수 있습니다.

<img src="/assets/images/tutorials/85/6-2.png" style="height:675px; width:1200px"/>

[코드 스냅샷](https://tizenschool.org/assets/images/tutorials/97/Lect3_Snapshot03_Add_Converter.zip)

## 4. Tizen Player에 대한 이해

<img src="/assets/images/tutorials/97/11.png" style="height:329px; width:786px"/>

**PlayerPage** , **MediaRenderingView** 에서 변경된 프로퍼티들을 상대 **View** 에게 알려주기 위해서

위의 그림과 같이 **PlayerPageViewModel** 를 통해 바인딩합니다.

**PlayerPage** 에서 **PauseButton** 을 눌렀을 때의 상황을 토대로 자세히 알아보도록 하겠습니다.

<img src="/assets/images/tutorials/97/11-1.png" style="height:556px; width:786px"/>

**PlayerPage** 에서 **PauseButton** 을 누르게 되면 **PlayerPage** 의 **PlayerStatus** 는 **Paused** 로 바뀌게 될 것이고,

이와 비인딩되어 있는 **PlayerPageViewModel** 의 **CurrentStatus** 도 **Paused** 로 바뀌게 될 것입니다.

마찬가지로 **MediaRenderingView** 의 **CurrentStatus** 도 **Paused** 로 변경이 되고,

최종적으로 **MediaRenderingView** 의 **OnElementPropertyChanged** 내에서 **Player.Pause()** 로 **재생이 일시정지** 됩니다.

다른 예를 통해 더 알아보도록 하겠습니다.

<img src="/assets/images/tutorials/97/11-2.png" style="height:556px; width:786px"/>

반대로 **Player** 의 현재 재생 시간을 **Timer** 를 통해 **MediaRenderingView** 의 **PlayPosition** 을 업데이트하면,

이와 바인딩 되어있는 **PlayerPageViewModel** 의 **CurrentPosition** 이 바뀌게 되고,

마찬가지로 **PlayerPage** 의 **ItemPosition** Label의 **Text가 갱신** 됩니다.

위와 같은 방법으로 **CustomRender** 와 이와 관련된 **View** , **ViewModel** 들을 구현, 수정해보도록 하겠습니다.

## 5. CustomRenderer 구현 (1/4)

**Tizen의 Player** 에는 비디오 **재생을 위한 몇가지 상태** 가 정의되어 있습니다.

아래를 통해 그 부분을 간략하게나마 알아보도록 하겠습니다.

<img src="/assets/images/tutorials/97/10k.png" style="height:515px; width:880px"/>

위에서 볼 수 있듯 비디오 재생을 하기 위해선 대략 아래와 같은 과정이 필요합니다.

먼저 **Dispaly** 를 현재 **Control** , 즉 **MediaView** 로 지정하고,

현재 **Element** , **MediaRenderingView** 의 **VideoPath** 프로퍼티를 통해 재생할 비디오를 지정합니다.

**PrepareAsync** 를 이용하여 재생할 준비가 끝나면 재생이 가능해 집니다.

<highlight>5,7,11</highlight>

```csharp
private async void PlayVideo()
{
    ...

    player.Display = new Display(Control);

    player.SetSource(new MediaUriSource(Element.VideoPath));

    ...

    await player.PrepareAsync();

    ...
}

```

보다 상세한 정보는 아래의 링크를 참조바랍니다.

[Tizen Player](https://developer.tizen.org/dev-guide/csapi/api/Tizen.Multimedia.Player.html)

## 6. CustomRenderer 구현 (2/4)

**Step 1: PlayerStatus 프로퍼티 추가**

**Tizen Player** 의 각 상태에 대응하는 **PlayerStatus** 를 추가해줍니다.

여기서 **Preparing** 은 **Player** 의 **PrepareAsync** 이 종료되지 않은 시점에서 **추가 입력으로 인한 오류를 방지** 하기 위함입니다.

[MediaRenderingViewRenderer.cs]

<highlight>7-13</highlight>

```csharp
using VideoPlayerLite.Models;
using Xamarin.Forms;
using Xamarin.Forms.Xaml;

namespace VideoPlayerLite.Views
{
    public enum PlayerStatus
    {
        Playing,
        Paused,
        Stopped,
        Preparing
    }

    [XamlCompilation(XamlCompilationOptions.Compile)]
	public partial class MediaRenderingView : View
	{
        public MediaRenderingView ()
		{
			InitializeComponent ();
		}
	}
}

```

**Step 2: 프로퍼티 추가**

**MediaRenderingView** 에 필요한 세 가지 프로퍼티를 추가해야 합니다.

재생할 **비디오에 대한 정보** 를 위해 **CurrentVideo** , **Player** 의 **현재 상태** 를 알기 위한 **CurrentStatus** ,

그리고 **현재 재생 시간** 을 위해 **CurrentPosition** 을 추가하도록 하겠습니다.

[MediaRenderingViewRenderer.cs]

<highlight>18-22,24,26-31,33-37</highlight>

```csharp
using VideoPlayerLite.Models;
using Xamarin.Forms;
using Xamarin.Forms.Xaml;

namespace VideoPlayerLite.Views
{
    public enum PlayerStatus
    {
        Playing,
        Paused,
        Stopped,
        Preparing
    }

    [XamlCompilation(XamlCompilationOptions.Compile)]
	public partial class MediaRenderingView : View
	{
        public static readonly BindableProperty CurrentVideoProperty = BindableProperty.Create("CurrentVideo", typeof(MediaItem), typeof(MediaRenderingView), null);
        public MediaItem CurrentVideo
        {
            get => (MediaItem)GetValue(CurrentVideoProperty);
        }

        public string VideoPath { get => CurrentVideo?.Path; }

        public static readonly BindableProperty CurrentStatusProperty = BindableProperty.Create("CurrentStatus", typeof(PlayerStatus), typeof(MediaRenderingView), PlayerStatus.Stopped, BindingMode.TwoWay);
        public PlayerStatus CurrentStatus
        {
            get => (PlayerStatus)GetValue(CurrentStatusProperty);
            set => SetValue(CurrentStatusProperty, value);
        }

        public static readonly BindableProperty CurrentPositionProperty = BindableProperty.Create("CurrentPosition", typeof(int), typeof(MediaRenderingView), 0, BindingMode.OneWayToSource);
        public int CurrentPosition
        {
            get => (int)GetValue(CurrentPositionProperty);
        }

        public MediaRenderingView ()
		{
			InitializeComponent ();
		}
	}
}

```

**Step 3: Tizen Player 추가**

**MediaRenderingViewRenderer** 에 **Tizen Player** 를 선언해주고 **OnElementChanged** 내에서 인스턴스화 해줍니다.

이때 **NewElement** 가 **null** 이 아닐 때는 **Renderer** 에 **View** 가 **Binding되었을 때를 의미** 합니다.

[MediaRenderingViewRenderer.cs]

<highlight>12,23-26</highlight>

```csharp
using System.ComponentModel;
using Tizen.Multimedia;
using VideoPlayerLite.Tizen.Tizen.TV.Renderer;
using VideoPlayerLite.Views;
using Xamarin.Forms.Platform.Tizen;

[assembly: ExportRenderer(typeof(MediaRenderingView), typeof(MediaRenderingViewRenderer))]
namespace VideoPlayerLite.Tizen.Tizen.TV.Renderer
{
    public class MediaRenderingViewRenderer : ViewRenderer<MediaRenderingView, MediaView>
    {
        private Player player;

        protected override void OnElementChanged(ElementChangedEventArgs<MediaRenderingView> e)
        {
            base.OnElementChanged(e);

            if (Control == null)
            {
                SetNativeControl(new MediaView(Forms.Context.MainWindow));
            }

            if (e.NewElement != null)
            {
                player = new Player();
            }
        }

        protected override void OnElementPropertyChanged(object sender, PropertyChangedEventArgs e)
        {
            base.OnElementPropertyChanged(sender, e);
        }
    }
}


```

그리고 **OnElementPropertyChaged** 내에  **Element** , **MediaRenderingView** 에 추가한 프로퍼티들의 변화에 따른 동작을 구현해 줍니다.

**CurrentVideo** 가 바뀌었을 때는 **바뀐 비디오를 재생** 할 수 있도록 해주고,

**CurrentStatus** 가 바뀌었을 때는 **Playing** , **Paused** , **Stopped** 에 알맞게 **비디오를 재생** 하거나, **일시정지** 하거나, **재생을 완전히 중단** 하도록 합니다.

[MediaRenderingViewRenderer.cs]

<highlight>24-63,66-69</highlight>

```csharp
using System;
using System.ComponentModel;
using Tizen.Multimedia;
using VideoPlayerLite.Tizen.Tizen.TV.Renderer;
using VideoPlayerLite.Views;
using Xamarin.Forms.Platform.Tizen;

[assembly: ExportRenderer(typeof(MediaRenderingView), typeof(MediaRenderingViewRenderer))]
namespace VideoPlayerLite.Tizen.Tizen.TV.Renderer
{
    public class MediaRenderingViewRenderer : ViewRenderer<MediaRenderingView, MediaView>
    {
        private Player player;

        protected override void OnElementChanged(ElementChangedEventArgs<MediaRenderingView> e)
        {
            /* */
        }

        protected override void OnElementPropertyChanged(object sender, PropertyChangedEventArgs e)
        {
            base.OnElementPropertyChanged(sender, e);

            if (e.PropertyName == MediaRenderingView.CurrentVideoProperty.PropertyName)
            {
                PlayVideo();
            }
            else if (e.PropertyName == MediaRenderingView.CurrentStatusProperty.PropertyName)
            {
                switch (Element.CurrentStatus)
                {
                    case PlayerStatus.Playing:
                        if (player.State == PlayerState.Idle)
                        {
                            PlayVideo();
                        }

                        if (player.State == PlayerState.Ready || player.State == PlayerState.Paused)
                        {
                            player.Start();
                        }
                        break;
                    case PlayerStatus.Paused:
                        if (player.State == PlayerState.Playing)
                        {
                            player.Pause();
                        }
                        break;
                    case PlayerStatus.Stopped:
                        if (player.State == PlayerState.Playing || player.State == PlayerState.Paused)
                        {
                            player.Stop();
                        }

                        if (player.State == PlayerState.Ready)
                        {
                            player.Unprepare();
                        }
                        break;
                    default:
                        break;
                }
            }
        }

        private void PlayVideo()
        {
            throw new NotImplementedException();
        }
    }
}


```

**Step 4: PlayVideo 메소드 구현**

**PlayVideo** 메소드를 구현해보도록 하겠습니다.

먼저 **이미 재생되고 있는 상황** 에 대비하여 **Stop** , **Unprepare** 메소드를 활용하여 **Player** 를 **Idle 상태로** 만들어 줍니다.

그 후에 **Display** 와 **Source** 를 **지정** 해주고 **PrepareAsync** 메소드를 이용하여 **재생 준비 상태** 로 만들어줍니다.

이때  **SetValueFromRenderer** 메소드를 이용해서 **Element** ( **MediaRenderingView** )의 **CurrentStatus** 를 **Preparing** 으로 **변경** 하였다가

**Prepare** 가 종료되면 **Playing** 으로 다시 바꿔 **재생** 될 수 있도록 합니다.

[MediaRenderingViewRenderer.cs]

<highlight>26-59</highlight>

```csharp
using System;
using System.ComponentModel;
using Tizen.Multimedia;
using VideoPlayerLite.Tizen.Tizen.TV.Renderer;
using VideoPlayerLite.Views;
using Xamarin.Forms;
using Xamarin.Forms.Platform.Tizen;

[assembly: ExportRenderer(typeof(MediaRenderingView), typeof(MediaRenderingViewRenderer))]
namespace VideoPlayerLite.Tizen.Tizen.TV.Renderer
{
    public class MediaRenderingViewRenderer : ViewRenderer<MediaRenderingView, MediaView>
    {
        private Player player;

        protected override void OnElementChanged(ElementChangedEventArgs<MediaRenderingView> e)
        {
            /* */
        }

        protected override void OnElementPropertyChanged(object sender, PropertyChangedEventArgs e)
        {
            /* */
        }

        private async void PlayVideo()
        {
            if (player.State == PlayerState.Playing || player.State == PlayerState.Paused)
            {
                player.Stop();
            }

            if (player.State == PlayerState.Ready)
            {
                player.Unprepare();
            }

            try
            {
                player.Display = new Display(Control);
                player.SetSource(new MediaUriSource(Element.VideoPath));
            }
            catch (Exception e)
            {
                Console.WriteLine("Player: " + e.Message);
            }

            ((IElementController)Element).SetValueFromRenderer(MediaRenderingView.CurrentStatusProperty, PlayerStatus.Preparing);

            try
            {
                await player.PrepareAsync();
                ((IElementController)Element).SetValueFromRenderer(MediaRenderingView.CurrentStatusProperty, PlayerStatus.Playing);
            }
            catch (Exception e)
            {
                ((IElementController)Element).SetValueFromRenderer(MediaRenderingView.CurrentStatusProperty, PlayerStatus.Stopped);
            }
        }
    }
}

```

## 7. CustomRenderer 구현 (3/4)

**Step 5: Playback 이벤트 핸들러 추가**

비디오가 **끝까지 재생** 되었거나 **의도치않게 중단** 되었을 경우의 처리를 위해서

**Player** 의 **PlaybackCompleted** , **PlaybackInterrupted** 두 이벤트에 이벤트 핸들러를 추가해줍니다.

두 핸들러에서는  **SetValueFromRenderer** 메소드로 **Element** 의 **CurrentStatus** 를 **Stopped** 로 만들어 **Player** 가 **Idle 상태** 가 될 수 있도록 합니다.

[MediaRenderingViewRenderer.cs]

<highlight>27-31,37-38,42-45,47-50</highlight>

```csharp
using System;
using System.ComponentModel;
using System.Threading;
using Tizen.Multimedia;
using VideoPlayerLite.Tizen.Tizen.TV.Renderer;
using VideoPlayerLite.Views;
using Xamarin.Forms;
using Xamarin.Forms.Platform.Tizen;

[assembly: ExportRenderer(typeof(MediaRenderingView), typeof(MediaRenderingViewRenderer))]
namespace VideoPlayerLite.Tizen.Tizen.TV.Renderer
{
    public class MediaRenderingViewRenderer : ViewRenderer<MediaRenderingView, MediaView>
    {
        private Player player;
        private Timer playPositionTimer;

        protected override void OnElementChanged(ElementChangedEventArgs<MediaRenderingView> e)
        {
            base.OnElementChanged(e);

            if (Control == null)
            {
                SetNativeControl(new MediaView(Forms.Context.MainWindow));
            }

            if (e.OldElement != null)
            {
                player.PlaybackCompleted -= PlaybackCompleted;
                player.PlaybackInterrupted -= PlaybackInterrupted;
            }

            if (e.NewElement != null)
            {
                player = new Player();

                player.PlaybackCompleted += PlaybackCompleted;
                player.PlaybackInterrupted += PlaybackInterrupted;
            }
        }

        private void PlaybackInterrupted(object sender, PlaybackInterruptedEventArgs e)
        {
            ((IElementController)Element).SetValueFromRenderer(MediaRenderingView.CurrentStatusProperty, PlayerStatus.Stopped);
        }

        private void PlaybackCompleted(object sender, EventArgs e)
        {
            ((IElementController)Element).SetValueFromRenderer(MediaRenderingView.CurrentStatusProperty, PlayerStatus.Stopped);
        }

        protected override void OnElementPropertyChanged(object sender, PropertyChangedEventArgs e)
        {
            /* */
        }

        private async void PlayVideo()
        {
            /* */
        }
    }
}


```

**Step 6: CurrentVideo 프로퍼티 Binding**

**MediaRenderigView** 의 **CurrentVideo** 와 **PlayerPageViewModel** 의 **SeletedVideo** 를 바인딩합니다.

[MediaRenderingView.xaml]

<highlight>5</highlight>

```xml
<?xml version="1.0" encoding="UTF-8"?>
<View xmlns="http://xamarin.com/schemas/2014/forms"
      xmlns:x="http://schemas.microsoft.com/winfx/2009/xaml"
      x:Class="VideoPlayerLite.Views.MediaRenderingView"
      CurrentVideo="{Binding SelectedVideo}"/>

```

어플리케이션을 실행하여 선택한 비디오가 재생되는지 확인합니다.

<img src="/assets/images/tutorials/85/13.png" style="height:675px; width:1200px"/>

[코드 스냅샷](https://tizenschool.org/assets/images/tutorials/97/Lect3_Snapshot06_Impl_MediaRenderingViewRenderer_1.zip)

## 8. CustomRenderer 구현 (4/4)

**Step 7: PlayPosition를 위한 Timer 추가**

**Player** 의 현재 재생시간을 주기적으로 **MediaRenderingView** 에 업데이트 하기 위한  **Timer** 를 선언합니다.

[MediaRenderingViewRenderer.cs]

<highlight>16</highlight>

```csharp
using System;
using System.ComponentModel;
using System.Threading;
using Tizen.Multimedia;
using VideoPlayerLite.Tizen.Tizen.TV.Renderer;
using VideoPlayerLite.Views;
using Xamarin.Forms;
using Xamarin.Forms.Platform.Tizen;

[assembly: ExportRenderer(typeof(MediaRenderingView), typeof(MediaRenderingViewRenderer))]
namespace VideoPlayerLite.Tizen.Tizen.TV.Renderer
{
    public class MediaRenderingViewRenderer : ViewRenderer<MediaRenderingView, MediaView>
    {
        private Player player;
        private Timer playPositionTimer;

        protected override void OnElementChanged(ElementChangedEventArgs<MediaRenderingView> e)
        {
            /* */
        }

        protected override void OnElementPropertyChanged(object sender, PropertyChangedEventArgs e)
        {
            /* */
        }

        private async void PlayVideo()
        {
            /* */
        }
    }
}

```

**Step 8: StartTimer, StopTimer 메소드 구현**

그리고 **StartTimer** , **StopTimer** 메소드를 구현해보도록 하겠습니다.

**Player** 의 **GetPlayPosition** 메소드를 통해 받아온 현재 재생 시간을 **SetValueFromRenderer** 메소드로

**MediaRenderingView** 의 **CurrentPosition** 에 업데이트하도록 합니다.

[MediaRenderingViewRenderer.cs]

<highlight>43-74,76-80</highlight>

```csharp
using System;
using System.ComponentModel;
using System.Threading;
using Tizen.Multimedia;
using VideoPlayerLite.Tizen.Tizen.TV.Renderer;
using VideoPlayerLite.Views;
using Xamarin.Forms;
using Xamarin.Forms.Platform.Tizen;

[assembly: ExportRenderer(typeof(MediaRenderingView), typeof(MediaRenderingViewRenderer))]
namespace VideoPlayerLite.Tizen.Tizen.TV.Renderer
{
    public class MediaRenderingViewRenderer : ViewRenderer<MediaRenderingView, MediaView>
    {
        private Player player;
        private Timer playPositionTimer;

        protected override void OnElementChanged(ElementChangedEventArgs<MediaRenderingView> e)
        {
            /* */
        }

        private void PlaybackInterrupted(object sender, PlaybackInterruptedEventArgs e)
        {
            /* */
        }

        private void PlaybackCompleted(object sender, EventArgs e)
        {
            /* */
        }

        protected override void OnElementPropertyChanged(object sender, PropertyChangedEventArgs e)
        {
            /* */
        }

        private async void PlayVideo()
        {
            /* */
        }

        private void StartTimer()
        {
            if (playPositionTimer != null)
            {
                return;
            }

            playPositionTimer = new Timer((x) =>
            {
                Device.BeginInvokeOnMainThread(() =>
                {
                    if (playPositionTimer != null)
                    {
                        int playPosition = 0;

                        if (player != null && (player.State == PlayerState.Ready || player.State == PlayerState.Paused || player.State == PlayerState.Playing))
                        {
                            playPosition = player.GetPlayPosition();
                        }

                        if (Element == null)
                        {
                            StopTimer();
                        }
                        else
                        {
                            ((IElementController)Element).SetValueFromRenderer(MediaRenderingView.CurrentPositionProperty, playPosition);
                        }
                    }
                });
            }, null, 0, 250);
        }

        private void StopTimer()
        {
            playPositionTimer?.Dispose();
            playPositionTimer = null;
        }
    }
}


```

재생할 비디오가 변경되었을 때 **StopTimer** 메소드로 정지시키거나, 재생이 시작될 때 **StartTimer** 메소드로 시작시킬 수 있도록

각 필요한 부분에 해당 메소드들을 추가해줍니다.

[MediaRenderingViewRenderer.cs]

<highlight>29,38</highlight>

```csharp
using System;
using System.ComponentModel;
using System.Threading;
using Tizen.Multimedia;
using VideoPlayerLite.Tizen.Tizen.TV.Renderer;
using VideoPlayerLite.Views;
using Xamarin.Forms;
using Xamarin.Forms.Platform.Tizen;

[assembly: ExportRenderer(typeof(MediaRenderingView), typeof(MediaRenderingViewRenderer))]
namespace VideoPlayerLite.Tizen.Tizen.TV.Renderer
{
    public class MediaRenderingViewRenderer : ViewRenderer<MediaRenderingView, MediaView>
    {
        private Player player;
        private Timer playPositionTimer;

              protected override void OnElementChanged(ElementChangedEventArgs<MediaRenderingView> e)
        {
            base.OnElementChanged(e);

            if (Control == null)
            {
                SetNativeControl(new MediaView(Forms.Context.MainWindow));
            }

            if (e.OldElement != null)
            {
                StopTimer();
                player.PlaybackCompleted -= PlaybackCompleted;
                player.PlaybackInterrupted -= PlaybackInterrupted;
            }

            if (e.NewElement != null)
            {
                player = new Player();

                StopTimer();
                player.PlaybackCompleted += PlaybackCompleted;
                player.PlaybackInterrupted += PlaybackInterrupted;
            }
        }

        private void PlaybackInterrupted(object sender, PlaybackInterruptedEventArgs e)
        {
            /* */
        }

        private void PlaybackCompleted(object sender, EventArgs e)
        {
            /* */
        }

        protected override void OnElementPropertyChanged(object sender, PropertyChangedEventArgs e)
        {
            /* */
        }

        private async void PlayVideo()
        {
            /* */
        }

        private void StartTimer()
        {
            /* */
        }

        private void StopTimer()
        {
            /* */
        }

    }
}

```

<highlight>39,55,64,77</highlight>

```csharp
using System;
using System.ComponentModel;
using System.Threading;
using Tizen.Multimedia;
using VideoPlayerLite.Tizen.Tizen.TV.Renderer;
using VideoPlayerLite.Views;
using Xamarin.Forms;
using Xamarin.Forms.Platform.Tizen;

[assembly: ExportRenderer(typeof(MediaRenderingView), typeof(MediaRenderingViewRenderer))]
namespace VideoPlayerLite.Tizen.Tizen.TV.Renderer
{
    public class MediaRenderingViewRenderer : ViewRenderer<MediaRenderingView, MediaView>
    {
        private Player player;
        private Timer playPositionTimer;

        protected override void OnElementChanged(ElementChangedEventArgs<MediaRenderingView> e)
        {
            /* */
        }

        private void PlaybackInterrupted(object sender, PlaybackInterruptedEventArgs e)
        {
            /* */
        }

        private void PlaybackCompleted(object sender, EventArgs e)
        {
            /* */
        }

        protected override void OnElementPropertyChanged(object sender, PropertyChangedEventArgs e)
        {
            base.OnElementPropertyChanged(sender, e);

            if (e.PropertyName == MediaRenderingView.CurrentVideoProperty.PropertyName)
            {
                StopTimer();
                PlayVideo();
            }
            else if (e.PropertyName == MediaRenderingView.CurrentStatusProperty.PropertyName)
            {
                switch (Element.CurrentStatus)
                {
                    case PlayerStatus.Playing:
                        if (player.State == PlayerState.Idle)
                        {
                            PlayVideo();
                        }

                        if (player.State == PlayerState.Ready || player.State == PlayerState.Paused)
                        {
                            player.Start();
                            StartTimer();
                        }
                        break;
                    case PlayerStatus.Paused:
                        if (player.State == PlayerState.Playing)
                        {
                            player.Pause();
                        }

                        StopTimer();
                        break;
                    case PlayerStatus.Stopped:
                        if (player.State == PlayerState.Playing || player.State == PlayerState.Paused)
                        {
                            player.Stop();
                        }

                        if (player.State == PlayerState.Ready)
                        {
                            player.Unprepare();
                        }

                        StopTimer();
                        break;
                    default:
                        break;
                }
            }
        }

        private async void PlayVideo()
        {
            /* */
        }

        private void StartTimer()
        {
            /* */
        }

        private void StopTimer()
        {
            /* */
        }
    }
}

```

**Step 9: CurrentPositon 프로퍼티 Binding.**

**MediaRenderingView** 에서의 현재 재생시간 변화를 **PlayerPage** 로 전달해 주기 위해 **PlayerPageViewModel** 에 **CurrentPosition** 프로퍼티를 추가합니다.

[PlayerPageViewModel.cs]

<highlight>47,49-57</highlight>

```csharp
using VideoPlayerLite.Models;
using Xamarin.Forms;

namespace VideoPlayerLite.ViewModels
{
    public class PlayerPageViewModel : ViewModelBase
    {
        private static readonly string NEXT_BUTTON = "Next";
        private static readonly string PREV_BUTTON = "Previous";

        private MediaItem selectedVideo;

        public MediaItem SelectedVideo
        {
            get { return selectedVideo; }
            set
            {
                selectedVideo = value;
                InvokePropertyChanged();
            }
        }

        private Command fetchSelectedVideoCommand;

        public Command FetchSelectedVideoCommand
        {
            get => fetchSelectedVideoCommand;
            set
            {
                fetchSelectedVideoCommand = value;
                InvokePropertyChanged();
            }
        }

        private Command controlButtonCommand;

        public Command ControlButtonCommand
        {
            get => controlButtonCommand;
            set
            {
                controlButtonCommand = value;
                InvokePropertyChanged();
            }
        }

        private int currentPosition;

        public int CurrentPosition
        {
            get => currentPosition;
            set
            {
                currentPosition = value;
                InvokePropertyChanged();
            }
        }

        public PlayerPageViewModel()
        {
            /* */
        }
    }
}

```

MediaRenderingView의 CurrentPosition과 PlayerPage내 ItemPosition Label의 Text를 PlayerPageViewModel의 CurrentPosition과 Binding합니다.

이때  **ItemPosition** Label의 **Text** 는 **Duration** 과 마찬가지로 **DurationConverter** 도 Binding해줍니다.

[MediaRenderingView.xaml]

<highlight>6</highlight>

```xml
<?xml version="1.0" encoding="UTF-8"?>
<View xmlns="http://xamarin.com/schemas/2014/forms"
      xmlns:x="http://schemas.microsoft.com/winfx/2009/xaml"
      x:Class="VideoPlayerLite.Views.MediaRenderingView"
      CurrentVideo="{Binding SelectedVideo}"
      CurrentPosition="{Binding CurrentPosition}"/>

```

[PlayerPage.xaml]

<highlight>30</highlight>

```xml
<?xml version="1.0" encoding="utf-8" ?>
<ContentPage xmlns="http://xamarin.com/schemas/2014/forms"
             xmlns:x="http://schemas.microsoft.com/winfx/2009/xaml"
             xmlns:Views="clr-namespace:VideoPlayerLite.Views"
             xmlns:ViewModels="clr-namespace:VideoPlayerLite.ViewModels"
             xmlns:Models="clr-namespace:VideoPlayerLite.Models"
             x:Class="VideoPlayerLite.Views.PlayerPage"
             NavigationPage.HasNavigationBar="false"
             FetchVideoCommand="{Binding FetchSelectedVideoCommand}">
    <ContentPage.BindingContext>
        <ViewModels:PlayerPageViewModel/>
    </ContentPage.BindingContext>
    <ContentPage.Resources>
        <ResourceDictionary>
            <Models:DurationConverter x:Key="DurationConverter"/>
        </ResourceDictionary>
    </ContentPage.Resources>
    <ContentPage.Content>
        <RelativeLayout>
            <Views:MediaRenderingView x:Name="RenderingView"
                                      RelativeLayout.HeightConstraint="{ConstraintExpression Type=RelativeToParent, Property=Height, Factor=1}"
                                      RelativeLayout.WidthConstraint="{ConstraintExpression Type=RelativeToParent, Property=Width, Factor=1}"/>
            ...
            <StackLayout RelativeLayout.HeightConstraint="{ConstraintExpression Type=RelativeToParent, Property=Height, Factor=0.045}"
                         RelativeLayout.WidthConstraint="{ConstraintExpression Type=RelativeToParent, Property=Width, Factor=0.127}"
                         RelativeLayout.YConstraint="{ConstraintExpression Type=RelativeToParent, Property=Height, Factor=0.911}"
                         RelativeLayout.XConstraint="{ConstraintExpression Type=RelativeToParent, Property=Width, Factor=0.05}"
                         Orientation="Horizontal">
                <Label x:Name="ItemPosition"
                       Text="{Binding CurrentPosition, Converter={StaticResource DurationConverter}}"/>
                <Label Text=" / " />
                <Label x:Name="Duration"
                       Text="{Binding SelectedVideo.Duration, Converter={StaticResource DurationConverter}}"/>
            </StackLayout>
            ...
        </RelativeLayout>
    </ContentPage.Content>
</ContentPage>

```

그리고 어플리케이션을 실행해서 현재 재생시간이 갱신되는 것을 확인합니다.

<img src="/assets/images/tutorials/85/14.png" style="height:675px; width:1200px"/>

[코드 스냅샷](https://tizenschool.org/assets/images/tutorials/97/Lect3_Snapshot07_Impl_MediaRenderingViewRenderer_2.zip)

해당 과정을  **Android** 의  **VideoView** 에 알맞게 구현하면  **Android** 프로젝트의  **Custom Render** 가 구현됩니다.

[Android-MediaRenderingViewRenderer.cs](https://tizenschool.org/assets/images/tutorials/97/MediaRenderingViewRenderer.cs)

## 9. 뒤로가기 버튼 처리

**Step 5: PlayerButton Clicked 이벤트 처리**

그리고 **PlayPauseButton** 이 클릭되었을 때 **PlayerStatus** 가 **Playing** 이라면 **Paused** 로,

**Paused** 이거나 **Stopped** 이면 **Playing** 으로 변경되도록 합니다.

[PlayerPage.xaml.cs]

<highlight>28,45-59</highlight>

```csharp
using System;
using Xamarin.Forms;
using Xamarin.Forms.Xaml;

namespace VideoPlayerLite.Views
{
    [XamlCompilation(XamlCompilationOptions.Compile)]
    public partial class PlayerPage : ContentPage
    {
        public static readonly BindableProperty FetchVideoCommandProperty = BindableProperty.Create("FetchVideoCommand", typeof(Command), typeof(PlayerPage), null);
        public Command FetchVideoCommand
        {
            get => (Command)GetValue(FetchVideoCommandProperty);
        }

        public static readonly BindableProperty PlayerStatusProperty = BindableProperty.Create("PlayerStatus", typeof(PlayerStatus), typeof(PlayerPage), PlayerStatus.Stopped, BindingMode.TwoWay);
        public PlayerStatus PlayerStatus
        {
            get => (PlayerStatus)GetValue(PlayerStatusProperty);
            set => SetValue(PlayerStatusProperty, value);
        }


        public PlayerPage()
        {
            InitializeComponent();

            PlayPauseButton.Clicked += PlayPauseButtonClicked;
        }

        protected override void OnAppearing()
        {
            base.OnAppearing();

            FetchVideoCommand.Execute(null);
        }

        protected override bool OnBackButtonPressed()
        {
            PlayerStatus = PlayerStatus.Paused;

            return base.OnBackButtonPressed();
        }

        private void PlayPauseButtonClicked(object sender, EventArgs e)
        {
            if (PlayerStatus == PlayerStatus.Playing)
            {
                PlayerStatus = PlayerStatus.Paused;
            }
            else if (PlayerStatus == PlayerStatus.Paused || PlayerStatus == PlayerStatus.Stopped)
            {
                PlayerStatus = PlayerStatus.Playing;
            }
            else
            {
                // The property changed event of the PlayingItem is going to change the PlayerStatus, which of the MediaRenderingViewRenderer.cs(aka.CustomRenderer), to the "Playing" state.
            }
        }
    }
}

```

**Step 6: PropertyChanged 구현**

**PlayerPage** 의 **PlayerStatus** 프로퍼티가 변경될 때 **PlayPauseButton** 의 **ButtonImage** 를 변경하도록 구현합니다.

[PlayerPage.xaml.cs]

<highlight>29,62-84</highlight>

```csharp
using System;
using Xamarin.Forms;
using Xamarin.Forms.Xaml;

namespace VideoPlayerLite.Views
{
    [XamlCompilation(XamlCompilationOptions.Compile)]
    public partial class PlayerPage : ContentPage
    {
        public static readonly BindableProperty FetchVideoCommandProperty = BindableProperty.Create("FetchVideoCommand", typeof(Command), typeof(PlayerPage), null);
        public Command FetchVideoCommand
        {
            get => (Command)GetValue(FetchVideoCommandProperty);
        }

        public static readonly BindableProperty PlayerStatusProperty = BindableProperty.Create("PlayerStatus", typeof(PlayerStatus), typeof(PlayerPage), PlayerStatus.Stopped, BindingMode.TwoWay);
        public PlayerStatus PlayerStatus
        {
            get => (PlayerStatus)GetValue(PlayerStatusProperty);
            set => SetValue(PlayerStatusProperty, value);
        }


        public PlayerPage()
        {
            InitializeComponent();

            PlayPauseButton.Clicked += PlayPauseButtonClicked;
            PropertyChanged += OnPropertyChanged;
        }

        protected override void OnAppearing()
        {
            base.OnAppearing();

            FetchVideoCommand.Execute(null);
        }

        protected override bool OnBackButtonPressed()
        {
            PlayerStatus = PlayerStatus.Paused;

            return base.OnBackButtonPressed();
        }

        private void PlayPauseButtonClicked(object sender, EventArgs e)
        {
            if (PlayerStatus == PlayerStatus.Playing)
            {
                PlayerStatus = PlayerStatus.Paused;
            }
            else if (PlayerStatus == PlayerStatus.Paused || PlayerStatus == PlayerStatus.Stopped)
            {
                PlayerStatus = PlayerStatus.Playing;
            }
            else
            {
                // The property changed event of the PlayingItem is going to change the PlayerStatus, which of the MediaRenderingViewRenderer.cs(aka.CustomRenderer), to the "Playing" state.
            }
        }

        private void OnPropertyChanged(object sender, System.ComponentModel.PropertyChangedEventArgs e)
        {
            if (e.PropertyName == PlayerPage.PlayerStatusProperty.PropertyName)
            {
                if (PlayerStatus == PlayerStatus.Playing)
                {
                    PlayPauseButton.ButtonImage = "btn_viewer_control_pause_normal.png";
                    ControlPad.IsEnabled = true;
                }
                else if (PlayerStatus == PlayerStatus.Paused)
                {
                    PlayPauseButton.ButtonImage = "btn_viewer_control_play_normal.png";
                }
                else if (PlayerStatus == PlayerStatus.Stopped)
                {
                    PlayPauseButton.ButtonImage = "btn_viewer_control_play_normal.png";
                }
                else if (PlayerStatus == PlayerStatus.Preparing)
                {
                    ControlPad.IsEnabled = false;
                }
            }
        }
    }
}

```

이때 **PlayerStatus** 에 따라 **ControlPad** 를 **Enable** 하거나 **Disable** 하는 이유는 **Preparing** 중 **추가 입력으로 인한 오동작을 방지** 하기 위함입니다.

**Step 7: SetFocus 메소드 추가**

**PlayerButton** 에 포커스가 가도록 하기 위한 **SetFocus** 메소드를 추가합니다.

[PlayerButton.xaml.cs]

<highlight>35-38</highlight>

```csharp
using System;
using Xamarin.Forms;
using Xamarin.Forms.Xaml;

namespace VideoPlayerLite.Views
{
    [XamlCompilation(XamlCompilationOptions.Compile)]
    public partial class PlayerButton : RelativeLayout
    {
        public event EventHandler Clicked;

        public string ButtonImage
        {
            get => Icon.Source.ToString();
            set
            {
                Icon.Source = value;
                InvokePropertyChanged();
            }
        }

        public string ButtonName
        {
            get => ControlButton.CommandParameter.ToString();
            set => ControlButton.CommandParameter = value;
        }

        public PlayerButton()
        {
            InitializeComponent();

            ControlButton.Clicked += (s, e) => Clicked?.Invoke(this, EventArgs.Empty);
        }

        public void SetFocus()
        {
            ControlButton.Focus();
        }
    }
}

```

**ControlPad** 가 **Enable** 되었을 때 그리고 **PlayerPage** 가 나타났을 때 **PlayPauseButton** 에 포커스가 갈 수 있도록 **SetFocus** 메소드를 추가합니다.

[PlayerPage.xaml.cs]

<highlight>35,70</highlight>

```csharp
using System;
using Xamarin.Forms;
using Xamarin.Forms.Xaml;

namespace VideoPlayerLite.Views
{
    [XamlCompilation(XamlCompilationOptions.Compile)]
    public partial class PlayerPage : ContentPage
    {
        public static readonly BindableProperty FetchVideoCommandProperty = BindableProperty.Create("FetchVideoCommand", typeof(Command), typeof(PlayerPage), null);
        public Command FetchVideoCommand
        {
            get => (Command)GetValue(FetchVideoCommandProperty);
        }

        public static readonly BindableProperty PlayerStatusProperty = BindableProperty.Create("PlayerStatus", typeof(PlayerStatus), typeof(PlayerPage), PlayerStatus.Stopped, BindingMode.TwoWay);
        public PlayerStatus PlayerStatus
        {
            get => (PlayerStatus)GetValue(PlayerStatusProperty);
            set => SetValue(PlayerStatusProperty, value);
        }


        public PlayerPage()
        {
            InitializeComponent();

            PlayPauseButton.Clicked += PlayPauseButtonClicked;
            PropertyChanged += OnPropertyChanged;
        }

        protected override void OnAppearing()
        {
            base.OnAppearing();
            PlayPauseButton.SetFocus();
            FetchVideoCommand.Execute(null);
        }

        protected override bool OnBackButtonPressed()
        {
            PlayerStatus = PlayerStatus.Paused;

            return base.OnBackButtonPressed();
        }

        private void PlayPauseButtonClicked(object sender, EventArgs e)
        {
            if (PlayerStatus == PlayerStatus.Playing)
            {
                PlayerStatus = PlayerStatus.Paused;
            }
            else if (PlayerStatus == PlayerStatus.Paused || PlayerStatus == PlayerStatus.Stopped)
            {
                PlayerStatus = PlayerStatus.Playing;
            }
            else
            {
                // The property changed event of the PlayingItem is going to change the PlayerStatus, which of the MediaRenderingViewRenderer.cs(aka.CustomRenderer), to the "Playing" state.
            }
        }

        private void OnPropertyChanged(object sender, System.ComponentModel.PropertyChangedEventArgs e)
        {
            if (e.PropertyName == PlayerPage.PlayerStatusProperty.PropertyName)
            {
                if (PlayerStatus == PlayerStatus.Playing)
                {
                    PlayPauseButton.ButtonImage = "btn_viewer_control_pause_normal.png";
                    ControlPad.IsEnabled = true;
                    PlayPauseButton.SetFocus();
                }
                else if (PlayerStatus == PlayerStatus.Paused)
                {
                    PlayPauseButton.ButtonImage = "btn_viewer_control_play_normal.png";
                }
                else if (PlayerStatus == PlayerStatus.Stopped)                {
                    PlayPauseButton.ButtonImage = "btn_viewer_control_play_normal.png";
                }
                else if (PlayerStatus == PlayerStatus.Preparing)
                {
                    ControlPad.IsEnabled = false;
                }
            }
        }
    }
}


```

이제 어플리케이션을 실행하여 완성된 모습을 확인해봅시다.

<img src="/assets/images/tutorials/85/16.png" style="height:330px; width:1190px"/>

[코드 스냅샷](https://tizenschool.org/assets/images/tutorials/97/Lect3_Snapshot09_Add_PlayerButton_Final.zip)

# Implementing PlayerButton

## 1. PlayerButton 생성

**LibraryPage** 에서 **PlayerPage** 로 넘어가기 위해서는 하나의 비디오를 선택해야 합니다.

따라서 **ItemView** 를 클릭하는 것으로 **PlayerPage** 가 나타날 수 있도록 구현하도록 하겠습니다.

**Step 6: ItemView에 Clicked 이벤트 핸들러 추가**

**ItemView** 에 **Clicked** 이벤트 핸들러를 추가하고 **FocusButton** 의 **Clicked** 이벤트와 바인딩합니다.

**FocusButton** 이 클릭되었을 때 **PlayerPage** 를 새로 생성하고 **PushAsync** 메소드를 이용하여 **PlayerPage** 로 이동합니다.

**PlayerPage** 에서 다시 **LibraryPage** 로 돌아왔을 때 처음 선택했었던 비디오에 포커스가 가 있도록 하기위해

**Disappearing** 이벤트에 **FocusButton** 의 **Focus** 메소드를 등록합니다.

[ItemView.xaml.cs]

<highlight>28-35</highlight>

```csharp
using System;
using VideoPlayerLite.Models;
using VideoPlayerLite.ViewModels;
using Xamarin.Forms;
using Xamarin.Forms.Xaml;

namespace VideoPlayerLite.Views
{
    [XamlCompilation(XamlCompilationOptions.Compile)]
    public partial class ItemView : RelativeLayout
    {
        public ItemView(MediaItem item)
        {
            InitializeComponent();

            BindingContext = new ItemViewModel(item);
        }


        protected override void OnSizeAllocated(double width, double height)
        {
            base.OnSizeAllocated(width, height);

            WidthRequest = height * 1.5f;
            InvalidateMeasure();
        }

        private void OnItemClicked(object sender, EventArgs e)
        {
            PlayerPage player = new PlayerPage();

            player.Disappearing += (s, ev) => FocusButton.Focus();

            Navigation.PushAsync(player);
        }
    }
}

```

[ItemView.xaml]

<highlight>29</highlight>

```xml
<?xml version="1.0" encoding="UTF-8"?>
<RelativeLayout xmlns="http://xamarin.com/schemas/2014/forms"
                xmlns:x="http://schemas.microsoft.com/winfx/2009/xaml"
                x:Class="VideoPlayerLite.Views.ItemView"
                HorizontalOptions="Start">
    <BoxView x:Name="BackgroundView"
             RelativeLayout.HeightConstraint="{ConstraintExpression Type=RelativeToParent, Property=Height, Factor=1}"
             RelativeLayout.WidthConstraint="{ConstraintExpression Type=RelativeToParent, Property=Width, Factor=1}"
             BackgroundColor="White"
             IsVisible="{Binding Path=IsFocused, Source={x:Reference Name=FocusButton}}"/>
    <Image x:Name="ThumbnailImage"
           RelativeLayout.HeightConstraint="{ConstraintExpression Type=RelativeToView, ElementName=BackgroundView, Property=Height, Factor=0.95}"
           RelativeLayout.WidthConstraint="{ConstraintExpression Type=RelativeToView, ElementName=BackgroundView, Property=Width, Factor=0.96}"
           RelativeLayout.YConstraint="{ConstraintExpression Type=RelativeToView, ElementName=BackgroundView, Property=Height, Factor=0.025}"
           RelativeLayout.XConstraint="{ConstraintExpression Type=RelativeToView, ElementName=BackgroundView, Property=Width, Factor=0.02}"
           Source="{Binding VideoItem.Thumbnail}"
           Aspect="AspectFill"/>
    <Label x:Name="Title"
           RelativeLayout.YConstraint="{ConstraintExpression Type=RelativeToParent, Property=Height, Factor=0.7}"
           RelativeLayout.XConstraint="{ConstraintExpression Type=RelativeToParent, Property=Width, Factor=0.07}"
           RelativeLayout.WidthConstraint="{ConstraintExpression Type=RelativeToView, ElementName=BackgroundView, Property=Width, Factor=0.86}"
           TextColor="White"
           Text="{Binding VideoItem.Title}"
           LineBreakMode="TailTruncation"/>
    <Button x:Name="FocusButton"
            RelativeLayout.HeightConstraint="{ConstraintExpression Type=RelativeToView, ElementName=BackgroundView, Property=Height, Factor=0.95}"
            RelativeLayout.WidthConstraint="{ConstraintExpression Type=RelativeToView, ElementName=BackgroundView, Property=Width, Factor=0.96}"
            Opacity="0"
            Clicked="OnItemClicked"/>
</RelativeLayout>

```

그리고 어플리케이션을 실행해서 현재 상태를 확인해봅시다.

<img src="/assets/images/tutorials/85/2-3.png" style="height:675px; width:1200px"/>

[코드 스냅샷](https://tizenschool.org/assets/images/tutorials/97/Lect3_Snapshot01_Add_PlayerPage.zip)

## 2. PlayerButton 생성

**PlayerPage** 에서 **뒤로가기 버튼** 을 눌렀을 때 재생중인 **비디오를 정지** 하도록 하여

와 이건 좀 어렵다.

**Step 1: CurrentStatus 프로퍼티 추가**

먼저, **PlayerPageViewModel** 에 현재 **Player의 상태** 에 대응하는 **CurrentStatus** 프로퍼티를 추가해줍니다.

[PlayerPageViewModel.cs]

<highlight>14,16-24</highlight>

```csharp
using VideoPlayerLite.Models;
using VideoPlayerLite.Views;
using Xamarin.Forms;

namespace VideoPlayerLite.ViewModels
{
    public class PlayerPageViewModel : ViewModelBase
    {
        private static readonly string NEXT_BUTTON = "Next";
        private static readonly string PREV_BUTTON = "Previous";

        /* Properties, Commands */

        private PlayerStatus currentStatus;

        public PlayerStatus CurrentStatus
        {
            get => currentStatus;
            set
            {
                currentStatus = value;
                InvokePropertyChanged();
            }
        }


        public PlayerPageViewModel()
        {
            FetchSelectedVideoCommand = new Command(() => SelectedVideo = MediaItemProvider.Instance.SelectedItem);

            ControlButtonCommand = new Command<string>((buttonName) =>
            {
                if (buttonName == PREV_BUTTON)
                {
                    SelectedVideo = MediaItemProvider.Instance.MoveToPrev();
                }
                else if (buttonName == NEXT_BUTTON)
                {
                    SelectedVideo = MediaItemProvider.Instance.MoveToNext();
                }
            });
        }
    }
}


```

**Step 2: PlayerStatus** **BindableProperty 추가**

**PlayerPage** 에 **PlayerPageViewModel** 의 **CurrentStatus** 와 **Binding** 될 **PlayerStatus** **BindableProperty** 를 추가하도록 하겠습니다.

[PlayerPage.xaml.cs]

<highlight>13-18</highlight>

```csharp
using Xamarin.Forms;

namespace VideoPlayerLite.Views
{
    public partial class PlayerPage : ContentPage
    {
        public static readonly BindableProperty FetchVideoCommandProperty = BindableProperty.Create("FetchVideoCommand", typeof(Command), typeof(PlayerPage), null);
        public Command FetchVideoCommand
        {
            get => (Command)GetValue(FetchVideoCommandProperty);
        }

        public static readonly BindableProperty PlayerStatusProperty = BindableProperty.Create("PlayerStatus", typeof(PlayerStatus), typeof(PlayerPage), PlayerStatus.Stopped, BindingMode.TwoWay);
        public PlayerStatus PlayerStatus
        {
            get => (PlayerStatus)GetValue(PlayerStatusProperty);
            set => SetValue(PlayerStatusProperty, value);
        }

        public PlayerPage()
        {
            InitializeComponent();
        }

        protected override void OnAppearing()
        {
            base.OnAppearing();

            FetchVideoCommand.Execute(null);
        }
    }
}

```

**Step 3: PlayerStatus Binding**

PlayerPage의 PlayerStatus, MediaRenderingView의 CurrentStatus와 PlayerPageViewModel의 CurrentStatus를 Binding합니다.

[PlayerPage.xaml]

<highlight>9</highlight>

```xml
<ContentPage xmlns="http://xamarin.com/schemas/2014/forms"
             xmlns:x="http://schemas.microsoft.com/winfx/2009/xaml"
             xmlns:Views="clr-namespace:VideoPlayerLite.Views"
             xmlns:ViewModels="clr-namespace:VideoPlayerLite.ViewModels"
             xmlns:Models="clr-namespace:VideoPlayerLite.Models"
             x:Class="VideoPlayerLite.Views.PlayerPage"
             NavigationPage.HasNavigationBar="false"
             FetchVideoCommand="{Binding FetchSelectedVideoCommand}"
             PlayerStatus="{Binding CurrentStatus}">
    ...
</ContentPage>

```

[MediaRenderingView.xaml]

<highlight>7</highlight>

```xml
<?xml version="1.0" encoding="UTF-8"?>
<View xmlns="http://xamarin.com/schemas/2014/forms"
      xmlns:x="http://schemas.microsoft.com/winfx/2009/xaml"
      x:Class="VideoPlayerLite.Views.MediaRenderingView"
      CurrentVideo="{Binding SelectedVideo}"
      CurrentPosition="{Binding CurrentPosition}"
      CurrentStatus="{Binding CurrentStatus}"/>

```

**Step 4: OnBackButtonPressed Override**

**PlayerPage** 에 **OnBackButtonPressed** 를 Override하여 뒤로가기 버튼이 눌러졌을 때 PlayerStatus를 Stopped로 바꾸어줍니다.

[PlayerPage.xaml.cs]

<highlight>32-37</highlight>

```csharp
using Xamarin.Forms;

namespace VideoPlayerLite.Views
{
    public partial class PlayerPage : ContentPage
    {
        public static readonly BindableProperty FetchVideoCommandProperty = BindableProperty.Create("FetchVideoCommand", typeof(Command), typeof(PlayerPage), null);
        public Command FetchVideoCommand
        {
            get => (Command)GetValue(FetchVideoCommandProperty);
        }

        public static readonly BindableProperty PlayerStatusProperty = BindableProperty.Create("PlayerStatus", typeof(PlayerStatus), typeof(PlayerPage), PlayerStatus.Stopped, BindingMode.TwoWay);
        public PlayerStatus PlayerStatus
        {
            get => (PlayerStatus)GetValue(PlayerStatusProperty);
            set => SetValue(PlayerStatusProperty, value);
        }

        public PlayerPage()
        {
            InitializeComponent();
        }

        protected override void OnAppearing()
        {
            base.OnAppearing();

            FetchVideoCommand.Execute(null);
        }

        protected override bool OnBackButtonPressed()
        {
            PlayerStatus = PlayerStatus.Paused;

            return base.OnBackButtonPressed();
        }
    }
}

```

[코드 스냅샷](https://tizenschool.org/assets/images/tutorials/97/Lect3_Snapshot08_Override_OnBackButtonPressed.zip)
