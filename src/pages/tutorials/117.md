---
layout: ../../layouts/tutorial/TextTutorial.astro
title: "C# Wearable App Development (2/3)"
description: "This tutorial describes how to use various UI components such as widgets, popup windows, toasts, layouts, the index and circle page and the rotary selector by Tizen.Wearable.CircularUI."
created: "2018/06/19"
modified: "2018/10/08"
profile: ["wearable"]
type: "dotnet"
level: 1
state: "open"
thumbnail: "/assets/images/tutorials/117/wearable_full_thumbnail2.png"
---

# I. Main Elements of Application screen

## Basic Elements of UI-Layouts

In this lesson, we will see the basics of creating a user interface in UI  **Tizen**  applications.



Creation of user interface of UI application starts from a window. This is the basic widget that represents your application; all screen components placed on it.

All elements of the user interface in  **Tizen**  are divided into widgets and containers (Layouts). Containers are mostly responsible for the widgets location and theirs size on the screen. Widgets are elements of information displaying or elements of control.



**Layouts**

Layouts are used to arrange the elements that make up the UI interface of a screen.

The layouts you choose in your app can either help or hurt you as you're creating an attractive and usable _Xamarin.Forms_ app. Taking some time to consider how each layout works can help you write cleaner and more scalable UI code. A screen can have a combination of different layouts to achieve a specific design.



**StackLayout**

The _StackLayout_ is used for displaying views along a line that is either horizontal or vertical. Position and size within the layout is determined based on a view's _HeightRequest_ , _WidthRequest_ , _HorizontalOptions_ and _VerticalOptions_ . _Views_ in a _StackLayout_ can be aligned to the center, left or right of the layout.

_StackLayout_ is often used as the base layout, arranging other layouts on the screen. For an example of when _StackLayout_ would be a good choice, consider an app that needs to display a button and a label, with the label left-aligned and the button right-aligned.

<img src="/assets/images/tutorials/114/lesson_9_image_001.png" style="height:404px; width:481px"/>



**AbsoluteLayout**

The  _AbsoluteLayout_ is used to arrange views by setting coordinates & size in terms of absolute values or ratios. AbsoluteLayout can be used to layer views as well as anchor them to the left, right or center.

Unlike  _StackLayout_ and  _Grid_ ,  _AbsoluteLayout_ allows child views to overlap. Unlike  _RelativeLayout_ ,  _AbsoluteLayout_ doesn't let you place elements off screen.

For an example of when  _AbsoluteLayout_ would be a good choice, consider an app that needs to present collections of objects as stacks. This is often seen when presenting albums of photos or songs.

<img src="/assets/images/tutorials/114/lesson_9_image_002.png" style="height:408px; width:491px"/>



**RelativeLayout**

The  _RelativeLayout_ is used for displaying views, with size and position specified as values relative to the values of the layout or another view. Relative values do not need to match the corresponding value on the related view.

As an example, it is possible to set a view's  _Width_ property to be proportional to another view's 
`X`
 property.

_RelativeLayout_ can be used to create UIs that scale proportionally across device sizes.



<img src="/assets/images/tutorials/114/lesson_9_image_003.png" style="undefined"/>



**Grid**

The  _Grid_ is used for displaying elements in rows & columns. Note that the Grid is not a table, so it does not have the concept of cells, header & footer rows, or borders between rows & columns. In general, _Grid_ is not appropriate for displaying tabular data. For that use, consider a  _ListView_  or  _TableView_ .

For an example of when a Grid is the right layout to use, consider a numeric input for a calculator. A numeric input for a calculator might consist of four rows and three columns, each with a button.

<img src="/assets/images/tutorials/114/lesson_9_image_004.png" style="height:360px; width:360px"/>



**ScrollerView**

_ScrollView_ contains layouts and enables them to scroll offscreen. ScrollView is also used to allow views to automatically move to the visible portion of the screen when the keyboard is showing. _ScrollView_ can be used to ensure that larger views display well on smaller phones. _ScrollView_ exposes a _Content_ property which can be set to a single view or layout.

<img src="/assets/images/tutorials/114/lesson_9_image_005.png" style="height:512px; width:446px"/>



_ScrollView_ has the following properties:



## Widgets (UI Controls)

**Label**

The  _Label_ view is used for displaying text, both single and multi-line. Labels can have custom fonts (families, sizes, and options) and colored text.



<img src="/assets/images/tutorials/114/lesson_9_image_006.png" style="height:360px; width:360px"/>



**Button**

The  _Button_ is the most fundamental interactive control in all of _Xamarin.Forms_ . The _Button_ usually displays a short text string indicating a command, but it can also display a bitmap image, or a combination of text and an image. The user presses the _Button_ with a finger or clicks it with a mouse to initiate that command.

<img src="/assets/images/tutorials/114/lesson_9_image_007.png" style="height:360px; width:360px"/>



Various styles are supported in button, which are as shown below:



<img src="/assets/images/tutorials/114/lesson_9_image_008.png" style="undefined"/>
                    
<img src="/assets/images/tutorials/114/lesson_9_image_009.png" style="height:360px; width:360px"/>



**ProgressBar**

A view with linear appearance used to display the status of any process.

<img src="/assets/images/tutorials/114/lesson_9_image_010.png" style="height:360px; width:360px"/>



Circular progress bar can also be used. It is basically a control that fits in the circular screen. It can be shown in _CirclePage_ only.



<img src="/assets/images/tutorials/114/lesson_9_image_011.png" style="height:360px; width:360px"/>



**CircleDateTimeSelector**

_CircleDateTimeSelector_ is a view for Date Picker and Time Picker. The view of this selector covers the entire screen. You can set the value of the year/month/day by touch or by rotating the bezel. You can also set the value of the hour/minute AM/PM by touch or by rotating the bezel.



<img src="/assets/images/tutorials/114/lesson_9_image_012.png" style="height:360px; width:360px"/>



**CircleListView**

_CircleListView_ is a view for presenting lists of data, a short list that does not require scrolling, and a long list that requires scrolling. This view is an extension of  _Xamarin.Forms.ListView_ . It is similar to  _Xamarin.Forms.ListView_ , but the Scroller is rendered to CircleSurface. You can move the list using Bezel interaction and Drag. To receive Rotary event, it must be registered as  _RotaryFocusObject_ , property of _CirclePage_ .



<img src="/assets/images/tutorials/114/lesson_9_image_013.png" style="height:360px; width:360px"/>



**CirclePage**

_CirclePage_ is a subclass of _Xamarin.Forms_ .Page that can show Circular _ProgressBar_ and Circular _Slider_ and the _button_ on the bottom of the screen. it can also show MenuItems on the circular menu.(MoreOption)

<img src="/assets/images/tutorials/114/lesson_9_image_014.png" style="height:360px; width:360px"/>



**CircleScrollView**

_CircleScrollView_ is to ensure that larger views display well on smaller wearable devices. It is an extension of  _Xamarin.Forms.ScrollView_ . Similar to  _Xamarin.Forms.ScrollView_ , but the Scroller is rendered to CircleSurface. Scrolling is possible with Bezel interaction. To receive Rotary event, it must be registered as  _RotaryFocusObject_ , property of _CirclePage_ .



<img src="/assets/images/tutorials/114/lesson_9_image_015.png" style="height:360px; width:360px"/>



**CircleStackLayout**

_CircleStackLayout_ organizes views in a one-dimensional line ("stack"), either horizontally or vertically. _CircleStackLayout_ is similar to _Xamarin.Forms.StackLayout_ , but it arranges internal components in a form that fits the circular screen. Rectangular components are placed in close proximity to the circle. Margin is calculated after placement.



<img src="/assets/images/tutorials/114/lesson_9_image_016.png" style="height:360px; width:360px"/>
    
<img src="/assets/images/tutorials/114/lesson_9_image_017.png" style="height:360px; width:360px"/>



**CircleStepper**

_CircleStepper_ allows you to select a value from a range of incremental values specified with Minimum, Maximum, and Increment properties. You can modify the value with Bezel interaction. To receive Rotary event, it must be registered as  _RotaryFocusObject_ , property of _CirclePage_ .

<img src="/assets/images/tutorials/114/lesson_9_image_018.png" style="undefined"/>



**CircleSurfaceEffectBehavior**

The  _CircleSurfaceEffectBehavior_ is a Behavior, which allows you to attach the  _CircleSurface_ to the  _Xamarin.Forms.Page_ . CircleSurface is a Tizen specific component that manages circle objects.



<img src="/assets/images/tutorials/114/lesson_9_image_019.png" style="undefined"/>

<img src="/assets/images/tutorials/114/lesson_9_image_020.png" style="undefined"/>



It provides you with five ways to do so:

<img src="/assets/images/tutorials/114/lesson_9_image_021.png" style="height:360px; width:360px"/>



<img src="/assets/images/tutorials/114/lesson_9_image_022.png" style="undefined"/>

<img src="/assets/images/tutorials/114/lesson_9_image_023.png" style="undefined"/>





<img src="/assets/images/tutorials/114/lesson_9_image_024.png" style="undefined"/>

<img src="/assets/images/tutorials/114/lesson_9_image_025.png" style="undefined"/>



**ContextPopupEffectBehavior**

_ContextPopupEffectBehavior_ is a Behavior for _Xamarin.Forms_ that is used to create the  _View_ with one or two _buttons_ . A popup with only one _button_ will have an  **Accept**  button only. The default text for  **Accept**  button is OK.

<img src="/assets/images/tutorials/114/lesson_9_image_026.png" style="height:360px; width:360px"/>

<img src="/assets/images/tutorials/114/lesson_9_image_027.png" style="undefined"/>



**Radio**

_Radio_  displays one or more options. You can select only one of the options having same GroupName property. Radio can select only one item among items having same GroupName property.

<img src="/assets/images/tutorials/114/lesson_9_image_028.png" style="height:360px; width:360px"/>

<img src="/assets/images/tutorials/114/lesson_9_image_029.png" style="undefined"/>



**PopupEntry**

_PopupEntry_ is a control that allows you to enter text with the IME when you click on  _Entry_ .

<img src="/assets/images/tutorials/114/lesson_9_image_030.png" style="undefined"/>



**Toast**

_Toast_ provides simple information.  _Toast_ automatically disappears after timeout (in seconds). Tizen Wearable Toastfills the entire screen with display message and image. There are many ways to show a toast some of them are shown below.

<br/>
<img src="/assets/images/tutorials/114/lesson_9_image_031.png" style="height:360px; width:360px"/>

<img src="/assets/images/tutorials/114/lesson_9_image_032.png" style="height:360px; width:360px"/>



**TwoButtonPopup**

A popup has two buttons on the left and right side of the circular screen.

Various styles are supported to display two button popup. Below are some of the styles to display a two button popup. We can provide a button as per our choice whether we want to add a button to the left or right or maybe both sides of the wearable screen.



<img src="/assets/images/tutorials/114/lesson_9_image_033.png" style="height:360px; width:360px"/>

<img src="/assets/images/tutorials/114/lesson_9_image_034.png" style="undefined"/>

<img src="/assets/images/tutorials/114/lesson_9_image_035.png" style="undefined"/>



**TwoButtonPage**

A subclass of _Xamarin.Forms.Page_ has two buttons on the left and right side of the circular screen.

<img src="/assets/images/tutorials/114/lesson_9_image_036.png" style="height:360px; width:360px"/>



**IndexPage**

_IndexPage_ is a subclass of multiple pages that can slide child page horizontally. It has dots on top of the screen for the number of child pages.

<img src="/assets/images/tutorials/114/lesson_9_image_037.png" style="height:360px; width:360px"/>









# II. UI of standard template

## Standard template

The C# code from your first application displays a label centered on the screen, containing the “ **Welcome to Xamarin Forms!”** text. This MyFirstApplication application created from the template is set up and ready to be built and run by Visual Studio right after you create it, as described in [Lesson 6](http://tizenschool.org/tutorial/116/contents/17).



The _Xamarin.Forms_ controls used to create the user interface of a Tizen .NET application can be broadly categorized into 3 groups:

```csharp
public class App : Application
{
    public App()
    {
        // The root page of your application
        MainPage = new ContentPage
        {
            Content = new StackLayout
            {
                VerticalOptions = LayoutOptions.Center,
                Children = {
                        new Label {
                            HorizontalTextAlignment = TextAlignment.Center,
                            Text = "Welcome to Xamarin Forms!"
                        }
             	   }
            }
        };
    }
}
```



This application is constructed with the following _Xamarin.Forms_ controls:

# III. Layout and Standard Styles

## Tizen.Wearable.CircularUI Package

Starting from this lesson, let’s move from theory to practice. We will show you how to create demo applications that will be based on the use of several UI components. At the beginning of each lesson, you will be able to see, which demo application this tutorial linked with.



During the next 6 lessons, we will show you how to create the first small application. It will contain the simplest standard layout, with text and button, clicking on which will change the text. Also, in the application there will be a popup dialog window for conforming exit from the application. In one of these lessons, we will teach you how to add messages output to the  **Visual Studio**  log window.



But before starting with our demo, we will need CircularUI nudget package.



**Tizen.Wearable.CircularUI Package**



Tizen Wearable CircularUI package is a set of helpful extensions of the Xamarin Forms framework. It is specifically designed for Samsung gear device that support Tizen.NET. The binaries are available via NuGet (package name  **Tizen.Wearable.CircularUI** ).



**Steps to add CircularUI in Project**



<img src="/assets/images/tutorials/114/lesson_11_image_001.png" style="height:683px; width:561px"/>



<img src="/assets/images/tutorials/114/lesson_11_image_002.png" style="height:466px; width:1000px"/>



<img src="/assets/images/tutorials/114/lesson_11_image_003.png" style="undefined"/>



<img src="/assets/images/tutorials/114/lesson_11_image_004.png" style="height:469px; width:1000px"/>



<img src="/assets/images/tutorials/114/lesson_11_image_005.png" style="height:596px; width:558px"/>



<img src="/assets/images/tutorials/114/lesson_11_image_006.png" style="height:533px; width:1000px"/>



## Demo Application # 1. Layout: Selection and Creation

To create a new layout, create an object of _StackLayout_ . We are beginning with stack layout here else we can add any layout or view as required.

```csharp
StackLayout stacklayout = new StackLayout();
```

Add Widget (UI Controls) i.e. _Button_ or _Label_ in the Children Property of _StackLayout_ .



There are two ways of adding UI Control to Children property of _StackLayout_ .

1.   Direct method.

```csharp
StackLayout stacklayout = new StackLayout
{
	Children =
	{

	}
};
```

2.   Using function Add() in Children property through the Layout object.

After adding layout, we need to set the content of the root page of our application. This can be done by initializing the _MainPage_ with new _ContentPage_ and set the Content property with layout object initialized above.

```csharp
// The root page of your application
MainPage = new ContentPage
{
	Content = stacklayout
};
```

If you run the application now, you will see nothing but a black screen. In the following lessons, we will teach you how to create graphic elements and fill layout with them.



You can download the full source code of this lesson [here.](https://s3-us-west-1.amazonaws.com/tizenschool/114/Wearable_Lesson011.zip)

# IV. System Logs

## Viewing Logs

During the development of the application and/or its debugging, it becomes necessary to obtain information about the state of variables or get messages with information about errors. For these purposes, **Tizen**  uses  **dlog**  library. To check the logs messages, both your own and other applications on the device/emulator, you can use the  **dlogutil utility** .



To use the dlog API, you must use **Log** class in the project which present in _Xamarin.Forms.Platform.Tizen_ namespace.



```csharp
using Xamarin.Forms.Platform.Tizen;
```

The message registration includes: message text, priority (indicates the importance level of the message), and tag. In the development environment, these messages are highlighted in different colors. The library includes the following priorities:





To specify the source of log messages, use the tag. Tag is a string that identifies the application or module.

```csharp
Log.Tag = "XamrinApplication";
```

The messages output is provided by the functions:

```csharp
Log.Debug("Message of Debug priority");
Log.Info("Message of Info priority");
Log.Warn("Message of Warning priority");
Log.Error("Message of Error priority");
Log.Fatal("Message of Fatal priority");
```



To view logs, in the Visual Studio IDE menu go to  **Tools > Tizen > Tizen Log Viewer.** Messages are highlighted in priority color. They can also be filtered by tag or by the content of the message. You can enable/disable messages of a certain type.



<img src="/assets/images/tutorials/114/lesson_12_image001.png" style="height:493px; width:1000px"/>



On the device, you can see the log messages using the dlogutil utility. Connect to the device via SDB. First, to use SDB, set the device to SDB mode by going to  **Settings → More system settings → Developer options → USB debugging** . Via console, run the  _SDB connect device.IP_ command.



To view the log, call dlogutil. In general, the command has the following form:

```csharp
dlogutil [<option>] ... [<filter-spec>] ...
```

The filter expression includes tag:priority. To view information messages of your application, call:

```csharp
dlogutil XamrinApplication:I
```

To view messages of all priorities, call:

```csharp
dlogutil XamrinApplication:*
```

Now you can display your error messages or additional information from your application in the logging window.

# V. Button Widget

## Button Creation

In this lesson we'll take a closer look at our first widget - i.e. button. We will teach you how to create and put it in the layout. We will also look into the standard styles and how they can be used. Then we will continue to create the demo application by adding a button to the already created layout.



**Button**

Button is a simple widget, which is placed on the screen of the application to receive a response from the user. It responds to a click or tap and directs an application to do the particular task. The user can click the button with the mouse or press it with a finger.



**Button Creation**

Our main purpose is to create a button widget and change its own text when the button widget is clicked upon.

Button widget is created by instantiating the _Button_ class.

C# code to create a sample button widget is given below:

```csharp
Button button = new Button
{
	Text = "Click Me!",
	VerticalOptions = LayoutOptions.CenterAndExpand,
	HorizontalOptions = LayoutOptions.Center,
};

```

Text property specifies the text that appears on the Button. This code creates a Button widget which displays the text ‘Click Me'.



**Handling Click Event**

The _Button_ class defines “ _Clicked_ ” event that is fired when the user clicks the button. The _Clicked_ handler is of type EventHandler.

There are 3 types of events available for button.

```csharp
button.Pressed += Button_Pressed;
button.Clicked += OnClickHandler;
button.Released += Button_Released;

```



C# code to handle click event:

```csharp
button.Clicked += OnButtonClicked;

void OnButtonClicked(object sender, EventArgs args)
{
	button.Text = "Clicked";
}

```

In a similar way, other event handler can be defined for pressed and released events.

<img src="/assets/images/tutorials/114/lesson_13_image_001.png" style="height:281px; width:492px"/>

The first line in this code signifies that when the Button is clicked, the _OnButtonClicked_ method is executed. Since we want to change the text of the button on click, we have again set the text property of button in this method. Once the user clicks the button, it now displays “Button is clicked”.

The first argument of _OnButtonClicked()_ is the Button object generating the event. This is useful when multiple Button objects share the same _Clicked_ event.

Apart from the _Clicked_ event, Button also defines _Pressed_ and _Released_ events.



**Standard styles**

Tizen .NET supports various styles for button which are named as _Default, Bottom, SelectMode and Circle_ .







## Creating a Button for Demo Application #1

Let’s go to the practical part. Create a new instance of a button.

```csharp
Button button = new Button
{
	Text = "Click Me!"
};

```



Add an event handler for a button click.

```csharp
button.Clicked += OnButtonClicked;

void OnButtonClicked(object sender, EventArgs args)
{
	button.Text = "Clicked";
}

```



You need to set the style of button as Bottom as mentioned earlier in the lesson.

```csharp
button.On<Xamarin.Forms.PlatformConfiguration.Tizen>().SetStyle(ButtonStyle.Bottom);
```



Add this button to the layout developed in [lesson 11](http://tizenschool.org/tutorial/117/contents/5).

<img src="/assets/images/tutorials/114/lesson_13_image_007.png" style="height:593px; width:470px"/>

Now you know how to create a button and handle the events.



The complete source code for this tutorial is available [here](https://s3-us-west-1.amazonaws.com/tizenschool/114/Wearable_Lesson013.zip).



# VI. Label Widget

## Description and Creation

In this lesson we will see a new widget i.e.  _Label_ for text displaying, you will find out how to control it and how to adjust the style of the displayed text. In the end we will show you how to add this label to the demo applications and how to change text in the widget after clicking on the button, which was created in previous lesson.



**Description and Creation**

_Label_ is a widget for displaying text on the screen of the applications with a graphical interface. For changing the text formatting, various options are provided which we will learn in coming sections.

C# code to create a label widget is given below:

```csharp
Label label = new Label
{
	Text = “Click Here”,
};
```

<img src="/assets/images/tutorials/114/lesson_14_image_001.png" style="height:360px; width:360px"/>



**Text Formatting**

Labels can also be aligned as per our choice. Alignment properties of a label can be changed by changing the _horizontal_ and _vertical_ options.







Similarly we can set the vertical options of the label as well using

```csharp
VerticalOptions = LayoutOptions.Center
```

It is possible to make long text shorter by setting the _LineBreakMode_ . The value ( _HeadTruncation, TailTruncation, MiddleTruncation_ ) specifies in which part of the line the letters will be omitted and replaced with ellipsis. For example, a _LineBreakMode_ equal to _TailTruncation_ means that the text at the end of the line will be omitted.

```csharp
LineBreakMode = LineBreakMode.TailTruncation;
```

<img src="/assets/images/tutorials/114/lesson_14_image_004.png" style="height:360px; width:360px"/>



The background color of the label can also be changed using

```csharp
BackgroundColor = Color.Blue
```

<img src="/assets/images/tutorials/114/lesson_14_image_005.png" style="height:360px; width:360px"/>



Labels expose a _FormattedText_ property which allows the presentation of text with multiple fonts and colors in the one Label.

The  **_FormattedText_**  property is of type _FormattedString,_ which comprises one or more _Span_ instances, set via the _Spans_  property. Each  **_Span_** possess the following properties:



```csharp
public class LabelPageCode : ContentPage
{
    public LabelPageCode()
    {
        var layout = new StackLayout {
            VerticalOptions = LayoutOptions.Center,
            Padding = new Thickness(5, 10)
        };

        var formattedString = new FormattedString();

        formattedString.Spans.Add(new Span { Text = "Red bold, ", ForegroundColor = Color.Red, FontAttributes = FontAttributes.Bold });

        formattedString.Spans.Add(new Span { Text = "default, " });

        formattedString.Spans.Add(new Span { Text = "italic small.", FontAttributes = FontAttributes.Italic, FontSize = Device.GetNamedSize(NamedSize.Small, typeof(Label)) });

        layout.Children.Add(new Label { FormattedText = formattedString });
        this.Content = layout;
    }
}
```

Hence the above code produces the following result.

<img src="/assets/images/tutorials/114/lesson_14_image_006.png" style="height:360px; width:360px"/>



**Using Simple Animations with Labels:**

We can also add animation effects to labels. The _ViewExtensions_ class provides us various ways to create simple animations. As an example we will learn to create a linearly translating label that moves from right to left.

```csharp
label.TranslateTo(-600, 0, 6000);
```



The _ViewExtensions_ class provides the following extension methods that can be used to create simple animations:

## Add a Label to the Demo Application

Our main purpose is to create a _label_ widget and change its text when the _button_ widget is clicked upon. Hence we create a _label_ widget and a _button_ widget. Since we want to display a string ‘Number of clicks’ along with the count of number times the _button_ widget has been clicked, we keep a variable ‘clicks’ which keeps count of the number of times the widget has been clicked and the text of the label is also modified.

<img src="/assets/images/tutorials/114/lesson_14_image_007.png" style="height:401px; width:459px"/>

```csharp
int clicks = 0;
Label label = new Label
{
	Text = String.Format("Number of clicks: {0}", clicks),
	VerticalOptions = LayoutOptions.CenterAndExpand,
	HorizontalOptions = LayoutOptions.Center,
};

```



The next step is to create a _button_ widget and an _event handler_ , which we learnt in the previous lesson. So the final code looks like this:

```csharp
Button button = new Button
{
	Text = "Click on me!",
	VerticalOptions = LayoutOptions.CenterAndExpand,
	HorizontalOptions = LayoutOptions.Center,
};

button.On<Xamarin.Forms.PlatformConfiguration.Tizen>().SetStyle(ButtonStyle.Default);
button.Clicked += OnButtonClicked;

MainPage = new ContentPage
{
	Content = new StackLayout
	{
		VerticalOptions = LayoutOptions.Center,
		Children = {
			label,
			button
		}
	}
};

void OnButtonClicked(object sender, EventArgs args)
{
	clicks++;
	label.Text = String.Format("Number of clicks: {0}", clicks);
}

```

<img src="/assets/images/tutorials/114/lesson_14_image_008.png" style="height:484px; width:511px"/>

Hence we can now create a _label_ widget and can successfully change its text when the _button_ widget is clicked. We can also add various styles to the _button_ widget as learnt in the previous lesson. Some of the examples are shown below.

<img src="/assets/images/tutorials/114/lesson_14_image_009.png" style="height:602px; width:638px"/>

<img src="/assets/images/tutorials/114/lesson_14_image_010.png" style="height:597px; width:599px"/>

The full source code for this lesson is attached [here](https://s3-us-west-1.amazonaws.com/tizenschool/114/Wearable_Lesson014.zip).

# VII. Popup window with Control elements

## Information Popup

In this lesson, we'll look at popup windows, the purpose and the way of its using. In the end of the lesson, as a practice, we will show you how to add user popup confirmation request to close the application.



**Popup Description**

Often in applications, it becomes necessary to display important information on the top of the entire user interface, or to request confirmation and/or cancellation of some action. To do this, you can use a popup window. To create a popup, use the following namespace:

```csharp
using Tizen.Wearable.CircularUI.Forms;
using Xamarin.Forms;

```



**Information Popup**

Information popup has a control to show progress/information and one button in the bottom side of the circular screen.

<img src="/assets/images/tutorials/114/lesson_15_image_001.png" style="height:566px; width:440px"/>

<br/> **Information Popup Creation**

Main use of the Information popup is to display some information or progress of some task, and display one action button at the bottom of the popup.

Information popup is created by instantiating the _InformationPopup_ class.

```csharp
var popup = new InformationPopup();
```



Set the Title and Text to the popup, Text of the popup is scrollable, Popup internally added scroller to this layout when size of the text is greater than total popup height:

```csharp
popup.Title = "Popup Title";
popup.Text = "Information Popup Text";

```



Create and add button to the popup:

```csharp
var button = new MenuItem()
{
    Text = "Ok",
};

popup.BottomButton = button;

```

Handle back button press and bottom button clicked event, here popup will be removed on back button press or bottom button click event:

```csharp
popup.BackButtonPressed += (s, a) =>
{
    popup.Dismiss();
};

popup.BottomButton.Clicked += (s, a) =>
{
    popup.Dismiss();
};
```



Display the popup:

```csharp
popup.Show();
```

<img src="/assets/images/tutorials/114/lesson_15_image_002.png" style="height:567px; width:440px"/>

Delete the popup:

```csharp
popup.Dismiss();
```





## Two Button Popup

Two Button popup has a control to show progress/information and two buttons in left and right side of the circular screen.



**TwoButtonPopup Creation**

Main use of the two button popup is to display some information or progress of some task, and display two action buttons at the left and right side of the popup.



Two button popup is created by instantiating the _TwoButtonPopup_ class.

```csharp
var popup = new TwoButtonPopup();
```



Set the Title and Text to the popup, Text of the popup is scrollable, Popup internally added scroller to this layout when size of the text is greater than total popup height:

```csharp
popup.Title = "Popup Title";
popup.Text = "Two Button Popup Text";

```



Create two buttons and add to the popup:

```csharp
var leftButton = new MenuItem()
{
    Text = "Delete",
    Icon = new FileImageSource { File = "lesson_12_icon_delete.png" },
};

var rightButton = new MenuItem()
{
    Text = "Save",
    Icon = new FileImageSource { File = "lesson_12_icon_save.png", },
};

popup.FirstButton = leftButton;
popup.SecondButton = rightButton;

```



Handle back button press, left button clicked, and right button clicked event, here popup will be removed on back button press or left/right button click event:

```csharp
popup.BackButtonPressed += (s,a) =>
{
    popup.Dismiss();
};

popup.FirstButton.Clicked += (s, a) =>
{
    popup.Dismiss();
};

popup.SecondButton.Clicked += (s, a) =>
{
    popup.Dismiss();
};

```



Display the popup:

```csharp
popup.Show();
```

<img src="/assets/images/tutorials/114/lesson_15_image_003.png" style="height:563px; width:449px"/>



Delete the popup:

```csharp
popup.Dismiss();
```



## Add a Popup Window to the Demo Application

Now move on to the practice and finish our demo application. We will show you how to create a popup window with two buttons: undo and confirm. The text message also will be displayed. In case of confirmation, the application will be closed; otherwise the popup window will be deleted by pressing the _cancel button_ or the hardware _Back button._









<img src="/assets/images/tutorials/114/lesson_15_image_004.png" style="height:48px; width:48px"/>

<img src="/assets/images/tutorials/114/lesson_15_image_005.png" style="height:48px; width:48px"/>









The full source code for this application is attached [here](https://s3-us-west-1.amazonaws.com/tizenschool/114/Wearable_Lesson015.zip).



# VIII. Image, Custom renderer and Scroller Widget

## Image Creation

In this lesson, we are going to show you how to create your second demo application. To create scrollable image, first of all, you will have to add the image, and then place it in the container with the scrollable area(Scroller). In the next lesson, after adding some logic, your application will turn into mini game.



**Image Creation**

_Image_ widget is usually used to display the image on the screen. This widget allows to display an image, as well as to display and to play animated .gif images.

This widget allows you to use an image file or directly the memory area where the image is stored. The last option is convenient when you download an image from the Internet, and you have no need to save it.



Take the following image and load it into the application.

<img src="/assets/images/tutorials/114/lesson_16_image_001.jpg" style="undefined"/>



It is advised to place _graphics, audio and other resources_ in the _res/ directory_ of your project. Only your application has access to this folder. During the application building, all the contents of this folder get into the  **_.tpk_** package. Create the _images/directory_ inside the _res/ directory_ and put the image there.













Image will be displayed as follow:

<img src="/assets/images/tutorials/114/lesson_16_image_002.png" style="height:569px; width:446px"/>

## Introduction to Custom Renderers

Custom renderers provide a powerful approach for customizing the appearance and behavior of _Xamarin.Forms_ controls. They can be used for small styling changes or sophisticated platform-specific layout and behavior customization. This article provides an introduction to custom renderers, and outlines the process for creating a custom renderer.



_Xamarin.Forms Pages, Layouts and Controls_  present a common API to describe cross-platform mobile user interfaces. Each _page, layout, and contro_ l is rendered differently on each platform, using a _Renderer_  class that in turn creates a native control (corresponding to the _Xamarin.Forms_ representation), arranges it on the screen, and adds the behavior specified in the shared code.



Developers can implement their own custom Renderer classes to customize the appearance and/or behavior of a control. Custom renderers for a given type can be added to one application project to customize the control in one place while allowing the default behavior on other platforms; or different custom renderers can be added to each application project to create a different look and feel on iOS, Android, and the Universal Windows Platform (UWP). However, implementing a custom renderer class to perform a simple control customization is often a heavy-weight response. Effects simplify this process, and are typically used for small styling changes.



Now customize an image using custom renderer:









## Using .gif Animation in Image Widget

As it was mentioned before, Tizen’s Image widget supports .gif animation but Xamarin forms doesn’t. So, to access the platform’ specific property, we need to write a custom renderer.



Let's try to use the following animation as a resource.

<img src="/assets/images/tutorials/114/lesson_16_image_003.gif" style="height:360px; width:360px"/>

We can treat GIF as an image, but by default, if you specify the path to such animation, the widget displays the file as a static image. You need to call additional functions to start the animation.



**Using Custom Renderer to play .gif in Image**

To play .gif in Image need to set _IsAnimated_ and _IsAnimationPlaying_ properties of the image.















.GIF animation will be played in Image Widget.

## Creating and Using the Scroller

In case you have a large amount of content to be placed on the screen, you can use a scroller that has a scroll area.

_Scroller_ is added as a layer between the conformant and the image, so if the size of the original image is larger than the display size, you can scroll the image in areas that is not included to the display borders. The scroller will be placed in a conformant, and the image will be placed in the scroller as it shown in the diagram below.

<img src="/assets/images/tutorials/114/lesson_16_image_004.png" style="height:463px; width:689px"/>

Create a function to create scrollable image:

```csharp
private void CreateScrollableImage()
{
}

```



To create a new image Control, use the following function:

```csharp
var image = new Image();
```



Add the following image, which will be bigger than the screen of the watch (in this case the screen is 360x360).

<img src="/assets/images/tutorials/114/lesson_16_image_005.png" style="height:562px; width:1200px"/>



To add image file name use Source property of Image class:

```csharp
image.Source = "lesson_16_3.png";
```



Create content page, create Scroller and add image as content to Scroller:

```csharp
ContentPage Scroller_image_page = new ContentPage
{
	Content = new ScrollView
	{
		Orientation = ScrollOrientation.Both,
		Content = image,
	}
};

```



Add content page to main page list:

```csharp
MainPage = Scroller_image_page;
```

You can see the result of scrollable image as below:

#V@https://s3-us-west-1.amazonaws.com/tizenschool/114/WearableLesson_16.mp4#V@



The full source code for this lesson is attached [here](https://s3-us-west-1.amazonaws.com/tizenschool/114/Wearable_Lesson016.zip).

# IX. Popup, Toast Style and types of scroller events

## Scroller Events

In this tutorial, we will continue writing second demo application. Moreover we will look at events that can be caught in the scroller and show how they can be used. Next, we will show you how to create a popup (Toast) window with a displayed message to notify users. At the end of this lesson, we will convert the application into a simple game.



**Scroller Events**



_ScrollView_ of _Xamarin.Forms_ supports below events that can be used like a feedback to the container.

However, Tizen platform supports some extra events for scrollview. These events can be accessed by writing custom renderer for Scrollview.

This can be handy in some situations, for example, we can find out when the scroll action is occurred or when the page is scrolled.



​Below is the code snippet to handle this event in renderer side.

```cpp
protected override void OnElementChanged(ElementChangedEventArgs<ScrollView> e)
{
	base.OnElementChanged(e);
	if (Control != null)
	{
		Control.DragStart += ControlDragStart;
		Control.DragStop += ControlDragStop;
		Control.PageScrolled += ControlPageScrolled;
	}
}

private void ControlPageScrolled(object sender, EventArgs e)
{
}

private void ControlDragStop(object sender, EventArgs e)
{
}

private void ControlDragStart(object sender, EventArgs e)
{
}

```

Sometimes in the application there is a situation when some text information, for example, a small hint or an error message needs to be outputted to the user. For this there is Toast popup window provided by _Tizen.Wearable.CircularUI.Forms_ . Let's add to the application a popup message, which is saying that the user can move the image with his finger across the screen.



After scroller creation and placing image in its content, we can show a Toast to guide the user to scroll to view the whole image.



Initially, to use the features provided by _Tizen.Wearable.CicularUI.Forms_ we need to initialize the _FormsCircularUI_ class which provides Tizen wearable specific APIs in our platform specific code _<projectname>.Tizen.Wearable.cs_ .

```csharp
static void Main(string[] args)
{
	var app = new Program();
	global::Xamarin.Forms.Platform.Tizen.Forms.Init(app);
	FormsCircularUI.Init();
	app.Run(args);
}
```

After adding the _FormsCircularUI_ to the code, we can add the _Toast_ in our shared code.

```csharp
Toast.DisplayText("To move, slide your finger across the screen...", 5000);

```

<img src="/assets/images/tutorials/114/lesoon_17_image_001.png" style="height:338px; width:290px"/>





## Making a Mini-Game from the Demo Application

Now, we will show you how to turn the demo application into a mini game, based on the material of this lesson.



**Game description** : The user is on a large map, and he or she by moving the map across the screen, should find a treasure. On the map there will be a line, helping the user to navigate on the map.



First of all, you should use a map image instead of the current image. We have drawn this kind of map for using it in this game. The image of the map is large enough. One cell has a size: 360x360.



Place it in the project using the following path: **res/images/map.jpg.**

<img src="/assets/images/tutorials/114/lesoon_17_image_002.jpg" style="height:289px; width:578px"/>

Initially, begin with adding the _ScrollView_ property to the _App_ class with _scroll orientation_ in both the direction.

```csharp
ScrollView scrollview = new ScrollView
{
    Orientation = ScrollOrientation.Both,
};

```

Add an image object, to include an image “images/map.jpg” in the application. After this, set it as the content of scrollview throught the object of _ScrollView_ so that image can be scrolled.

```csharp
Image image = new Image
{
	Source = "images/map.jpg"
};
scrollview.Content = image;

```

On the map determine the coordinates where the treasure is located (horizontally and vertically):

<img src="/assets/images/tutorials/114/lesoon_17_image_003.png" style="height:289px; width:578px"/>



It turned out that X = 3908, and Y = 943.



As long as each time the scrolling area moves, it should be checked, whether the point with the treasure has entered the scroller's area, we have to register the callback for the scroll event. For this add an event handler <scrolled>.

```csharp
scrollView.Scrolled += ScrollviewOnScrolled;
. . .

private void ScrollviewOnScrolled(object sender, ScrolledEventArgs e)
{
	. . .
}
```

As it was mentioned before, you should check whether a treasure is found or not. Then determine where the scroll zone is in relation to the content. To obtain this data, _ScrollView_ has the following property:

```csharp
double xCenter = scrollView.ScrollX + width / 2;
double yCenter = scrollView.ScrollY + height / 2;

```

Add the constants for the received coordinates of the treasure, height and width.

```csharp
const int treasureX = 3908;
const int treasureY = 943;
const int width = 360;
const int height = 360;
const int AreaRadius = 150;

```

The constant “AreaRadius” will be used as the radius of the circular zone in which you will be looking for the desired point.  Since the scroller is stretched to the whole screen, and its size is 360x360, then the radius of the round screen is 180. Take a slightly smaller circle so in the beginning the cross on the map fully enters on the screen, after which it will be signaled that the treasure is found.



To determine whether the point is in the circle, write the following function:

```csharp
private bool IsPointInCircle(double xCenter, double yCenter)
{
	double deltaX = Math.Abs(xCenter - treasureX);
	double deltaY = Math.Abs(yCenter - treasureY);
	double distance = Math.Sqrt((deltaX * deltaX) + (deltaY * deltaY));
	if (distance < AreaRadius)
	{
		return true;
	}
	return false;
}
```

In order to notify the user that the treasure is found, use _Toast_ . Add _Toast_ to the event handler for scroll event, if the treasure is found.

```csharp
private void ScrollviewOnScrolled(object sender, ScrolledEventArgs e)
{
	ScrollView scrollView = (ScrollView)sender;
	double xCenter = scrollView.ScrollX + width / 2;
	double yCenter = scrollView.ScrollY + height / 2;
	bool isInCircle = IsPointInCircle(xCenter, yCenter);
	if (isInCircle)
    {
		scrollView.InputTransparent = true;
		Toast.DisplayText("Congratulations! You found the treasure.");
	}
}
```

It may happen that you have simultaneously created a lot of popup windows, so you have to explicitly stop the scroller if the target area is found.

In the library there is no special function to just stop scrolling but we can stop the user interaction with the visual element. In order to disable the user input and make scroller transparent to user input we can set _InputTransparent_ property true.

```csharp
if (isInCircle)
{
	scrollView.InputTransparent = true;
	Toast.DisplayText("Congratulations! You found the treasure.");
}

```

That would be all for this lesson. Now you may see the game below.



#V@https://s3-us-west-1.amazonaws.com/tizenschool/114/WearableLesson_17.mp4#V@



The complete source code of this tutorial is available [here](https://s3-us-west-1.amazonaws.com/tizenschool/114/Wearable_Lesson017.zip).





# X. Stack layout

## What is Stack Layout?

From this lesson we will start our next demo application. In which we will show you how by using a _scroll view_ , a  _Stack Layout_ , _image widgets_ , and an _index widge_ t - display the active page and create an interface with a page-by-page content preview. In this lesson, we will take a closer look at the  _Stack Layout_  and get acquainted with its available options. Moreover, we will create the container itself and fill it with the contents.



**What is Stack Layout?**

_StackLayout_ organizes views in a one-dimensional line ("stack"), either horizontally or vertically. Views in a _StackLayout_ can be sized based on the space in the layout using layout options. Positioning is determined by the order views were added to the layout and the layout options of the views.



Below is a diagram of the components location, placed in the StackLayout.

<img src="/assets/images/tutorials/114/lesson_18_image_001.png" style="height:360px; width:662px"/>

_StackLayout_ is less complex than other views. Simple linear interfaces can be created by just adding views to a _StackLayout_ , and more complex interfaces created by nesting them.

## Usage & Behavior



**Spacing**

By default, _StackLayout_ will add a 6px margin between views. This can be controlled or set to have no margin by setting the _Spacing_ property on _StackLayout_ . The following code demonstrates how to set spacing and the effect of different spacing options:

```csharp
public class StackLayoutCode : ContentPage
{
	public StackLayoutCode() {
		var layout = new StackLayout();
		var button = new Button {
			Text = "StackLayout",
			VerticalOptions = LayoutOptions.Start,
			HorizontalOptions = LayoutOptions.FillAndExpand
		};
		var yellowBox = new BoxView {
			Color = Color.Yellow,
			VerticalOptions = LayoutOptions.FillAndExpand,
			HorizontalOptions = LayoutOptions.FillAndExpand
		};
		var greenBox = new BoxView {
			Color = Color.Green,
			VerticalOptions = LayoutOptions.FillAndExpand,
			HorizontalOptions = LayoutOptions.FillAndExpand
		};
		var blueBox = new BoxView {
			Color = Color.Blue,
			VerticalOptions = LayoutOptions.FillAndExpand,
			HorizontalOptions = LayoutOptions.FillAndExpand,
			HeightRequest = 75
		};
		layout.Children.Add(button);
		layout.Children.Add(yellowBox);
		layout.Children.Add(greenBox);
		layout.Children.Add(blueBox);
		layout.Spacing = 10;
		Content = layout;
	}
}
```



**Sizing**

The size of a view in a _StackLayout_ depends on both the height and width requests and the layout options. _StackLayout_ will enforce padding. The following LayoutOptions will cause views to take up as much space as is available from the layout:



**Positioning**

Views in a _StackLayout_ can be positioned and sized using _LayoutOptions_ . Each view can be given _VerticalOptions_ and _HorizontalOptions_ , defining how the views will position themselves relative to the layout. The following predefined _LayoutOptions_ are available:

## Filling StackLayout with Elements

We will now try to implement whatever we learned previously and try to create a _StackLayout_ with two buttons as its children. Since we have learnt how to create buttons previously we won’t particularly stop on this topic.

```csharp
public App() {
	// The root page of your application
	MainPage = new ContentPage
	{
		Content = new StackLayout
		{
			HorizontalOptions = LayoutOptions.FillAndExpand,
			VerticalOptions = LayoutOptions.FillAndExpand,
			Children = {
				new Button {
					Text = "Button1",
					VerticalOptions = LayoutOptions.FillAndExpand,
					HorizontalOptions = LayoutOptions.FillAndExpand,
				},
				new Button {
					Text = "Button2",
					VerticalOptions = LayoutOptions.FillAndExpand,
					HorizontalOptions = LayoutOptions.FillAndExpand,
				}
			},
		Spacing = 0,
		}
	};
}
```

<img src="/assets/images/tutorials/114/lesson_18_image_002.png" style="height:360px; width:360px"/>

The above code creates two buttons occupying all free space lying over each other vertically on the screen, since we did not specify their orientation. _StackLayout_ also has a default spacing of 6px; hence if we do not specify spacing as 0, we can notice a small gap between the two buttons.

<img src="/assets/images/tutorials/114/lesson_18_image_003.png" style="height:360px; width:360px"/>

We can use _BackgroundColor_ to color the two buttons and can specify the particular color which we want to use.

```csharp
Content = new StackLayout
{
	HorizontalOptions = LayoutOptions.FillAndExpand,
	VerticalOptions = LayoutOptions.FillAndExpand,
	Children = {
		new Button {
			Text = "Button1",
			BackgroundColor = Color.DarkBlue,
			VerticalOptions = LayoutOptions.FillAndExpand,
			HorizontalOptions = LayoutOptions.FillAndExpand,
		},
		new Button {
			Text = "Button2",
			BackgroundColor = Color.DarkGreen,
			VerticalOptions = LayoutOptions.FillAndExpand,
			HorizontalOptions = LayoutOptions.FillAndExpand,
		}
	},
	Spacing = 0,
}
```

<img src="/assets/images/tutorials/114/lesson_18_image_004.png" style="height:360px; width:360px"/>

As you can see, both buttons share space equally. We can use _StackLayout_ in two perspectives: _vertical_ and _horizontal_ . Hence we can change the orientation from vertical to horizontal using _Orientation_ function.

```csharp
Content = new StackLayout
{
	Orientation = StackOrientation.Horizontal,
	HorizontalOptions = LayoutOptions.FillAndExpand,
	VerticalOptions = LayoutOptions.FillAndExpand,
	Children = {
		new Button {
			Text = "Button1",
			BackgroundColor = Color.DarkBlue,
			VerticalOptions = LayoutOptions.FillAndExpand,
			HorizontalOptions = LayoutOptions.FillAndExpand,
		},
		new Button {
			Text = "Button2",
			BackgroundColor = Color.DarkGreen,
			VerticalOptions = LayoutOptions.FillAndExpand,
			HorizontalOptions = LayoutOptions.FillAndExpand,
		}
	},
	Spacing = 0,
}

```

<img src="/assets/images/tutorials/114/lesson_18_image_005.png" style="height:360px; width:360px"/>

We can also provide spacing in the vertical orientation as done earlier by changing the spacing parameter.



## Controlling the Objects alignment

We can align the objects as per our need. As given in positioning section we can align the elements towards center, start and end of the page.



To align button1 element towards left we change its _horizontal_ property.

```csharp
new Button
{
	Text = "Button1",
	BackgroundColor = Color.DarkBlue,
	VerticalOptions = LayoutOptions.FillAndExpand,
	HorizontalOptions = LayoutOptions.Start,
}
```

<img src="/assets/images/tutorials/114/lesson_18_image_006.png" style="height:360px; width:360px"/>

Similarly align button1 element towards right we change button2’s _horizontal_ property so that button1 has more space to occupy.

```csharp
new Button
{
	Text = "Button2",
	BackgroundColor = Color.DarkBlue,
	VerticalOptions = LayoutOptions.FillAndExpand,
	HorizontalOptions = LayoutOptions.End,
}
```

<img src="/assets/images/tutorials/114/lesson_18_image_007.png" style="height:360px; width:360px"/>

For vertical orientation,

To shift the button1 upwards we change its _vertical_ property.

```csharp
new Button
{
	Text = "Button1",
	BackgroundColor = Color.DarkBlue,
	VerticalOptions = LayoutOptions.Start,
	HorizontalOptions = LayoutOptions.FillAndExpand,
}
```

<img src="/assets/images/tutorials/114/lesson_18_image_008.png" style="height:360px; width:360px"/>

To shift the button1 downwards we change the _vertical_ property of button2 so as to provide more space to button1.

```csharp
new Button
{
	Text = "Button2",
	BackgroundColor = Color.DarkBlue,
	VerticalOptions = LayoutOptions.End,
	HorizontalOptions = LayoutOptions.FillAndExpand,
}
```

<img src="/assets/images/tutorials/114/lesson_18_image_009.png" style="height:360px; width:360px"/>

So far we have used _FillAndExpand_ so that our elements use all the free space available to them. Now we will try to center each element and see what happens.

```csharp
Content = new StackLayout
{
	HorizontalOptions = LayoutOptions.FillAndExpand,
	VerticalOptions = LayoutOptions.FillAndExpand,
	Children = {
		new Button {
			Text = "Button1",
			BackgroundColor = Color.DarkBlue,
			VerticalOptions = LayoutOptions.Center,
			HorizontalOptions = LayoutOptions.Center,
		},
		new Button {
			Text = "Button2",
			BackgroundColor = Color.DarkGreen,
			VerticalOptions = LayoutOptions.Center,
			HorizontalOptions = LayoutOptions.Center,
		}
	},
}

```

Here we will use both the object in their default size,

<img src="/assets/images/tutorials/114/lesson_18_image_010.png" style="height:360px; width:360px"/>

Our next objective is to keep both the buttons in equal proportion and use the free vertical space available to them hence we _FillAndExpand_ the _vertical_ property of both of our elements.

```csharp
Content = new StackLayout {
	HorizontalOptions = LayoutOptions.FillAndExpand,
	VerticalOptions = LayoutOptions.FillAndExpand,
	Children = {
		new Button {
			Text = "Button1",
			BackgroundColor = Color.DarkBlue,
			VerticalOptions = LayoutOptions.FillAndExpand,
			HorizontalOptions = LayoutOptions.Center, },
		new Button {
			Text = "Button2",
			BackgroundColor = Color.DarkGreen,
			VerticalOptions = LayoutOptions.FillAndExpand,
			HorizontalOptions = LayoutOptions.Center,
		}
	},
}
```

<img src="/assets/images/tutorials/114/lesson_18_image_011.png" style="height:360px; width:360px"/>
                                                                                

We can easily shift the button1 upwards from what we have learnt previously using

```csharp
VerticalOptions = LayoutOptions.Start

```

<img src="/assets/images/tutorials/114/lesson_18_image_012.png" style="height:360px; width:360px"/>

To shift the button1 towards left we can change the _horizontal_ property of button1 towards left. Since the default sizes of buttons is too big we will use _HeightRequest_ and _WidthRequest_ property of Xamarin which eventually sets the desired height and width of the element.

After changing the _HeightRequest_ and _WidthRequest_ properties of the element, our code looks something like this.

```csharp
MainPage = new ContentPage
{
	Content = new StackLayout
	{
		HorizontalOptions = LayoutOptions.FillAndExpand,
		VerticalOptions = LayoutOptions.FillAndExpand,
		Children = {
			new Button {
				Text = "Button1",
				BackgroundColor = Color.DarkBlue,
				VerticalOptions = LayoutOptions.Start,
				HorizontalOptions = LayoutOptions.Center,
				WidthRequest = 80,
				HeightRequest = 150
			},
			new Button {
				Text = "Button2",
				BackgroundColor = Color.DarkGreen,
				VerticalOptions = LayoutOptions.FillAndExpand,
				HorizontalOptions = LayoutOptions.Center,
				WidthRequest = 80,
				HeightRequest = 150
			}
		},
	}
};

```

<img src="/assets/images/tutorials/114/lesson_18_image_013.png" style="height:360px; width:360px"/>

On changing the _horizontal_ property of button, the object tends to move out of the scope of the screen hence we provide a padding of 30. The _Padding_ property represents the distance between an element and its child elements, and is used to separate the control from its own content.

```csharp
MainPage = new ContentPage
{
	Content = new StackLayout
	{
		HorizontalOptions = LayoutOptions.FillAndExpand,
		VerticalOptions = LayoutOptions.FillAndExpand,
		Padding = 30,
		Children = {
			new Button {
				Text = "Button1",
				BackgroundColor = Color.DarkBlue,
				VerticalOptions = LayoutOptions.Start,
				HorizontalOptions = LayoutOptions.Start,
				WidthRequest = 80,
				HeightRequest = 150,
				Margin = 0
			},
			new Button {
				Text = "Button2",
				BackgroundColor = Color.DarkGreen,
				VerticalOptions = LayoutOptions.FillAndExpand,
				HorizontalOptions = LayoutOptions.Center,
				WidthRequest = 80,
				HeightRequest = 150
			}
		},
	}
};

```

<img src="/assets/images/tutorials/114/lesson_18_image_014.png" style="undefined"/>

We have now learned how to change the _vertical_ and _horizontal_ properties of elements both separately as well as simultaneously.



In the next lesson, we will use this layout for our next demo application.

# XI. Using scroller for pageview

## Prepare Layout and Scroller

In this lesson we will teach you how to create a _ScrollView_ container, fill the stack layout, created in the previous lesson with image. Next, we will put the stack layout in the created _scrollView_ and use the _scroller_ properties to implement page scrolling.



**Prepare Layout and Scroller**



Create a _ScrollView_ object to add the scrolling feature to the application.

```csharp
ScrollView scrollobj = new ScrollView
{
	Orientation = ScrollOrientation.Both,
	. . .
};
```

Add _stacklayout_ object to content of _scrollview_ object.

```csharp
StackLayout stacklayout = new StackLayout
{
	Orientation = StackOrientation.Horizontal
};

scrollobj.Content = stacklayout;
```

Change the _MainPage_ Content: Replace the _Stacklayout_ object with _ScrollView_ object.

```csharp
MainPage = new ContentPage
{
	Content = scrollobj
};
```

Add content to the _stacklayout_ . First take the following five images and use them as content.

<img src="/assets/images/tutorials/114/lesson_19_image_002.png" style="height:480px; width:480px"/>

<img src="/assets/images/tutorials/114/lesson_19_image_003.png" style="height:480px; width:480px"/>

<img src="/assets/images/tutorials/114/lesson_19_image_004.png" style="height:480px; width:480px"/>

<img src="/assets/images/tutorials/114/lesson_19_image_005.png" style="height:480px; width:480px"/>

<img src="/assets/images/tutorials/114/lesson_19_image_006.png" style="height:480px; width:480px"/>

Name these images 1.png, 2.png … 5.png for simplicity.



Create function for loading and displaying image as it was done in [lesson 16](http://tizenschool.org/tutorial/117/contents/15). We need to create image object to keep these images and maintain their attributes. Now we can add images to the corresponding objects and put them in _stacklayout_ as its _child_ property.

```csharp
private void LoadImages(StackLayout stacklayout)
{
	Image[] images = new Image[6];
	for (int i = 1; i <= 5; i++)
	{
		images[i] = new Image();
		String imagePath = "images/" + i.ToString() + ".png";
		images[i].Source = ImageSource.FromFile(imagePath);

		stacklayout.Children.Add(images[i]);
	}
}
```

Run the application and see the result.

<img src="/assets/images/tutorials/114/lesson_19_image_008.gif" style="height:552px; width:409px"/>

Also, change the orientation of the content from horizontal to vertical.

```csharp
StackLayout stacklayout = new StackLayout
{
	Orientation = StackOrientation.Vertical,
	Spacing = 0
};
```

<img src="/assets/images/tutorials/114/lesson_19_image_007.gif" style="height:548px; width:407px"/>





## Implementation of Page-by-page Scrolling

The _scrollview_ container can be used for _pageview_ , which means that during scrolling, it will always stop the scrolling area on the top of the page. You can specify different page sizes and a page scroll limit.



For example, in this application, as shown in the following image, you can stop scrolling, in the any point of the content.

<img src="/assets/images/tutorials/114/lesson_19_image_001.png" style="height:360px; width:360px"/>

Now set up the scroller for page scrolling so that the content of the pages always stops on the middle of the area, using the function:

```csharp
SetPageSize(ScrollerObj.W, ScrollerObj.H);

```

The function takes the size of the page, **which represents a “step” in pixels with which the area will be scrolled in the scroller.**



This function can be used through _ElmSharp_ scroller on platform side. As mentioned in [lesson 17](http://tizenschool.org/tutorial/117/contents/19), we need to write custom renderer for this purpose to access Tizen specific features ( _ElmSharp_ scoller in this case). This code will be included in a separate file for custom renderer.

```csharp
[assembly:ExportRenderer(typeof(MyScrollView), typeof(MyRenderer))]

namespace Wearable_Lesson019.Tizen.Wearable
{
	class MyRenderer : ScrollViewRenderer
	{
		protected override void OnElementChanged(ElementChangedEventArgs<ScrollView> e)
		{
			base.OnElementChanged(e);
			if (Control != null)
			{
				global::Xamarin.Forms.Platform.Tizen.Native.Scroller scroller = Control;
				var ScrollerObj = Element as MyScrollView;
				scroller.SetPageSize(ScrollerObj.W, ScrollerObj.H);
			}
		}
	}
}
```

For implanting the above code we need to make some changes in shared code. Following are the changes made in our shared platform independent code.



We need to make a new class for our custom scrollview to include the above features.

```csharp
public class MyScrollView : ScrollView
{
	public int W{ get; set; }
	public int H{ get; set; }
	public MyScrollView()
	{
		W = 360;
		H = 360;
	}
}

```



That's what we are supposed to receive.



#V@https://s3-us-west-1.amazonaws.com/tizenschool/114/WearableLesson_19.mp4#V@



The complete source code of this tutorial is available [here.](https://s3-us-west-1.amazonaws.com/tizenschool/114/Wearable_Lesson019.zip)



# XII. Index Page, Circle Page, Circle Scroller and Rotary selector

## Index Page

In this lesson, we will look at an _index_ widget, learn how to create and use it. We will consider only the " _circle_ " style for the _index_ widget in which the elements circled on the screen.



**Index Widget Description**



The _index_ widget is used to display pages. For wearable devices with a round display, it is allowed to display from 1 to 20 indicators and only active one will be highlighted.



The _IndexPage_ is extension of _Xamarin.Forms.MultiPage_ . When a Page is added or removed from _IndexPage_ , circular index is added or removed automatically from the top of window.



Adding an _index_ widget to an application is simple. We simply have to use _Tizen.Wearable.CircularUI.Forms_ as a namespace. Then we can directly create an _IndexPage_ .



We will now learn to create an _Index_ widget consisting of pages which have different background colors. After successfully creating a basic Index widget with different colors, we will create an Index widget consisting of different images.



To create an index widget,

```csharp
IndexPage p = new IndexPage();

```

To create an Index widget consisting of pages with different background colors, we create a function which returns the page with given color. Then push this page into the _IndexPage_ .

```csharp
private ContentPage GetPage(Color c)
{
	ContentPage myPage = new ContentPage
	{
		BackgroundColor = c
	};
	return myPage;
}

public App()
{
	IndexPage p = new IndexPage();

	p.Children.Add(GetPage(Color.Red));
	p.Children.Add(GetPage(Color.Black));
	p.Children.Add(GetPage(Color.Yellow));

	MainPage = p;
}
```

Now you can run this application and look at the result as below.



**#V@https://s3-us-west-1.amazonaws.com/tizenschool/114/WearableLesson_20.1.mp4#V@**



To use images in an _index_ widget, we simply add the images in the respective _ContentPages,_

```csharp
private ContentPage GetPage(string imageName)
{
	var myImage = new Image()
	{
		VerticalOptions = LayoutOptions.FillAndExpand,
		HorizontalOptions = LayoutOptions.FillAndExpand
	};
	myImage.Source = imageName;

	ContentPage myPage = new ContentPage
	{
		Content = new StackLayout
		{
		VerticalOptions = LayoutOptions.Center,
		Children = {
			myImage,
		}
	}
};
	return myPage;
}

public App()
{
	IndexPage p = new IndexPage();
	p.Children.Add(GetPage("img1.jpg"));
	p.Children.Add(GetPage("img1.jpg"));
	p.Children.Add(GetPage("img1.jpg"));
	MainPage = p;
}

```

You can run this application and look at the result as below.



**#V@https://s3-us-west-1.amazonaws.com/tizenschool/114/WearableLesson_20.2.mp4#V@**



The source code of this tutorial is available [here.](https://s3-us-west-1.amazonaws.com/tizenschool/114/WearableLesson_20.zip)



In the next lesson, by using a _circle scroller_ , we'll handle the case, where the number of pages is larger than it is allowed for the index.



## Circle Page and Circle Scroller

In this lesson we will finish third demo application. You may have a question: what to do with the index if the number of pages is growing. In this case, our advice is to use a circle scroller.



Now, we will show you how to add a round surface, and place a circle scroller there as well as how to use it to implement page flipping by bezel. Moreover, when there are a lot of pages, the scroller will be used like an alternative to the index widget.



**Creating a Circle Page**

To draw round objects on the screen we need a special surface. Hence we will use _CirclePage_ . The _CirclePage_ is a _ContentPage_ , which allows you to insert views that require _CircleSurface_ , and you can show _ToolbarItems_ with _MoreOption_ . It has an _ActionButton_ , and can use the _MenuItem_ type as text, icon, command, and so on. To create a _CirclePage_ we use

```csharp
CirclePage p = new CirclePage();
```



**Create a Circle Scroller**

To create a circle scoller use the _CircleScrollView_ class provided in Xamarin.

```csharp
CircleScrollView sv = new CircleScrollView()
```



Since our objective is to add various contents to the _CircleScroller_ , we just need to add the content to the _CircleScrollView_ created above. Hence to add several images we do

```csharp
CircleScrollView sv = new CircleScrollView()
{
	Orientation = ScrollOrientation.Horizontal,
	Content = new StackLayout
	{
		Orientation = StackOrientation.Horizontal,
		HorizontalOptions = LayoutOptions.Center,
		VerticalOptions = LayoutOptions.Center,
		Children =
		{
			image1,
			image2,
			image3,
		}
	}
};
```



To keep scroller to be in horizontal direction scrolling from left to right and vice versa, we keep the orientation of the _CircleScrollView_ as horizontal and then add the images. The _StackLayout_ created above is also set in horizontal direction for obvious reasons.



Now we have successfully created a _CirclePage_ and _CircleScrollView_ . The next step is to set the content of _CirclePage_ as below

```csharp
p.Content = sv;
```



To take up the rotatory event application need to use an interface _IRotaryFocusable_ , which is used to take a rotatory event?

```csharp
p.RotaryFocusObject = sv;
```



The final code looks something like this.

```csharp
private Image getImage(string imgName, int width, int height)
{
	var image = new Image()
	{
		HeightRequest = height,
		WidthRequest = width,
		VerticalOptions = LayoutOptions.Center,
		HorizontalOptions = LayoutOptions.Center
	};
	image.Source = imgName;
	return image;
}

public App()
{
	var image1 = getImage("img1.jpg", 300, 400);
	var image2 = getImage("img2.jpg", 300, 400);
	var image3 = getImage("img3.jpg", 300, 400);

	CirclePage p = new CirclePage();
	CircleScrollView sv = new CircleScrollView()
	{
		Orientation = ScrollOrientation.Horizontal,
		Content = new StackLayout
		{
			Orientation = StackOrientation.Horizontal,
			HorizontalOptions = LayoutOptions.Center,
			VerticalOptions = LayoutOptions.Center,
			Children =
			{
				image1,
				image2,
				image3,
			}
		}
	};

	p.RotaryFocusObject = sv;
	p.Content = sv;
	MainPage = p;
}

```



You can adjust the size of the image as per your requirements using _HeightRequest_ and _Widthrequest_ .



Run this application and you should get below result.

**#V@https://s3-us-west-1.amazonaws.com/tizenschool/114/WearableLesson_21.mp4#V@**



The source code for this application is available [here](https://s3-us-west-1.amazonaws.com/tizenschool/114/WearableLesson_21.zip)

## Rotary selector

In this section of guide we will learn how to create a rotary selector, add elements to it, and try to handle the events when the elements are clicked.



**Rotary selector** is a widget provided by _Tizen.Wearable.CircularUI_ . It is not one of the standard library widgets; moreover it is specifically designed for round wearable devices. This widget consists of several elements, arranged in a circle on one or several pages of a wearable device.<br/><br/> **Rotary Selector** allows you to conveniently select items or go to the next or previous page by rotating the bezel. This widget will be useful if, for example, instead of using the standard list, you will add the application settings items or items for displaying and providing a selection of some categories in the application. In some cases, you can look at the  **rotary selector** widget as a replacement for the standard list on the watch. Using this widget you can see more items on the screen and have a more similar look to the standard watch applications, if necessary.



**Creating a Rotary Selector**

Add a Rotary Selector we need to create a CirclePage which we learnt in the previous lesson.

```csharp
CirclePage cp = new CirclePage();
```



The basic Content Page is now created; we just need to append the elements in a circular fashion. To append the elements use the _ToolbarItem_ class. Here we will only use the text and icon property of _ToolbarItem_ . To add icon we can directly provide the image source path as a string.

To create a simple _ToolbarItem_ , we simply do:

```cpp
ToolbarItem t1 = new ToolbarItem
{
	Text = "tool1",
	Icon = "default.png"
};

```



The next step is to append this _ToolbarItem_ to our _CirclePage_ , which can be done simply be using the _MoreOption_ feature provided by **_CirclePage_** since _CirclePage_ maintains a list of _ToolbarItems_ .This can be achieved by simply using,

```csharp
cp.ToolbarItems.Add(t1);
```



We should now get something like this,



<img src="/assets/images/tutorials/114/lesson_22_image001.png" style="height:360px; width:360px"/>



**Adding Items to the Rotary Selector**

To add multiple elements we create and append multiple _ToolbarItem_ . In this sample application we have appended 13 ToolbarItems to the _CirclePage_ . On running the application we should see the following result:



**#V@https://s3-us-west-1.amazonaws.com/tizenschool/114/WearableLesson_22.1.mp4#V@**



As expected, 13 items with basic text were displayed on the screen. Also, when you rotate the bezel, you can see how selector moves around the circle of the screen, and if it reaches the end of the current page, it goes to the next one.



One of the many advantages of using _ToolbarItem_ class is that we can change its properties, such as the icon of the item, the priority of the item and a few more things. We had previously used only the Text and icon property of _ToolbarItem_ .



**Event Handling in Rotary Selector**

The rotary selector supports item-clicked event handler i.e. we can handle the events once the item is clicked upon. Adding an event handler to an item is fairly simple. The _ToolbarItem_ class provides an _EventHandler_ named Clicked, which gets activated once the item is clicked. Hence handling an event in rotary selector is very similar to handling events in _Buttons_ which we learnt previously.

<br/>Following example now provides the event handling option for _ToolbarItem_ t1 which gets activated when the item is clicked.

```csharp
public App()
{
	CirclePage cp = new CirclePage();
	for (int i = 1; i <= 13; i++)
	{
		ToolbarItem item = new ToolbarItem
		{
			Text = "tool " + i,
			Icon = "default.png",
		};
		item.Clicked += Item_Clicked;
		cp.ToolbarItems.Add(item);
	}
	MainPage = cp;
}

private void Item_Clicked(object sender, EventArgs e)
{
	ToolbarItem item = sender as ToolbarItem;
	ContentPage mypage = new ContentPage()
	{
		Content = new StackLayout
		{
			VerticalOptions = LayoutOptions.Center,
			Children =
			{
				new Label
				{
					 HorizontalTextAlignment = TextAlignment.Center,
					 Text =  item.Text + " opened!"
				},
			}
		}
	};
	MainPage.Navigation.PushModalAsync(mypage);
}
```



When the item is clicked, our objective is to open a new page displaying “Tool1 Opened”.<br/>

After running this application we should get the following result:

**#V@https://s3-us-west-1.amazonaws.com/tizenschool/114/WearableLesson_22.2.mp4#V@**



The source code for this application is available [here](https://s3-us-west-1.amazonaws.com/tizenschool/114/Wearable_lesson22.zip)


