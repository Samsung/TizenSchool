---
layout: ../../layouts/tutorial/TextTutorial.astro
title: 'How to Create "Heart Rate Monitor" App'
description: "This tutorial teaches how to create Heart Rate Monitor app using Xamarin Forms and Sensor API."
created: "2017/09/12"
modified: "2018/09/24"
profile: ["mobile"]
type: "dotnet"
level: 3
state: "open"
thumbnail: "/assets/images/tutorials/14/heart_monitor.jpg"
---

# I. INTRODUCTION

## 1. Overview

In this tutorial, we will create a Heart Rate Monitor application which will use Sensor API to obtain information about user's heart rate in order to present it on the screen.

First, take a look at the final version of the application. The applicationâ€™s UI consists of two pages:

Measurement page is the main application page on which the user operates most of the time when the application runs. It defines two view layers:

The **Welcome layer** is displayed during the application startup and visible only once, when the application is running.

<img src="/assets/images/tutorials/14/hrm-welcome-layer.png" style="width:30%"/>

It contains **Get started** button which allows the user to display the **Main layer** of the **Measurement page** .

The **Main layer** of the **Measurement page** allows the user to start and cancel the measurement process. During measurement it displays heart animation, instantaneous value of the heart rate, remaining measurement time, and indicates whether the heart rate limit is exceeded.

<img src="/assets/images/tutorials/14/hrm-main-layer-ready.png" style="width:30%"/>
 
<img src="/assets/images/tutorials/14/hrm-main-layer-measurement.png" style="width:30%"/>

At the end of the measurement process it displays an appropriate message, the content of which depends on the average value of the heart rate and the value of the heart rate limit.

<img src="/assets/images/tutorials/14/hrm-main-layer-finished-1.png" style="width:30%"/>
 
<img src="/assets/images/tutorials/14/hrm-main-layer-finished-2.png" style="width:30%"/>
 
<img src="/assets/images/tutorials/14/hrm-main-layer-finished-3.png" style="width:30%"/>

## 2. Importing and building solution

In this step, we will import and build Visual Studio solution containing initial application code.

Step 1: Download and unpack [heart-rate-monitor.zip](https://s3-us-west-1.amazonaws.com/tizenschool/14/heart-rate-monitor.zip) file.

Step 2: Click File > Open > Project/Solution...

<img src="/assets/images/tutorials/14/hrm-import-1.png" style="height:832px; width:1250px"/>

Step 3: Go to downloaded directory and select HeartRateMonitor.sln file (Microsoft Visual Studio Solution), then click the "Open" button.

<img src="/assets/images/tutorials/14/hrm-import-2.png" style="height:832px; width:1250px"/>

The solution structure should appear in the Solution Explorer view. It should contain two projects: HeartRateMonitor and HeartRateMonitor.Tizen.Mobile.

<img src="/assets/images/tutorials/14/hrm-import-3.png" style="height:832px; width:1250px"/>

Step 4: Right-click on the solution and select "Restore NuGet Packages" from the context menu. This will set up NuGet packages for all projects.

<img src="/assets/images/tutorials/14/hrm-import-4.png" style="height:832px; width:1250px"/>

Step 5: Right-click on the solution again and select "Clean Solution" from the context menu.

<img src="/assets/images/tutorials/14/hrm-import-5.png" style="height:832px; width:1250px"/>

Step 6: Right-click on the solution again and select "Rebuild Solution" from the context menu.

<img src="/assets/images/tutorials/14/hrm-import-6.png" style="height:832px; width:1250px"/>

Step 7: Right-click on the "HeartRateMonitor.Tizen.Mobile" project and select "Set as StartUp Project" from the context menu.

<img src="/assets/images/tutorials/14/hrm-import-7.png" style="height:832px; width:1250px"/>

Right now the application can be run on the emulator or target device. We will start with the base version of the application. The application displays the **Measurement page** with the **Welcome layer** visible. The **Get started** button does nothing. But don't worry, we will implement these things in the next steps.

<img src="/assets/images/tutorials/14/hrm-welcome-layer.png" style="width:30%"/>

# II. DISPLAYING MAIN LAYER ON THE MEASUREMENT PAGE

## 1. Goal

The goal of this tutorial's part is to display the **Main layer** of the **Measurement page** . The base version of the application provides complete UI layout of this layer.

<img src="/assets/images/tutorials/14/hrm-main-layer-ready-code-step-2.png" style="width:30%"/>

The layer called **Main layer** consists of several areas:

At this stage, mentioned layer parts do nothing.

So, let's begin.

## 2. PageNavigation class implementation

We have to implement **PageNavigation** class. It provides commands that allow navigation through the application pages. At this stage we will not use its commands. Fully implemented PageNavigation class is needed during application view model initialization (described in the next chapter).

We will modify the HeartRateMonitor/Navigation/PageNavigation.cs file of the project.

Step 1: Create constructor of the PageNavigation class with implementation of its two public commands.

<highlight>3-19</highlight>

```csharp
#region methods

/// <summary>
/// PageNavigation class constructor.
/// </summary>
/// <param name="navigation"></param>
public PageNavigation(INavigation navigation)
{
    NavigateToCommand = new Command<Type>(async (Type pageType) =>
    {
        Page page = (Page)Activator.CreateInstance(pageType);
        await navigation.PushAsync(page, false);
    });

    NavigateBackCommand = new Command(async () =>
    {
        await navigation.PopAsync();
    });
}

#endregion

```

## 3. Initializing view model

We have to create an instance of the application view model (HeartRateMonitor/ViewModels/MainViewModel.cs class). This class provides an abstraction of the view exposing public properties and commands.

We will modify the HeartRateMonitor/HeartRateMonitor.cs file of the project.

Step 1: Create instance of the **MainViewModel** class inside the **App** class constructor.

<highlight>6-9</highlight>

```csharp
/// <summary>
/// App class constructor.
/// </summary>
public App()
{
    MeasurementPage appMeasurementPage = new MeasurementPage();
    AppMainViewModel = new MainViewModel(Properties, new PageNavigation(appMeasurementPage.Navigation));

    MainPage = new NavigationPage(appMeasurementPage)
    {
        BarBackgroundColor = ColorConstants.BASE_APP_COLOR
    };
}

```

## 4. Extending the view model

We have to provide **IsStarted** property in the view model, indicating whether the **Get started** button on the **Welcome layer** has been pressed or not.

We will modify the HeartRateMonitor/ViewModels/MainViewModel.cs file of the project.

Step 1: Create private field for IsStarted property.

<highlight>3-6</highlight>

```csharp
#region fields

/// <summary>
/// Flag indicating whether the application is in started state.
/// </summary>
private bool _isStarted = false;

#endregion

```

Step 2: Create public IsStarted property.

<highlight>3-10</highlight>

```csharp
public ICommand UpdateHeartRateLimitCommand { private set; get; }

/// <summary>
/// Property indicating whether the application is in started state.
/// </summary>
public bool IsStarted
{
    set { SetProperty(ref _isStarted, value); }
    get { return _isStarted; }
}

#endregion

```

Step 3: Modify ExecuteGetStartedCommand method as shown below.

<highlight>7</highlight>

```csharp
/// <summary>
/// Executes the GetStartedCommand command.
/// Updates value of the IsStarted property.
/// </summary>
private void ExecuteGetStartedCommand()
{
    IsStarted = true;
}

```

## 5. Extending the view

We will modify the HeartRateMonitor/Views/MeasurementPage.xaml file of the project.

The modified file should allow the application to display the **Main layer** when the **IsStarted** property of the view model is set to **true** .

Step 1: Bind NavigationPage.HasNavigationBar property of the ContentPage element to the IsStarted property of the view model.

It will allow the application to display the **Navigation bar** when the **IsStarted** property is set to **true** .

<highlight>9</highlight>

```xml
<ContentPage xmlns="http://xamarin.com/schemas/2014/forms"
             xmlns:x="http://schemas.microsoft.com/winfx/2009/xaml"
             xmlns:constants="clr-namespace:HeartRateMonitor.Constants"
             xmlns:views="clr-namespace:HeartRateMonitor.Views"
             x:Class="HeartRateMonitor.Views.MeasurementPage"
             Title="Heart Rate Monitor"
             BindingContext="{Binding Source={x:Static Application.Current}, Path=AppMainViewModel}"
             NavigationPage.HasBackButton="False"
             NavigationPage.HasNavigationBar="{Binding IsStarted}">

```

Step 2: Add data trigger to the container responsible for displaying the Main layer.

It will allow the application to make the **Main layer** visible when the **IsStarted** property is set to **true** .

<highlight>6-13</highlight>

```xml
<!-- Main layout -->
<AbsoluteLayout AbsoluteLayout.LayoutBounds="0, 0, 1, 1"
                AbsoluteLayout.LayoutFlags="All"
                IsVisible="False">

    <AbsoluteLayout.Triggers>
        <DataTrigger Binding="{Binding IsStarted, StringFormat='{0}'}"
                     TargetType="AbsoluteLayout"
                     Value="True">
            <Setter Property="IsVisible"
                    Value="True" />
        </DataTrigger>
    </AbsoluteLayout.Triggers>

    <!-- Message area -->
    <AbsoluteLayout AbsoluteLayout.LayoutBounds="0, 0, 720, 320">

```

Step 3: Add data trigger to the container responsible for displaying the Welcome layer.

It will allow the application to make the **Welcome layer** hidden when the **IsStarted** property is set to **true** .

<highlight>5-12</highlight>

```xml
<!-- Welcome layout -->
<AbsoluteLayout AbsoluteLayout.LayoutBounds="0, 0, 1, 1"
                AbsoluteLayout.LayoutFlags="All">

    <AbsoluteLayout.Triggers>
        <DataTrigger Binding="{Binding IsStarted, StringFormat='{0}'}"
                     TargetType="AbsoluteLayout"
                     Value="True">
            <Setter Property="IsVisible"
                    Value="False" />
        </DataTrigger>
    </AbsoluteLayout.Triggers>

    <Image AbsoluteLayout.LayoutBounds="0, 0, 1, 1"
           AbsoluteLayout.LayoutFlags="All"
           Source="bg_heart.png"
           Aspect="AspectFill"/>

```

Step 4: Add data trigger to the Get started button.

It will allow the application to make the **Get started** button disabled when the **IsStarted** property is set to **true** .

<highlight>7-16</highlight>

```xml
    <StackLayout AbsoluteLayout.LayoutBounds="0, 1, 720, AutoSize"
                 AbsoluteLayout.LayoutFlags="PositionProportional"
                 Padding="112, 0, 112, 34">
        <Button BackgroundColor="{x:Static constants:ColorConstants.BUTTON_TEXT_COLOR}"
                Command="{Binding GetStartedCommand}"
                Text="Get started"
                TextColor="{x:Static constants:ColorConstants.BASE_APP_COLOR}">
            <Button.Triggers>
                <DataTrigger Binding="{Binding IsStarted, StringFormat='{0}'}"
                             TargetType="Button"
                             Value="True">
                    <Setter Property="IsEnabled"
                            Value="False" />
                </DataTrigger>
            </Button.Triggers>
        </Button>
    </StackLayout>
</AbsoluteLayout>

```

Right now the application can be run on the emulator or target device. After pressing the **Get started** button, the **Main layer** of the **Measurement page** should be shown.

<img src="/assets/images/tutorials/14/hrm-main-layer-ready-code-step-2.png" style="width:30%"/>

# III. SETTING HEART RATE LIMIT VALUE USING SETTINGS PAGE

## 1. Goal

The goal of this tutorial's part is to allow the application to display the **Settings page** in order to update the default value of the heart rate limit.

Below you can see the **Main layer** of the **Measurement page** displaying the default value of the heart rate limit (180 bpm), as well as the **Settings page** layout before limit update.

<img src="/assets/images/tutorials/14/hrm-main-layer-ready.png" style="width:30%"/>
 
<img src="/assets/images/tutorials/14/hrm-settings-page-code-step-3-1.png" style="width:30%"/>

The **Settings page** defines **Navigation bar** with **Back arrow** which allows the user to navigate back to the **Measurement page** without any changes made.

It also defines a slider element which allows the user to set the new value of the heart rate limit. The value of the limit is displayed by the label above the slider.

To save or cancel changes made on this page, the user can press one of the buttons located in the footer ( **Cancel** or **Done** ). The **Cancel** button navigates back to the **Measurement page** without changes. The **Done** button saves changes before page changing.

At this stage, the **Settings page** is fully functional and ready to update the value of the heart rate limit.

So, let's begin.

## 2. The limit view model properties

We have to provide three properties ( **HeartRateLimitSliderValue** , **HeartRateLimitIndicatorLayoutBounds** and **HeartRateLimitValue** ) in the view model that are responsible for indicating the heart rate limit slider on the **Measurement page** .

We will modify the HeartRateMonitor/ViewModels/MainViewModel.cs file of the project.

Step 1: Create private fields for HeartRateLimitSliderValue, HeartRateLimitIndicatorLayoutBounds and HeartRateLimitValue properties.

<highlight>8-21</highlight>

```csharp
#region fields

/// <summary>
/// Flag indicating whether the application is in started state.
/// </summary>
private bool _isStarted = false;

/// <summary>
/// Number representing heart rate limit value.
/// </summary>
private int _heartRateLimitValue;

/// <summary>
/// Number representing heart rate limit slider value.
/// </summary>
private double _heartRateLimitSliderValue;

/// <summary>
/// Rectangle object representing heart rate limit indicator position.
/// </summary>
private Rectangle _heartRateLimitIndicatorLayoutBounds = new Rectangle(0, 0, 50, 60);

#endregion

```

Step 2: Create public HeartRateLimitSliderValue, HeartRateLimitIndicatorLayoutBounds and HeartRateLimitValue properties.

<highlight>10-35</highlight>

```csharp
/// <summary>
/// Property indicating whether the application is in started state.
/// </summary>
public bool IsStarted
{
    set { SetProperty(ref _isStarted, value); }
    get { return _isStarted; }
}

/// <summary>
/// Property with value representing heart rate limit value.
/// </summary>
public int HeartRateLimitValue
{
    set { SetProperty(ref _heartRateLimitValue, value); }
    get { return _heartRateLimitValue; }
}

/// <summary>
/// Property with value representing heart rate limit slider value.
/// </summary>
public double HeartRateLimitSliderValue
{
    set { SetProperty(ref _heartRateLimitSliderValue, value); }
    get { return _heartRateLimitSliderValue; }
}

/// <summary>
/// Property with value representing heart rate limit indicator position.
/// </summary>
public Rectangle HeartRateLimitIndicatorLayoutBounds
{
    set { SetProperty(ref _heartRateLimitIndicatorLayoutBounds, value); }
    get { return _heartRateLimitIndicatorLayoutBounds; }
}

#endregion

```

## 3. The limit initial value

We have to restore values of **HeartRateLimitSliderValue** , **HeartRateLimitIndicatorLayoutBounds** and **HeartRateLimitValue** properties in the view model. It should happen when the **Main layer** of the **Measurement page** becomes visible (when the **IsStarted** property is set).

We will modify the HeartRateMonitor/ViewModels/MainViewModel.cs file of the project.

Step 1: Create private constant fields that are used to calculate values of properties.

<highlight>6-20</highlight>

```csharp
/// <summary>
/// Rectangle object representing heart rate limit indicator position.
/// </summary>
private Rectangle _heartRateLimitIndicatorLayoutBounds = new Rectangle(0, 0, 50, 60);

/// <summary>
/// Number representing the maximum value of the heart rate that can be provided by Tizen Sensor API.
/// </summary>
private const int MAX_APP_HEART_RATE_VALUE = 220;

/// <summary>
/// Number representing default value of the heart rate limit.
/// </summary>
private const int HEART_RATE_DEFAULT_LIMIT_VALUE = 180;

/// <summary>
/// String representing a key that is used by application's properties dictionary
/// to save current heart rate limit value.
/// </summary>
private const string HEART_RATE_LIMIT_KEY = "heartRateLimit";

#endregion

```

Step 2: Create private variable for reference to the IDictionary object that will be used to store some application data.

<highlight>7-11</highlight>

```csharp
/// <summary>
/// String representing a key that is used by application's properties dictionary
/// to save current heart rate limit value.
/// </summary>
private const string HEART_RATE_LIMIT_KEY = "heartRateLimit";

/// <summary>
/// Reference to the IDictionary object that is used to store some data,
/// so that they are available the next time the applications runs.
/// </summary>
private IDictionary<string, object> _properties;

#endregion

```

Step 3: Initialize the \_properties variable in the class constructor.

<highlight>8</highlight>

```csharp
/// <summary>
/// MainViewModel class constructor.
/// </summary>
/// <param name="properties"></param>
/// <param name="pageMavigation"></param>
public MainViewModel(IDictionary<string, object> properties, PageNavigation pageMavigation)
{
    _properties = properties;

    GetStartedCommand = new Command(ExecuteGetStartedCommand);
    ToggleMeasurementCommand = new Command(ExecuteToggleMeasurementCommand);
    ShowSettingsCommand = new Command(ExecuteShowSettingsCommand, CanExecuteShowSettingsCommand);
    UpdateHeartRateLimitCommand = new Command(ExecuteUpdateHeartRateLimitCommand);
}

```

Step 4: Implement private RestoreHeartRateLimitSliderValue method.

<highlight>12-27</highlight>

```csharp
/// <summary>
/// Executes the ToggleMeasurementCommand command.
/// Depending on the IsMeasuring property state, it starts or stops the measurement process.
/// Additionally, it calls ChangeCanExecute method
/// to update the execution state of the ShowSettingsCommand command.
/// </summary>
private void ExecuteToggleMeasurementCommand()
{

}

/// <summary>
/// Restores heart rate limit slider value.
/// It tries to obtain this value from application properties dictionary.
/// If it is not available in the dictionary, the value is calculated based on app constants.
/// </summary>
private void RestoreHeartRateLimitSliderValue()
{
    if (_properties.ContainsKey(HEART_RATE_LIMIT_KEY))
    {
        HeartRateLimitSliderValue = (double)_properties[HEART_RATE_LIMIT_KEY];
    }
    else
    {
        HeartRateLimitSliderValue = (double)HEART_RATE_DEFAULT_LIMIT_VALUE / MAX_APP_HEART_RATE_VALUE;
    }
}

#endregion

```

Step 5: Execute the RestoreHeartRateLimitSliderValue method when the IsStarted property is set.

<highlight>6-10</highlight>

```csharp
/// <summary>
/// Property indicating whether the application is in started state.
/// </summary>
public bool IsStarted
{
    set
    {
        SetProperty(ref _isStarted, value);
        RestoreHeartRateLimitSliderValue();
    }
    get { return _isStarted; }
}

```

Step 6: Update the HeartRateLimitValue property when the value of the HeartRateLimitSliderValue is set.

<highlight>6-10</highlight>

```csharp
/// <summary>
/// Property with value representing heart rate limit slider value.
/// </summary>
public double HeartRateLimitSliderValue
{
    set
    {
        SetProperty(ref _heartRateLimitSliderValue, value);
        HeartRateLimitValue = (int)(value * MAX_APP_HEART_RATE_VALUE);
    }
    get { return _heartRateLimitSliderValue; }
}

```

Step 7: Implement private UpdateHeartRateLimitIndicatorPosition method.

<highlight>16-24</highlight>

```csharp
/// <summary>
/// MainViewModel class constructor.
/// </summary>
/// <param name="properties"></param>
/// <param name="pageMavigation"></param>
public MainViewModel(IDictionary<string, object> properties, PageNavigation pageMavigation)
{
    _properties = properties;

    GetStartedCommand = new Command(ExecuteGetStartedCommand);
    ToggleMeasurementCommand = new Command(ExecuteToggleMeasurementCommand);
    ShowSettingsCommand = new Command(ExecuteShowSettingsCommand, CanExecuteShowSettingsCommand);
    UpdateHeartRateLimitCommand = new Command(ExecuteUpdateHeartRateLimitCommand);
}

/// <summary>
/// Updates value of the HeartRateLimitIndicatorLayoutBounds property.
/// </summary>
/// <param name="value"></param>
private void UpdateHeartRateLimitIndicatorPosition(double value)
{
    HeartRateLimitIndicatorLayoutBounds = new Rectangle(value, _heartRateLimitIndicatorLayoutBounds.Top,
        _heartRateLimitIndicatorLayoutBounds.Width, _heartRateLimitIndicatorLayoutBounds.Height);
}

/// <summary>
/// Executes UpdateHeartRateLimitCommand command.
/// Updates value of the HeartRateLimitSliderValue property.
/// Navigates back to the measurement page by executing NavigateBackCommand command
/// of the PageNavigation class.
/// </summary>
private void ExecuteUpdateHeartRateLimitCommand()
{

}

```

Step 8: Execute the UpdateHeartRateLimitIndicatorPosition method when the value of the HeartRateLimitSliderValue is set.

<highlight>9</highlight>

```csharp
/// <summary>
/// Property with value representing heart rate limit slider value.
/// </summary>
public double HeartRateLimitSliderValue
{
    set
    {
        SetProperty(ref _heartRateLimitSliderValue, value);
        UpdateHeartRateLimitIndicatorPosition(value);
        HeartRateLimitValue = (int)(value * MAX_APP_HEART_RATE_VALUE);
    }
    get { return _heartRateLimitSliderValue; }
}

```

## 4. The limit appearance

We have to bind values of UI elements responsible for the appearance of the heart rate limit slider to **HeartRateLimitIndicatorLayoutBounds** and **HeartRateLimitValue** properties of the view model.

We will modify the HeartRateMonitor/Views/MeasurementPage.xaml file of the project.

Step 1: Add bindings to **HeartRateLimitIndicatorLayoutBounds** and **HeartRateLimitValue** properties of the view model.

<highlight>20, 27</highlight>

```xml
<!-- Progress area -->
<AbsoluteLayout AbsoluteLayout.LayoutBounds="0, 683, 720, 275">
    <StackLayout AbsoluteLayout.LayoutBounds=".5, 0, AutoSize, 137"
                 AbsoluteLayout.LayoutFlags="PositionProportional"
                 Orientation="Horizontal"
                 Spacing="0">
        <Label Style="{StaticResource HeartRateValueDisabledText}"
               Text="0" />
        <Label Style="{StaticResource HeartRateValueDisabledText}"
               Text="0" />
        <Label Style="{StaticResource HeartRateValueDisabledText}"
               Text="0" />
    </StackLayout>
    <Label AbsoluteLayout.LayoutBounds="450, 64, AutoSize, AutoSize"
           Style="{StaticResource HeartRateValueUnitText}"
           Text="bpm" />
    <AbsoluteLayout AbsoluteLayout.LayoutBounds="87, 126, 546, 60">
        <ProgressBar AbsoluteLayout.LayoutBounds="25, 14, 496, 8"
                     Progress="0" />
        <AbsoluteLayout AbsoluteLayout.LayoutBounds="{Binding HeartRateLimitIndicatorLayoutBounds}"
                        AbsoluteLayout.LayoutFlags="PositionProportional">
            <BoxView AbsoluteLayout.LayoutBounds="22, 5, 6, 26"
                     BackgroundColor="Black" />
            <Label AbsoluteLayout.LayoutBounds=".5, 1, AutoSize, AutoSize"
                   AbsoluteLayout.LayoutFlags="PositionProportional"
                   Style="{StaticResource HeartRateLimitLabel}"
                   Text="{Binding HeartRateLimitValue}" />
        </AbsoluteLayout>
    </AbsoluteLayout>
</AbsoluteLayout>

```

Right now the application can be run on the emulator or target device. After pressing the **Get started** button, the **Main layer** of the **Measurement page** should be shown. Pay attention to the position of the heart rate limit indicator and the value of its label. It indicates 180 bpm (default value of the heart rate limit).

<img src="/assets/images/tutorials/14/hrm-main-layer-ready.png" style="width:30%"/>

## 5. Showing settings

We have to create **HeartRateLimitBufferValue** and **HeartRateLimitSliderBufferValue** properties of the view model that are responsible for storing heart rate limit values for UI elements on the **Settings page** . We also have to implement **ShowSettingsCommand** command, which will be executed when the settings icon on the **Measurement page** is pressed. To navigate to the **Settings page** , we will use **NavigateToCommand** command of the **PageNavigation** class.

We will modify the HeartRateMonitor/ViewModels/MainViewModel.cs file of the project.

Step 1: Create AppPageNavigation property for storing an instance of the PageNavigation class.

<highlight>3-6</highlight>

```csharp
#region properties

/// <summary>
/// An instance of PageNavigation class.
/// </summary>
public PageNavigation AppPageNavigation { private set; get; }

/// <summary>
/// Sets a property of the view model indicating that the application is in started state.
/// </summary>
public ICommand GetStartedCommand { private set; get; }

```

Step 2: Initialize the AppPageNavigation property in the class constructor.

<highlight>9</highlight>

```csharp
/// <summary>
/// MainViewModel class constructor.
/// </summary>
/// <param name="properties"></param>
/// <param name="pageMavigation"></param>
public MainViewModel(IDictionary<string, object> properties, PageNavigation pageMavigation)
{
    _properties = properties;
    AppPageNavigation = pageMavigation;

    GetStartedCommand = new Command(ExecuteGetStartedCommand);
    ToggleMeasurementCommand = new Command(ExecuteToggleMeasurementCommand);
    ShowSettingsCommand = new Command(ExecuteShowSettingsCommand, CanExecuteShowSettingsCommand);
    UpdateHeartRateLimitCommand = new Command(ExecuteUpdateHeartRateLimitCommand);
}

```

Step 3: Create private fields for HeartRateLimitBufferValue and HeartRateLimitSliderBufferValue properties.

<highlight>6-9, 16-19</highlight>

```csharp
/// <summary>
/// Number representing heart rate limit value.
/// </summary>
private int _heartRateLimitValue;

/// <summary>
/// Number representing temporary buffered heart rate limit value.
/// </summary>
private int _heartRateLimitBufferValue;

/// <summary>
/// Number representing heart rate limit slider value.
/// </summary>
private double _heartRateLimitSliderValue;

/// <summary>
/// Number representing temporary buffered heart rate limit slider value.
/// </summary>
private double _heartRateLimitSliderBufferValue;

```

Step 4: Create public HeartRateLimitBufferValue and HeartRateLimitSliderBufferValue properties.

<highlight>10-17, 33-40</highlight>

```csharp
/// <summary>
/// Property with value representing heart rate limit value.
/// </summary>
public int HeartRateLimitValue
{
    set { SetProperty(ref _heartRateLimitValue, value); }
    get { return _heartRateLimitValue; }
}

/// <summary>
/// Property with value representing temporary buffered heart rate limit value.
/// </summary>
public int HeartRateLimitBufferValue
{
    set { SetProperty(ref _heartRateLimitBufferValue, value); }
    get { return _heartRateLimitBufferValue; }
}

/// <summary>
/// Property with value representing heart rate limit slider value.
/// </summary>
public double HeartRateLimitSliderValue
{
    set
    {
        SetProperty(ref _heartRateLimitSliderValue, value);
        UpdateHeartRateLimitIndicatorPosition(value);
        HeartRateLimitValue = (int)(value * MAX_APP_HEART_RATE_VALUE);
    }
    get { return _heartRateLimitSliderValue; }
}

/// <summary>
/// Property with value representing temporary buffered heart rate limit slider value.
/// </summary>
public double HeartRateLimitSliderBufferValue
{
    set { SetProperty(ref _heartRateLimitSliderBufferValue, value); }
    get { return _heartRateLimitSliderBufferValue; }
}

```

Step 5: Update value of the HeartRateLimitBufferValue property when the HeartRateLimitSliderBufferValue property is set.

<highlight>6-10</highlight>

```csharp
/// <summary>
/// Property with value representing temporary buffered heart rate limit slider value.
/// </summary>
public double HeartRateLimitSliderBufferValue
{
    set
    {
        SetProperty(ref _heartRateLimitSliderBufferValue, value);
        HeartRateLimitBufferValue = (int)(value * MAX_APP_HEART_RATE_VALUE);
    }
    get { return _heartRateLimitSliderBufferValue; }
}

```

Step 6: Implement the ShowSettingsCommand command.

<highlight>10-11</highlight>

```csharp
/// <summary>
/// Executes the ShowSettingsCommand command.
/// Updates value of the HeartRateLimitSliderBufferValue property.
/// Navigates to the settings page by executing NavigateToCommand command
/// of the PageNavigation class.
/// </summary>
/// <param name="obj"></param>
private void ExecuteShowSettingsCommand(object obj)
{
    HeartRateLimitSliderBufferValue = HeartRateLimitSliderValue;
    AppPageNavigation.NavigateToCommand.Execute(obj);
}

```

Step 7: Update CanExecuteShowSettingsCommand method to allow the ShowSettingsCommand command to be executed.

<highlight>8</highlight>

```csharp
/// <summary>
/// Checks whether the ShowSettingsCommand command can be executed.
/// </summary>
/// <param name="arg"></param>
/// <returns>Returns true if the ShowSettingsCommand can be executed, false otherwise.</returns>
private bool CanExecuteShowSettingsCommand(object arg)
{
    return true;
}

```

## 6. The settings slider appearance

We have to bind values of UI elements responsible for the appearance of the settings slider to **HeartRateLimitBufferValue** and **HeartRateLimitSliderBufferValue** properties of the view model.

We will modify the HeartRateMonitor/Views/SettingsPage.xaml file of the project.

Step 1: Add bindings to **HeartRateLimitBufferValue** and **HeartRateLimitSliderBufferValue** properties of the view model.

<highlight>8, 10</highlight>

```xml
<!-- Slider area -->
<AbsoluteLayout AbsoluteLayout.LayoutBounds="0, 0, 720, 320">
    <Label AbsoluteLayout.LayoutBounds="0, 76, 720, 58"
           Style="{StaticResource BaseLabel}"
           Text="Set heart rate limit:" />
    <Label AbsoluteLayout.LayoutBounds="0, 166, 720, 48"
           Style="{StaticResource MessageMainLabel}"
           Text="{Binding HeartRateLimitBufferValue}" />
    <Slider AbsoluteLayout.LayoutBounds="112, 225, 496, 64"
            Value="{Binding HeartRateLimitSliderBufferValue}" />
</AbsoluteLayout>

```

Right now the application can be run on the emulator or target device. After pressing the **Get started** button, the **Main layer** of the **Measurement page** should be shown. When you press the **Settings icon** in the **Navigation bar** the application should display the **Settings page** , which is shown below. Pay attention to the position of the slider and the value of its label. It indicates 180 bpm (default value of the heart rate limit).

<img src="/assets/images/tutorials/14/hrm-settings-page-code-step-3-6.png" style="width:30%"/>

When you change the slider position, the value of the label updates automatically. At this stage the application does not save the changed value of the heart rate limit. It will be implemented in the next chapter.

## 7. Saving settings

We have to implement **UpdateHeartRateLimitCommand** command of the view model. This command is executed when **Done** button on the **Settings page** is pressed.

We also have to update the application properties dictionary, to be sure that the changed limit value is available after the application restart.

We will modify the HeartRateMonitor/ViewModels/MainViewModel.cs and HeartRateMonitor/HeartRateMonitor.cs project files.

Step 1: Implement the ExecuteUpdateHeartRateLimitCommand method of the MainViewModel class

<highlight>9-10</highlight>

```csharp
/// <summary>
/// Executes UpdateHeartRateLimitCommand command.
/// Updates value of the HeartRateLimitSliderValue property.
/// Navigates back to the measurement page by executing NavigateBackCommand command
/// of the PageNavigation class.
/// </summary>
private void ExecuteUpdateHeartRateLimitCommand()
{
    HeartRateLimitSliderValue = HeartRateLimitSliderBufferValue;
    AppPageNavigation.NavigateBackCommand.Execute(null);
}

```

Step 2: Update properties dictionary when the HeartRateLimitSliderValue property is set.

<highlight>9</highlight>

```csharp
/// <summary>
/// Property with value representing heart rate limit slider value.
/// </summary>
public double HeartRateLimitSliderValue
{
    set
    {
        SetProperty(ref _heartRateLimitSliderValue, value);
        _properties[HEART_RATE_LIMIT_KEY] = value;
        UpdateHeartRateLimitIndicatorPosition(value);
        HeartRateLimitValue = (int)(value * MAX_APP_HEART_RATE_VALUE);
    }
    get { return _heartRateLimitSliderValue; }
}

```

Right now the application can be run on the emulator or target device. Go to the **Settings page** , modify the slider position and press the **Done** button. The application should display the **Measurement page** with the updated value of the heart rate limit.

<img src="/assets/images/tutorials/14/hrm-settings-page-code-step-3-7.png" style="width:30%"/>
 
<img src="/assets/images/tutorials/14/hrm-measurement-page-code-step-3-7.png" style="width:30%"/>

## 8. Canceling changes

We have to define a command for the **Cancel** button on the **Settings page** , which will use the **NavigateBackCommand** method of the **PageNavigation** class to navigate back to the **Measurement page** without any additional action.

We will modify the HeartRateMonitor/Views/SettingsPage.xaml file of the project.

Step 1: Define command parameter for the Cancel button

<highlight>7-8</highlight>

```xml
<!-- Footer button area -->
<StackLayout AbsoluteLayout.LayoutBounds="0, 1, 720, AutoSize"
             AbsoluteLayout.LayoutFlags="PositionProportional"
             Orientation="Horizontal"
             Padding="32, 0, 32, 34"
             Spacing="32">
    <Button Command="{Binding AppPageNavigation.NavigateBackCommand}"
            Text="Cancel" />
    <Button Command="{Binding UpdateHeartRateLimitCommand}"
            Text="Done" />
</StackLayout>

```

Right now the application can be run on the emulator or target device. Go to the **Settings page** , modify the slider position and press the **Cancel** button. The application should display the **Measurement page** without the updated value of the heart rate limit.

<img src="/assets/images/tutorials/14/hrm-settings-page-code-step-3-8.png" style="width:30%"/>
 
<img src="/assets/images/tutorials/14/hrm-measurement-page-code-step-3-8.png" style="width:30%"/>

# IV. IMPLEMENTING THE MEASUREMENT PROCESS

## 1. Goal

The goal of this tutorial's part is to add functionality to the measurement process.

For this purpose we have to implement the functionality of:

Below you can see the sequence of application screens during the measurement process we want to achieve at the end of this chapter.

<img src="/assets/images/tutorials/14/hrm-measurement-page-code-step-4-1-ready.png" style="width:30%"/>
 
<img src="/assets/images/tutorials/14/hrm-measurement-page-code-step-4-1-measuring.png" style="width:30%"/>
 
<img src="/assets/images/tutorials/14/hrm-measurement-page-code-step-4-1-finished.png" style="width:30%"/>

## 2. Starting the countdown

We have to implement **ToggleMeasurementCommand** command which is executed every time the **Start measurement** button is pressed. This command will call **StartMeasurement** and **StopMeasurement** methods alternately, allowing the application to start and stop the measurement process. By default (without the **StopMeasurement** method call) the measurement process is stopped automatically after 12 seconds.

We will modify the HeartRateMonitor/ViewModels/MainViewModel.cs file of the project.

Step 1: Create private fields for IsMeasuring and IsMeasuring properties, which allows the application to recognize whether the measurement process is in progress or has finished.

<highlight>6-14</highlight>

```csharp
/// <summary>
/// Flag indicating whether the application is in started state.
/// </summary>
private bool _isStarted = false;

/// <summary>
/// Flag indicating whether the measurement process is in progress.
/// </summary>
private bool _isMeasuring = false;

/// <summary>
/// Flag indicating whether the measurement process is finished.
/// </summary>
private bool _isFinished = false;

/// <summary>
/// Number representing heart rate limit value.
/// </summary>
private int _heartRateLimitValue;

```

Step 2: Create public IsMeasuring and IsFinished properties.

<highlight>6-22</highlight>

```csharp
/// <summary>
/// Updates view model properties responsible for UI representation of heart rate limit.
/// </summary>
public ICommand UpdateHeartRateLimitCommand { private set; get; }

/// <summary>
/// Property indicating whether the measurement process is in progress.
/// </summary>
public bool IsMeasuring
{
    set { SetProperty(ref _isMeasuring, value); }
    get { return _isMeasuring; }
}

/// <summary>
/// Property indicating whether the measurement process is finished.
/// </summary>
public bool IsFinished
{
    set { SetProperty(ref _isFinished, value); }
    get { return _isFinished; }
}

/// <summary>
/// Property indicating whether the application is in started state.
/// </summary>
public bool IsStarted
{
    set
    {
        SetProperty(ref _isStarted, value);
        RestoreHeartRateLimitSliderValue();
    }
    get { return _isStarted; }
}

```

Step 3: Create private \_measurementLock field, which allows to decide whether the application should try to automatically stop the measurement process after 12 seconds from the start.

<highlight>6-11</highlight>

```csharp
/// <summary>
/// Flag indicating whether the measurement process is finished.
/// </summary>
private bool _isFinished = false;

/// <summary>
/// Number indicating whether the measurement process can be stopped automatically or not.
/// If the value is equal to zero, the measurement process can be stopped automatically.
/// Otherwise not.
/// </summary>
private int _measurementLock = 0;

/// <summary>
/// Number representing heart rate limit value.
/// </summary>
private int _heartRateLimitValue;

```

Step 4: Create private constant MEASUREMENT_TIME field which stores information about the measurement process duration.

<highlight>6-9</highlight>

```csharp
/// <summary>
/// Number representing default value of the heart rate limit.
/// </summary>
private const int HEART_RATE_DEFAULT_LIMIT_VALUE = 180;

/// <summary>
/// Number representing measurement time.
/// </summary>
private const int MEASUREMENT_TIME = 12;

/// <summary>
/// String representing a key that is used by application's properties dictionary
/// to save the current heart rate limit value.
/// </summary>
private const string HEART_RATE_LIMIT_KEY = "heartRateLimit";

```

Step 5: Create private field for MeasurementCountdown property. It will store a value representing countdown progress.

<highlight>8-11</highlight>

```csharp
/// <summary>
/// Number indicating whether the measurement process can be stopped automatically or not.
/// If the value is equal to zero, the measurement process can be stopped automatically.
/// Otherwise not.
/// </summary>
private int _measurementLock = 0;

/// <summary>
/// String representing the value of measurement countdown.
/// </summary>
private string _measurementCountdown;

/// <summary>
/// Number representing heart rate limit value.
/// </summary>
private int _heartRateLimitValue;

```

Step 6: Create public MeasurementCountdown property.

<highlight>14-24</highlight>

```csharp
/// <summary>
/// Property indicating whether the application is in started state.
/// </summary>
public bool IsStarted
{
    set
    {
        SetProperty(ref _isStarted, value);
        RestoreHeartRateLimitSliderValue();
    }
    get { return _isStarted; }
}

/// <summary>
/// Property with value representing measurement countdown.
/// </summary>
public string MeasurementCountdown
{
    set { SetProperty(ref _measurementCountdown, value); }
    get
    {
        return "(" + _measurementCountdown + " sec.)";
    }
}

/// <summary>
/// Property with value representing heart rate limit value.
/// </summary>
public int HeartRateLimitValue
{
    set { SetProperty(ref _heartRateLimitValue, value); }
    get { return _heartRateLimitValue; }
}

```

Step 7: Create private \_measurementStartTimestamp field which will represent the starting time point of the measurement process.

<highlight>6-9</highlight>

```csharp
/// <summary>
/// String representing the value of measurement countdown.
/// </summary>
private string _measurementCountdown;

/// <summary>
/// DateTime object representing the starting time point of the measurement process.
/// </summary>
private DateTime _measurementStartTimestamp;

/// <summary>
/// Number representing heart rate limit value.
/// </summary>
private int _heartRateLimitValue;

```

Step 8: Implement StopMeasurement method responsible for stopping the measurement process.

<highlight>12-30</highlight>

```csharp
/// <summary>
/// Executes the ToggleMeasurementCommand command.
/// Depending on the IsMeasuring property state, it starts or stops the measurement process.
/// Additionally, it calls ChangeCanExecute method
/// to update execution state of the ShowSettingsCommand command.
/// </summary>
private void ExecuteToggleMeasurementCommand()
{

}

/// <summary>
/// Stops measurement process.
/// Sets values of properties responsible for indicating that the measurement process is finished.
/// Invokes "MeasurementFinished" event.
/// Executes the StopHeartRateMonitor method of the HeartRateMonitorModel object.
/// Updates value of the CurrentHeartRate property by using GetAverageHeartRateValue method.
/// </summary>
/// <param name="canceled"></param>
private void StopMeasurement(bool canceled = false)
{
    IsMeasuring = false;

    if (canceled)
    {
        return;
    }

    IsFinished = true;
}

/// <summary>
/// Restores heart rate limit slider value.
/// It tries to obtain this value from application properties dictionary.
/// If it is not available in the dictionary, the value is calculated based on app constants.
/// </summary>
private void RestoreHeartRateLimitSliderValue()
{
    if (_properties.ContainsKey(HEART_RATE_LIMIT_KEY))
    {
        HeartRateLimitSliderValue = (double)_properties[HEART_RATE_LIMIT_KEY];
    }
    else
    {
        HeartRateLimitSliderValue = (double)HEART_RATE_DEFAULT_LIMIT_VALUE / MAX_APP_HEART_RATE_VALUE;
    }
}

```

Step 9: Implement StartMeasurement method responsible for starting the measurement process.

<highlight>20-61</highlight>

```csharp
/// <summary>
/// Executes the ToggleMeasurementCommand command.
/// Depending on the IsMeasuring property state, it starts or stops the measurement process.
/// Additionally, it calls ChangeCanExecute method
/// to update execution state of the ShowSettingsCommand command.
/// </summary>
private void ExecuteToggleMeasurementCommand()
{

}

/// <summary>
/// Starts the measurement process.
/// Sets values of fields and properties
/// responsible for the correct course of the measurement process.
/// Invokes "MeasurementStarted" event.
/// Sets timer to let the application know
/// when the measurement process should be stopped automatically.
/// Executes the StartHeartRateMonitor method of the HeartRateMonitorModel object.
/// </summary>
private void StartMeasurement()
{
    IsFinished = false;
    IsMeasuring = true;
    MeasurementCountdown = MEASUREMENT_TIME.ToString();
    _measurementStartTimestamp = DateTime.Now;
    Device.StartTimer(TimeSpan.FromSeconds(MEASUREMENT_TIME), () =>
    {
        if (IsMeasuring && _measurementLock == 0)
        {
            StopMeasurement();
        }

        if (_measurementLock > 0)
        {
            _measurementLock -= 1;
        }

        return false;
    });

    Device.StartTimer(TimeSpan.FromSeconds(1), () =>
    {
        if (!IsMeasuring)
        {
            return false;
        }

        TimeSpan measurementElapsedTime = DateTime.Now - _measurementStartTimestamp;
        MeasurementCountdown = (MEASUREMENT_TIME - measurementElapsedTime.Seconds).ToString();
        return true;
    });
}

/// <summary>
/// Stops measurement process.
/// Sets values of properties responsible for indicating that the measurement process is finished.
/// Invokes "MeasurementFinished" event.
/// Executes the StopHeartRateMonitor method of the HeartRateMonitorModel object.
/// Updates value of the CurrentHeartRate property by using GetAverageHeartRateValue method.
/// </summary>
/// <param name="canceled"></param>
private void StopMeasurement(bool canceled = false)
{
    IsMeasuring = false;

    if (canceled)
    {
        return;
    }

    IsFinished = true;
}

```

Step 10: Implement ToggleMeasurementCommand command.

<highlight>9-17</highlight>

```csharp
/// <summary>
/// Executes the ToggleMeasurementCommand command.
/// Depending on the IsMeasuring property state, it starts or stops the measurement process.
/// Additionally, it calls ChangeCanExecute method
/// to update the execution state of the ShowSettingsCommand command.
/// </summary>
private void ExecuteToggleMeasurementCommand()
{
    if (IsMeasuring)
    {
        StopMeasurement(true);
        _measurementLock += 1;
    }
    else
    {
        StartMeasurement();
    }
}

```

## 3. Toggling Start measurement button state

We have to create **DataTrigger** of the **Start measurement** button to update its label when it is toggled.

We will modify the HeartRateMonitor/Views/MeasurementPage.xaml file of the project.

Step 1: Create **DataTrigger** of the **Start measurement** button.

<highlight>8-17</highlight>

```xml
<!-- Footer button area -->
<StackLayout AbsoluteLayout.LayoutBounds="0, 1, 720, AutoSize"
             AbsoluteLayout.LayoutFlags="PositionProportional"
             Padding="112, 0, 112, 34">
    <Button BackgroundColor="{x:Static constants:ColorConstants.BASE_APP_COLOR}"
            Command="{Binding ToggleMeasurementCommand}"
            Text="Start measurement"
            TextColor="{x:Static constants:ColorConstants.BUTTON_TEXT_COLOR}">
        <Button.Triggers>
            <DataTrigger Binding="{Binding IsMeasuring, StringFormat='{0}'}"
                         TargetType="Button"
                         Value="True">
                <Setter Property="Text"
                        Value="Cancel measurement" />
            </DataTrigger>
        </Button.Triggers>
    </Button>
</StackLayout>

```

Right now the application can be run on the emulator or target device. Go to the **Main layer** of the **Measurement page** and press the **Start measurement** button. The label of the button should display **Cancel measurement** text. After 12 seconds the label should be changed back to the **Start measurement** text.

<img src="/assets/images/tutorials/14/hrm-measurement-page-start-measurement-code-step-4-3.png" style="width:30%"/>
 
<img src="/assets/images/tutorials/14/hrm-measurement-page-cancel-measurement-code-step-4-3.png" style="width:30%"/>

## 4. Displaying the countdown

We have to bind the **MeasurementCountdown** property of the view model to the application UI.

We will modify the HeartRateMonitor/Views/MeasurementPage.xaml file of the project.

Step 1: Create binding to the **MeasurementCountdown** view model property.

<highlight>11</highlight>

```xml
<!-- Message area -->
<AbsoluteLayout AbsoluteLayout.LayoutBounds="0, 0, 720, 320">
    <StackLayout AbsoluteLayout.LayoutBounds="0, 76, 720, 58">
        <StackLayout Orientation="Horizontal"
                     Spacing="0"
                     HorizontalOptions="CenterAndExpand">
            <Label Style="{StaticResource TitleMainLabel}"
                   Text="{x:Static constants:MessageConstants.READY_TITLE}" />
            <Label IsVisible="False"
                   Style="{StaticResource TitleMainLabel}"
                   Text="{Binding MeasurementCountdown}" />
        </StackLayout>
    </StackLayout>
    <Label AbsoluteLayout.LayoutBounds="0, 158, 720, 96"
           Style="{StaticResource MessageMainLabel}"
           Text="{x:Static constants:MessageConstants.READY_CONTENT}" />
</AbsoluteLayout>

```

Step 2: Add DataTrigger to show countdown only during measurement.

<highlight>11-20</highlight>

```xml
<!-- Message area -->
<AbsoluteLayout AbsoluteLayout.LayoutBounds="0, 0, 720, 320">
    <StackLayout AbsoluteLayout.LayoutBounds="0, 76, 720, 58">
        <StackLayout Orientation="Horizontal"
                     Spacing="0"
                     HorizontalOptions="CenterAndExpand">
            <Label Style="{StaticResource TitleMainLabel}"
                   Text="{x:Static constants:MessageConstants.READY_TITLE}" />
            <Label IsVisible="False"
                   Style="{StaticResource TitleMainLabel}"
                   Text="{Binding MeasurementCountdown}">
                <Label.Triggers>
                    <DataTrigger Binding="{Binding IsMeasuring, StringFormat='{0}'}"
                                 TargetType="Label"
                                 Value="True">
                        <Setter Property="IsVisible"
                                Value="True" />
                    </DataTrigger>
                </Label.Triggers>
            </Label>
        </StackLayout>
    </StackLayout>
    <Label AbsoluteLayout.LayoutBounds="0, 158, 720, 96"
           Style="{StaticResource MessageMainLabel}"
           Text="{x:Static constants:MessageConstants.READY_CONTENT}" />
</AbsoluteLayout>

```

## 5. Updating message

We have to create **DataTriggers** to update message title and content at each stage of the measurement process.

We will modify the HeartRateMonitor/Views/MeasurementPage.xaml file of the project.

Step 1: Create **DataTriggers** responsible for updating the message title.

<highlight>8-23</highlight>

```xml
<!-- Message area -->
<AbsoluteLayout AbsoluteLayout.LayoutBounds="0, 0, 720, 320">
    <StackLayout AbsoluteLayout.LayoutBounds="0, 76, 720, 58">
        <StackLayout Orientation="Horizontal"
                     Spacing="0"
                     HorizontalOptions="CenterAndExpand">
            <Label Style="{StaticResource TitleMainLabel}"
                   Text="{x:Static constants:MessageConstants.READY_TITLE}">
                <Label.Triggers>
                    <DataTrigger Binding="{Binding IsMeasuring, StringFormat='{0}'}"
                                 TargetType="Label"
                                 Value="True">
                        <Setter Property="Text"
                                Value="{x:Static constants:MessageConstants.MEASURING_TITLE}" />
                    </DataTrigger>
                    <DataTrigger Binding="{Binding IsFinished, StringFormat='{0}'}"
                                 TargetType="Label"
                                 Value="True">
                        <Setter Property="Text"
                                Value="{x:Static constants:MessageConstants.FINISHED_TITLE}" />
                    </DataTrigger>
                </Label.Triggers>
            </Label>
            <Label IsVisible="False"
                   Style="{StaticResource TitleMainLabel}"
                   Text="{Binding MeasurementCountdown}">
                <Label.Triggers>
                    <DataTrigger Binding="{Binding IsMeasuring, StringFormat='{0}'}"
                                 TargetType="Label"
                                 Value="True">
                        <Setter Property="IsVisible"
                                Value="True" />
                    </DataTrigger>
                </Label.Triggers>
            </Label>
        </StackLayout>
    </StackLayout>
    <Label AbsoluteLayout.LayoutBounds="0, 158, 720, 96"
           Style="{StaticResource MessageMainLabel}"
           Text="{x:Static constants:MessageConstants.READY_CONTENT}" />
</AbsoluteLayout>

```

Step 2: Create **DataTriggers** responsible for updating the message content.

<highlight>40-55</highlight>

```xml
<!-- Message area -->
<AbsoluteLayout AbsoluteLayout.LayoutBounds="0, 0, 720, 320">
    <StackLayout AbsoluteLayout.LayoutBounds="0, 76, 720, 58">
        <StackLayout Orientation="Horizontal"
                     Spacing="0"
                     HorizontalOptions="CenterAndExpand">
            <Label Style="{StaticResource TitleMainLabel}"
                   Text="{x:Static constants:MessageConstants.READY_TITLE}">
                <Label.Triggers>
                    <DataTrigger Binding="{Binding IsMeasuring, StringFormat='{0}'}"
                                 TargetType="Label"
                                 Value="True">
                        <Setter Property="Text"
                                Value="{x:Static constants:MessageConstants.MEASURING_TITLE}" />
                    </DataTrigger>
                    <DataTrigger Binding="{Binding IsFinished, StringFormat='{0}'}"
                                 TargetType="Label"
                                 Value="True">
                        <Setter Property="Text"
                                Value="{x:Static constants:MessageConstants.FINISHED_TITLE}" />
                    </DataTrigger>
                </Label.Triggers>
            </Label>
            <Label IsVisible="False"
                   Style="{StaticResource TitleMainLabel}"
                   Text="{Binding MeasurementCountdown}">
                <Label.Triggers>
                    <DataTrigger Binding="{Binding IsMeasuring, StringFormat='{0}'}"
                                 TargetType="Label"
                                 Value="True">
                        <Setter Property="IsVisible"
                                Value="True" />
                    </DataTrigger>
                </Label.Triggers>
            </Label>
        </StackLayout>
    </StackLayout>
    <Label AbsoluteLayout.LayoutBounds="0, 158, 720, 96"
           Style="{StaticResource MessageMainLabel}"
           Text="{x:Static constants:MessageConstants.READY_CONTENT}">
        <Label.Triggers>
            <DataTrigger Binding="{Binding IsMeasuring, StringFormat='{0}'}"
                         TargetType="Label"
                         Value="True">
                <Setter Property="Text"
                        Value="{x:Static constants:MessageConstants.MEASURING_CONTENT}" />
            </DataTrigger>
            <DataTrigger Binding="{Binding IsFinished, StringFormat='{0}'}"
                         TargetType="Label"
                         Value="True">
                <Setter Property="Text"
                        Value="{x:Static constants:MessageConstants.FINISHED_CONTENT_WITHIN_LIMIT}" />
            </DataTrigger>
        </Label.Triggers>
    </Label>
</AbsoluteLayout>

```

Right now the application can be run on the emulator or target device. Go to the **Main layer** of the **Measurement page** and press the **Start measurement** button. The message title and content should indicate that the measurement process is in progress. After 12 seconds the message should inform that the measurement is finished.

<img src="/assets/images/tutorials/14/hrm-measurement-page-code-step-4-5-ready.png" style="width:30%"/>
 
<img src="/assets/images/tutorials/14/hrm-measurement-page-code-step-4-5-measuring.png" style="width:30%"/>
 
<img src="/assets/images/tutorials/14/hrm-measurement-page-code-step-4-5-finished.png" style="width:30%"/>

## 6. Implementing heart rate monitor service

We have to implement **HeartRateMonitorService** class which allows the application to obtain heart rate value using the Tizen Sensor API.

We will modify the HeartRateMonitor.Tizen.Mobile/Services/HeartRateMonitorService.cs file of the project.

Step 1: Create private \_hrm field which will store an instance of the HeartRateMonitor class provided by the Tizen Sensor API.

<highlight>3-6</highlight>

```csharp
#region fields

/// <summary>
/// An instance of the HeartRateMonitor class provided by the Tizen Sensor API.
/// </summary>
private HRM _hrm;

#endregion

```

Step 2: Create private \_currentHeartRate field which will store the value representing the heart rate obtained using the Tizen Sensor API.

<highlight>6-9</highlight>

```csharp
/// <summary>
/// An instance of the HeartRateMonitor class provided by the Tizen Sensor API.
/// </summary>
private HRM _hrm;

/// <summary>
/// Number representing the value of the current heart rate.
/// </summary>
private int _currentHeartRate;

#endregion

```

Step 3: Create private OnDataUpdated handler method which will be executed each time DataUpdated event provided by the Tizen Sensot API occurs. It saves the current value of the heart rate and invokes HeartRateMonitorDataChanged event.

<highlight>9-20</highlight>

```csharp
/// <summary>
/// Stops notification about the changes of the heart rate value.
/// </summary>
public void StopHeartRateMonitor()
{

}

/// <summary>
/// Handles "DataUpdated" event of the HeartRateMonitor object provided by the Tizen Sensor API.
/// Saves the current heart rate value in the _currentHeartRate field.
/// Invokes "HeartRateMonitorDataChanged" event.
/// </summary>
/// <param name="sender"></param>
/// <param name="e"></param>
private void OnDataUpdated(object sender, HeartRateMonitorDataUpdatedEventArgs e)
{
    _currentHeartRate = e.HeartRate;
    HeartRateMonitorDataChanged?.Invoke(this, new EventArgs());
}

#endregion

```

Step 4: Implement public Init method which initializes the service.

<highlight>6-9</highlight>

```csharp
/// <summary>
/// Initializes HeartRateMonitorService class.
/// </summary>
public void Init()
{
    _hrm = new HRM();

    _hrm.Interval = 1000;
    _hrm.DataUpdated += OnDataUpdated;
}

```

Step 5: Implement public StartHeartRateMonitor, which starts notification (with DataUpdated events) about the changes of the heart rate value.

<highlight>6</highlight>

```csharp
/// <summary>
/// Starts notification about the changes of the heart rate value.
/// </summary>
public void StartHeartRateMonitor()
{
    _hrm.Start();
}

```

Step 6: Implement public StopHeartRateMonitor which stops notification about the changes of the heart rate value.

<highlight>6</highlight>

```csharp
/// <summary>
/// Stops notification about the changes of the heart rate value.
/// </summary>
public void StopHeartRateMonitor()
{
    _hrm.Stop();
}

```

Step 7: Implement public GetHeartRate method which returns the current heart rate value provided by the Tizen Sensor API.

<highlight>7</highlight>

```csharp
/// <summary>
/// Returns the current heart rate value provided by the Tizen Sensor API.
/// </summary>
/// <returns>Current heart rate value provided by the Tizen Sensor API.</returns>
public int GetHeartRate()
{
    return _currentHeartRate;
}

```

## 7. Obtaining heart rate value

We have to create the **HeartRateMonitorDataChanged** event handler and create **CurrentHeartRate** property. This property must be updated each time the **HeartRateMonitorDataChanged** event is handled.

We will modify the HeartRateMonitor/ViewModels/MainViewModel.cs file of the project.

Step 1: Create private \_currentHeartRate field for CurrentHeartRate property, which allows the application to store the value of the current heart rate.

<highlight>6-9</highlight>

```csharp
/// <summary>
/// DateTime object representing the starting time point of the measurement process.
/// </summary>
private DateTime _measurementStartTimestamp;

/// <summary>
/// Number representing the current heart rate value.
/// </summary>
private int _currentHeartRate = 0;

/// <summary>
/// Number representing heart rate limit value.
/// </summary>
private int _heartRateLimitValue;

```

Step 2: Create public CurrentHeartRate property.

<highlight>13-20</highlight>

```csharp
/// <summary>
/// Property with value representing measurement countdown.
/// </summary>
public string MeasurementCountdown
{
    set { SetProperty(ref _measurementCountdown, value); }
    get
    {
        return "(" + _measurementCountdown + " sec.)";
    }
}

/// <summary>
/// Property with value representing current heart rate.
/// </summary>
public int CurrentHeartRate
{
    set { SetProperty(ref _currentHeartRate, value); }
    get { return _currentHeartRate; }
}

/// <summary>
/// Property with value representing heart rate limit value.
/// </summary>
public int HeartRateLimitValue
{
    set { SetProperty(ref _heartRateLimitValue, value); }
    get { return _heartRateLimitValue; }
}

```

Step 3: Create private \_heartRateMonitorModel field being a reference to the instance of the HeartRateMonitorModel class.

<highlight>7-10</highlight>

```csharp
/// <summary>
/// String representing a key that is used by application's properties dictionary
/// to save the current heart rate limit value.
/// </summary>
private const string HEART_RATE_LIMIT_KEY = "heartRateLimit";

/// <summary>
/// Reference to the object of the HeartRateMonitorModel class.
/// </summary>
private HeartRateMonitorModel _heartRateMonitorModel;

/// <summary>
/// Reference to the IDictionary object that is used to store some data,
/// so that they are available the next time the applications runs.
/// </summary>
private IDictionary<string, object> _properties;

```

Step 4: Create an instance of the HeartRateMonitorModel class.

<highlight>8</highlight>

```csharp
/// <summary>
/// MainViewModel class constructor.
/// </summary>
/// <param name="properties"></param>
/// <param name="pageMavigation"></param>
public MainViewModel(IDictionary<string, object> properties, PageNavigation pageMavigation)
{
    _heartRateMonitorModel = new HeartRateMonitorModel();
    _properties = properties;
    AppPageNavigation = pageMavigation;

    GetStartedCommand = new Command(ExecuteGetStartedCommand);
    ToggleMeasurementCommand = new Command(ExecuteToggleMeasurementCommand);
    ShowSettingsCommand = new Command(ExecuteShowSettingsCommand, CanExecuteShowSettingsCommand);
    UpdateHeartRateLimitCommand = new Command(ExecuteUpdateHeartRateLimitCommand);
}

```

Step 5: Create handler method which will be executed each time the HeartRateMonitorDataChanged event is invoked.

<highlight>11-22</highlight>

```csharp
/// <summary>
/// Updates the value of the HeartRateLimitIndicatorLayoutBounds property.
/// </summary>
/// <param name="value"></param>
private void UpdateHeartRateLimitIndicatorPosition(double value)
{
    HeartRateLimitIndicatorLayoutBounds = new Rectangle(value, _heartRateLimitIndicatorLayoutBounds.Top,
        _heartRateLimitIndicatorLayoutBounds.Width, _heartRateLimitIndicatorLayoutBounds.Height);
}

/// <summary>
/// Handles "HeartRateMonitorDataChanged" event of the HeartRateMonitorModel object.
/// Updates the value of the MeasurementCountdown property.
/// Updates the value of the CurrentHeartRate property.
/// Adds a new value to the list of measurement values.
/// </summary>
/// <param name="sender"></param>
/// <param name="e"></param>
private void ModelOnHeartRateMonitorDataChanged(object sender, EventArgs e)
{
    CurrentHeartRate = _heartRateMonitorModel.GetHeartRate();
}

/// <summary>
/// Executes UpdateHeartRateLimitCommand command.
/// Updates the value of the HeartRateLimitSliderValue property.
/// Navigates back to the measurement page by executing NavigateBackCommand command
/// of the PageNavigation class.
/// </summary>
private void ExecuteUpdateHeartRateLimitCommand()
{
    HeartRateLimitSliderValue = HeartRateLimitSliderBufferValue;
    AppPageNavigation.NavigateBackCommand.Execute(null);
}

```

Step 6: Add the ModelOnHeartRateMonitorDataChanged handler to the HeartRateMonitorDataChanged event of the HeartRateMonitorModel class.

<highlight>16</highlight>

```csharp
/// <summary>
/// MainViewModel class constructor.
/// </summary>
/// <param name="properties"></param>
/// <param name="pageMavigation"></param>
public MainViewModel(IDictionary<string, object> properties, PageNavigation pageMavigation)
{
    _properties = properties;
    AppPageNavigation = pageMavigation;

    GetStartedCommand = new Command(ExecuteGetStartedCommand);
    ToggleMeasurementCommand = new Command(ExecuteToggleMeasurementCommand);
    ShowSettingsCommand = new Command(ExecuteShowSettingsCommand, CanExecuteShowSettingsCommand);
    UpdateHeartRateLimitCommand = new Command(ExecuteUpdateHeartRateLimitCommand);

    _heartRateMonitorModel.HeartRateMonitorDataChanged += ModelOnHeartRateMonitorDataChanged;
}

```

Step 7: Execute StartHeartRateMonitor method of the HeartRateMonitorModel class inside the StartMeasurement method.

<highlight>43</highlight>

```csharp
/// <summary>
/// Starts measurement process.
/// Sets the values of fields and properties
/// responsible for the correct flow of the measurement process.
/// Invokes "MeasurementStarted" event.
/// Sets timer to let the application know
/// when the measurement process should be stopped automatically.
/// Executes the StartHeartRateMonitor method of the HeartRateMonitorModel object.
/// </summary>
private void StartMeasurement()
{
    IsFinished = false;
    IsMeasuring = true;
    MeasurementCountdown = MEASUREMENT_TIME.ToString();
    _measurementStartTimestamp = DateTime.Now;
    Device.StartTimer(TimeSpan.FromSeconds(MEASUREMENT_TIME), () =>
    {
        if (IsMeasuring && _measurementLock == 0)
        {
            StopMeasurement();
        }

        if (_measurementLock > 0)
        {
            _measurementLock -= 1;
        }

        return false;
    });

    Device.StartTimer(TimeSpan.FromSeconds(1), () =>
    {
        if (!IsMeasuring)
        {
            return false;
        }

        TimeSpan measurementElapsedTime = DateTime.Now - _measurementStartTimestamp;
        MeasurementCountdown = (MEASUREMENT_TIME - measurementElapsedTime.Seconds).ToString();
        return true;
    });

    _heartRateMonitorModel.StartHeartRateMonitor();
}

```

Step 8: Execute StopHeartRateMonitor method of the HeartRateMonitorModel class inside the StopMeasurement method.

<highlight>12</highlight>

```csharp
/// <summary>
/// Stops the measurement process.
/// Sets the values of properties responsible for indicating that the measurement process is finished.
/// Invokes "MeasurementFinished" event.
/// Executes the StopHeartRateMonitor method of the HeartRateMonitorModel object.
/// Updates the value of the CurrentHeartRate property by using GetAverageHeartRateValue method.
/// </summary>
/// <param name="canceled"></param>
private void StopMeasurement(bool canceled = false)
{
    IsMeasuring = false;
    _heartRateMonitorModel.StopHeartRateMonitor();

    if (canceled)
    {
        return;
    }

    IsFinished = true;
}

```

Step 9: Reset the CurrentHeartRate value when the measurement process is stopped using Cancel measurement button.

<highlight>16</highlight>

```csharp
/// <summary>
/// Stops the measurement process.
/// Sets the values of properties responsible for indicating that the measurement process is finished.
/// Invokes "MeasurementFinished" event.
/// Executes the StopHeartRateMonitor method of the HeartRateMonitorModel object.
/// Updates the value of the CurrentHeartRate property by using GetAverageHeartRateValue method.
/// </summary>
/// <param name="canceled"></param>
private void StopMeasurement(bool canceled = false)
{
    IsMeasuring = false;
    _heartRateMonitorModel.StopHeartRateMonitor();

    if (canceled)
    {
        CurrentHeartRate = 0;
        return;
    }

    IsFinished = true;
}

```

## 8. Preparing digits of the heart rate value

We have to create **CurrentHeartRateFirstNumber** , **CurrentHeartRateSecondNumber** and **CurrentHeartRateThirdNumber** properties, which will represent the digits of the heart rate value. These properties should be updated each time the **CurrentHeartRate** property changes.

We will modify the HeartRateMonitor/ViewModels/MainViewModel.cs file of the project.

Step 1: Create private fields for CurrentHeartRateFirstNumber, CurrentHeartRateSecondNumber and CurrentHeartRateThirdNumber properties.

<highlight>6-19</highlight>

```csharp
/// <summary>
/// Number representing the current heart rate value.
/// </summary>
private int _currentHeartRate = 0;

/// <summary>
/// Number representing the value of the first digit of the heart rate value.
/// </summary>
private int _currentHeartRateFirstNumber = 0;

/// <summary>
/// Number representing the value of the second digit of the heart rate value.
/// </summary>
private int _currentHeartRateSecondNumber = 0;

/// <summary>
/// Number representing the value of the third digit of the heart rate value.
/// </summary>
private int _currentHeartRateThirdNumber = 0;

/// <summary>
/// Number representing heart rate limit value.
/// </summary>
private int _heartRateLimitValue;

```

Step 2: Create public CurrentHeartRateFirstNumber, CurrentHeartRateSecondNumber and CurrentHeartRateThirdNumber properties.

<highlight>10-35</highlight>

```csharp
/// <summary>
/// Property with value representing heart rate limit indicator position.
/// </summary>
public Rectangle HeartRateLimitIndicatorLayoutBounds
{
    set { SetProperty(ref _heartRateLimitIndicatorLayoutBounds, value); }
    get { return _heartRateLimitIndicatorLayoutBounds; }
}

/// <summary>
/// Property representing the value of the first digit of the heart rate value.
/// </summary>
public int CurrentHeartRateFirstNumber
{
    set { SetProperty(ref _currentHeartRateFirstNumber, value); }
    get { return _currentHeartRateFirstNumber; }
}

/// <summary>
/// Property representing the value of the second digit of the heart rate value.
/// </summary>
public int CurrentHeartRateSecondNumber
{
    set { SetProperty(ref _currentHeartRateSecondNumber, value); }
    get { return _currentHeartRateSecondNumber; }
}

/// <summary>
/// Property representing the value of the third digit of the heart rate value.
/// </summary>
public int CurrentHeartRateThirdNumber
{
    set { SetProperty(ref _currentHeartRateThirdNumber, value); }
    get { return _currentHeartRateThirdNumber; }
}

#endregion

```

Step 3: Create private constant variable containing the maximum value of the heart rate that can be displayed on the application screen.

<highlight>6-9</highlight>

```csharp
/// <summary>
/// Rectangle object representing heart rate limit indicator position.
/// </summary>
private Rectangle _heartRateLimitIndicatorLayoutBounds = new Rectangle(0, 0, 50, 60);

/// <summary>
/// Number representing the maximum value of the heart rate that can be displayed on the application screen.
/// </summary>
private const int MAX_HEART_RATE_VALUE = 999;

/// <summary>
/// Number representing the maximum value of the heart rate that can be provided by Tizen Sensor API.
/// </summary>
private const int MAX_APP_HEART_RATE_VALUE = 220;

```

Step 4: Create private SetHeartRateNumbersValues method extracting digits of the current heart rate value.

<highlight>11-36</highlight>

```csharp
/// <summary>
/// Updates the value of the HeartRateLimitIndicatorLayoutBounds property.
/// </summary>
/// <param name="value"></param>
private void UpdateHeartRateLimitIndicatorPosition(double value)
{
    HeartRateLimitIndicatorLayoutBounds = new Rectangle(value, _heartRateLimitIndicatorLayoutBounds.Top,
        _heartRateLimitIndicatorLayoutBounds.Width, _heartRateLimitIndicatorLayoutBounds.Height);
}

/// <summary>
/// Updates the values of the CurrentHeartRateFirstNumber, CurrentHeartRateSecondNumber
/// and CurrentHeartRateThirdNumber properties.
/// </summary>
/// <param name="value"></param>
private void SetHeartRateNumbersValues(int value)
{
    if (value > MAX_HEART_RATE_VALUE)
    {
        return;
    }

    int[] listOfDigits = new int[] { 0, 0, 0 };
    int position = 2;

    while (value > 0)
    {
        listOfDigits[position] = value % 10;
        value = value / 10;
        position -= 1;
    }

    CurrentHeartRateThirdNumber = listOfDigits[2];
    CurrentHeartRateSecondNumber = listOfDigits[1];
    CurrentHeartRateFirstNumber = listOfDigits[0];
}

/// <summary>
/// Handles "HeartRateMonitorDataChanged" event of the HeartRateMonitorModel object.
/// Updates the value of the MeasurementCountdown property.
/// Updates the value of the CurrentHeartRate property.
/// Adds a new value to the list of measurement values.
/// </summary>
/// <param name="sender"></param>
/// <param name="e"></param>
private void ModelOnHeartRateMonitorDataChanged(object sender, EventArgs e)
{
    CurrentHeartRate = _heartRateMonitorModel.GetHeartRate();
}

```

Step 5: Execute the SetHeartRateNumbersValues method when the CurrentHeartRate property is set.

<highlight>6-10</highlight>

```csharp
/// <summary>
/// Property with value representing current heart rate.
/// </summary>
public int CurrentHeartRate
{
    set
    {
        SetProperty(ref _currentHeartRate, value);
        SetHeartRateNumbersValues(value);
    }
    get { return _currentHeartRate; }
}

```

## 9. Displaying the heart rate value

We have to bind **CurrentHeartRateFirstNumber** , **CurrentHeartRateSecondNumber** and **CurrentHeartRateThirdNumber** properties to the application UI.

We will modify the HeartRateMonitor/Views/MeasurementPage.xaml file of the project.

Step 1: Bind CurrentHeartRateFirstNumber, CurrentHeartRateSecondNumber and CurrentHeartRateThirdNumber properties to the Text property of the appropriate Labels.

<highlight>8, 10, 12</highlight>

```xml
<!-- Progress area -->
<AbsoluteLayout AbsoluteLayout.LayoutBounds="0, 683, 720, 275">
    <StackLayout AbsoluteLayout.LayoutBounds=".5, 0, AutoSize, 137"
                 AbsoluteLayout.LayoutFlags="PositionProportional"
                 Orientation="Horizontal"
                 Spacing="0">
        <Label Style="{StaticResource HeartRateValueDisabledText}"
               Text="{Binding CurrentHeartRateFirstNumber}" />
        <Label Style="{StaticResource HeartRateValueDisabledText}"
               Text="{Binding CurrentHeartRateSecondNumber}" />
        <Label Style="{StaticResource HeartRateValueDisabledText}"
               Text="{Binding CurrentHeartRateThirdNumber}" />
    </StackLayout>

```

Step 2: Create MultiTriggers allowing the application to highlight only important digits of the heart rate value.

<highlight>8-19, 21-34, 36-51</highlight>

```xml
<!-- Progress area -->
<AbsoluteLayout AbsoluteLayout.LayoutBounds="0, 683, 720, 275">
    <StackLayout AbsoluteLayout.LayoutBounds=".5, 0, AutoSize, 137"
                 AbsoluteLayout.LayoutFlags="PositionProportional"
                 Orientation="Horizontal"
                 Spacing="0">
        <Label Style="{StaticResource HeartRateValueText}"
               Text="{Binding CurrentHeartRateFirstNumber}">
            <Label.Triggers>
                <MultiTrigger TargetType="Label">
                    <MultiTrigger.Conditions>
                        <BindingCondition Binding="{Binding CurrentHeartRateFirstNumber, StringFormat='{0}'}"
                                          Value="0" />
                    </MultiTrigger.Conditions>
                    <Setter Property="Style"
                            Value="{StaticResource HeartRateValueDisabledText}" />
                </MultiTrigger>
            </Label.Triggers>
        </Label>
        <Label Style="{StaticResource HeartRateValueText}"
               Text="{Binding CurrentHeartRateSecondNumber}">
            <Label.Triggers>
                <MultiTrigger TargetType="Label">
                    <MultiTrigger.Conditions>
                        <BindingCondition Binding="{Binding CurrentHeartRateFirstNumber, StringFormat='{0}'}"
                                          Value="0" />
                        <BindingCondition Binding="{Binding CurrentHeartRateSecondNumber, StringFormat='{0}'}"
                                          Value="0" />
                    </MultiTrigger.Conditions>
                    <Setter Property="Style"
                            Value="{StaticResource HeartRateValueDisabledText}" />
                </MultiTrigger>
            </Label.Triggers>
        </Label>
        <Label Style="{StaticResource HeartRateValueText}"
               Text="{Binding CurrentHeartRateThirdNumber}">
            <Label.Triggers>
                <MultiTrigger TargetType="Label">
                    <MultiTrigger.Conditions>
                        <BindingCondition Binding="{Binding CurrentHeartRateFirstNumber, StringFormat='{0}'}"
                                          Value="0" />
                        <BindingCondition Binding="{Binding CurrentHeartRateSecondNumber, StringFormat='{0}'}"
                                          Value="0" />
                        <BindingCondition Binding="{Binding CurrentHeartRateThirdNumber, StringFormat='{0}'}"
                                          Value="0" />
                    </MultiTrigger.Conditions>
                    <Setter Property="Style"
                            Value="{StaticResource HeartRateValueDisabledText}" />
                </MultiTrigger>
            </Label.Triggers>
       </Label>
    </StackLayout>

```

Right now the application can be run on the emulator or target device. Go to the **Main layer** of the **Measurement page** and press the **Start measurement** button. The obtained value of the heart rate should be displayed during the measurement process and after it is finished.

<img src="/assets/images/tutorials/14/hrm-measurement-page-code-step-4-9-ready.png" style="width:30%"/>
 
<img src="/assets/images/tutorials/14/hrm-measurement-page-code-step-4-9-measuring.png" style="width:30%"/>
 
<img src="/assets/images/tutorials/14/hrm-measurement-page-code-step-4-9-finished.png" style="width:30%"/>

## 10. Preparing the heart rate progress value

We have to create **HeartRateProgress** property, which will store the value of the progress representing the heart rate value. This property should be updated each time the **CurrentHeartRate** property changes.

We will modify the HeartRateMonitor/ViewModels/MainViewModel.cs file of the project.

Step 1: Create private field for HeartRateProgress property.

<highlight>6-9</highlight>

```csharp
/// <summary>
/// Number representing the value of the third digit of the heart rate value.
/// </summary>
private int _currentHeartRateThirdNumber = 0;

/// <summary>
/// Number representing current heart rate progress bar value.
/// </summary>
private double _heartRateProgress;

/// <summary>
/// Number representing heart rate limit value.
/// </summary>
private int _heartRateLimitValue;

```

Step 2: Create public HeartRateProgress property.

<highlight>14-21</highlight>

```csharp
/// <summary>
/// Property with value representing current heart rate.
/// </summary>
public int CurrentHeartRate
{
    set
    {
        SetProperty(ref _currentHeartRate, value);
        SetHeartRateNumbersValues(value);
    }
    get { return _currentHeartRate; }
}

/// <summary>
/// Property with value representing current heart rate progress bar value.
/// </summary>
public double HeartRateProgress
{
    set { SetProperty(ref _heartRateProgress, value); }
    get { return _heartRateProgress; }
}

/// <summary>
/// Property with value representing heart rate limit value.
/// </summary>
public int HeartRateLimitValue
{
    set { SetProperty(ref _heartRateLimitValue, value); }
    get { return _heartRateLimitValue; }
}

```

Step 3: Create private SetHeartRateProgress method updating the value of the heart rate progress.

<highlight>20-27</highlight>

```csharp
/// <summary>
/// MainViewModel class constructor.
/// </summary>
/// <param name="properties"></param>
/// <param name="pageMavigation"></param>
public MainViewModel(IDictionary<string, object> properties, PageNavigation pageMavigation)
{
    _heartRateMonitorModel = new HeartRateMonitorModel();
    _properties = properties;
    AppPageNavigation = pageMavigation;

    GetStartedCommand = new Command(ExecuteGetStartedCommand);
    ToggleMeasurementCommand = new Command(ExecuteToggleMeasurementCommand);
    ShowSettingsCommand = new Command(ExecuteShowSettingsCommand, CanExecuteShowSettingsCommand);
    UpdateHeartRateLimitCommand = new Command(ExecuteUpdateHeartRateLimitCommand);

    _heartRateMonitorModel.HeartRateMonitorDataChanged += ModelOnHeartRateMonitorDataChanged;
}

/// <summary>
/// Updates the value of the HeartRateProgress property.
/// </summary>
/// <param name="value"></param>
private void SetHeartRateProgress(int value)
{
    HeartRateProgress = (double)value / MAX_APP_HEART_RATE_VALUE;
}

/// <summary>
/// Updates the value of the HeartRateLimitIndicatorLayoutBounds property.
/// </summary>
/// <param name="value"></param>
private void UpdateHeartRateLimitIndicatorPosition(double value)
{
    HeartRateLimitIndicatorLayoutBounds = new Rectangle(value, _heartRateLimitIndicatorLayoutBounds.Top,
        _heartRateLimitIndicatorLayoutBounds.Width, _heartRateLimitIndicatorLayoutBounds.Height);
}

```

Step 4: Execute the SetHeartRateProgress method when the CurrentHeartRate property is set.

<highlight>10</highlight>

```csharp
/// <summary>
/// Property with value representing current heart rate.
/// </summary>
public int CurrentHeartRate
{
    set
    {
        SetProperty(ref _currentHeartRate, value);
        SetHeartRateNumbersValues(value);
        SetHeartRateProgress(value);
    }
    get { return _currentHeartRate; }
}

```

## 11. Displaying the heart rate progress value

We have to bind **HeartRateProgress** property to the application UI.

We will modify the HeartRateMonitor/Views/MeasurementPage.xaml file of the project.

Step 1: Bind HeartRateProgress property to the Progress property of the ProgressBar element.

<highlight>3</highlight>

```xml
    <AbsoluteLayout AbsoluteLayout.LayoutBounds="87, 126, 546, 60">
        <ProgressBar AbsoluteLayout.LayoutBounds="25, 14, 496, 8"
                     Progress="{Binding HeartRateProgress}" />
        <AbsoluteLayout AbsoluteLayout.LayoutBounds="{Binding HeartRateLimitIndicatorLayoutBounds}"
                        AbsoluteLayout.LayoutFlags="PositionProportional">
            <BoxView AbsoluteLayout.LayoutBounds="22, 5, 6, 26"
                     BackgroundColor="Black" />
            <Label AbsoluteLayout.LayoutBounds=".5, 1, AutoSize, AutoSize"
                   AbsoluteLayout.LayoutFlags="PositionProportional"
                   Style="{StaticResource HeartRateLimitLabel}"
                   Text="{Binding HeartRateLimitValue}" />
        </AbsoluteLayout>
    </AbsoluteLayout>
</AbsoluteLayout>

<!-- Footer button area -->

```

Right now the application can be run on the emulator or target device. Go to the **Main layer** of the **Measurement page** and press the **Start measurement** button. The obtained value of the heart rate should be reflected by the position of the progress bar during the measurement process and after it is finished.

<img src="/assets/images/tutorials/14/hrm-measurement-page-code-step-4-11-ready.png" style="width:30%"/>
 
<img src="/assets/images/tutorials/14/hrm-measurement-page-code-step-4-11-measuring.png" style="width:30%"/>
 
<img src="/assets/images/tutorials/14/hrm-measurement-page-code-step-4-11-finished.png" style="width:30%"/>

## 12. Preparing the heart rate ranges

We have to create **MeasurementResultRange** property, which will store the value representing the range to which the heart rate value is classified. This property should be updated each time the **CurrentHeartRate** or **HeartRateLimitSliderValue** property changes. It allows the application to display detailed message content at the end of the measurement process, which depends on the measured heart rate and the heart rate limit.

We will modify the HeartRateMonitor/ViewModels/MainViewModel.cs file of the project.

Step 1: Create private field for MeasurementResultRange property.

<highlight>8-15</highlight>

```csharp
/// <summary>
/// Number indicating whether the measurement process can be stopped automatically or not.
/// If the value is equal to zero, the measurement process can be stopped automatically.
/// Otherwise not.
/// </summary>
private int _measurementLock = 0;

/// <summary>
/// Number representing the range to which the heart rate value is classified,
/// when the measurement is finished.
/// If the value is equal to 1, the heart rate value is above the defined heart rate limit.
/// If the value is equal to 0, the heart rate value is within the defined heart rate limit.
/// If the value is equal to -1, the heart rate value is within the average resting rate.
/// </summary>
private int _measurementResultRange;

/// <summary>
/// String representing the value of measurement countdown.
/// </summary>
private string _measurementCountdown;

```

Step 2: Create public MeasurementResultRange property.

<highlight>10-18</highlight>

```csharp
/// <summary>
/// Property representing the value of the third digit of the heart rate value.
/// </summary>
public int CurrentHeartRateThirdNumber
{
    set { SetProperty(ref _currentHeartRateThirdNumber, value); }
    get { return _currentHeartRateThirdNumber; }
}

/// <summary>
/// Property representing the range to which the heart rate value is classified,
/// when the measurement is finished.
/// </summary>
public int MeasurementResultRange
{
    set { SetProperty(ref _measurementResultRange, value); }
    get { return _measurementResultRange; }
}

#endregion

```

Step 3: Create constant integers describing the lower and upper limits of the average resting rate.

<highlight>6-14</highlight>

```csharp
/// <summary>
/// Number representing the maximum value of the heart rate that can be provided by Tizen Sensor API.
/// </summary>
private const int MAX_APP_HEART_RATE_VALUE = 220;

/// <summary>
/// Number representing the lower limit of the average resting rate.
/// </summary>
private const int AVERAGE_HEART_RATE_VALUE_LOWER_LIMIT = 61;

/// <summary>
/// Number representing the upper limit of the average resting rate.
/// </summary>
private const int AVERAGE_HEART_RATE_VALUE_UPPER_LIMIT = 76;

/// <summary>
/// Number representing the default value of the heart rate limit.
/// </summary>
private const int HEART_RATE_DEFAULT_LIMIT_VALUE = 180;

```

Step 4: Create private UpdateMeasurementResultRange method updating the value of the MeasurementResultRange property.

<highlight>23-41</highlight>

```csharp
/// <summary>
/// Stops the measurement process.
/// Sets the values of properties responsible for indicating that the measurement process is finished.
/// Invokes "MeasurementFinished" event.
/// Executes the StopHeartRateMonitor method of the HeartRateMonitorModel object.
/// Updates the value of the CurrentHeartRate property by using GetAverageHeartRateValue method.
/// </summary>
/// <param name="canceled"></param>
private void StopMeasurement(bool canceled = false)
{
    IsMeasuring = false;
    _heartRateMonitorModel.StopHeartRateMonitor();

    if (canceled)
    {
        CurrentHeartRate = 0;
        return;
    }

    IsFinished = true;
}

/// <summary>
/// Updates the value of the MeasurementResultRange property.
/// </summary>
private void UpdateMeasurementResultRange()
{
    if (CurrentHeartRate > HeartRateLimitValue)
    {
        MeasurementResultRange = 1;
    }
    else if (CurrentHeartRate >= AVERAGE_HEART_RATE_VALUE_LOWER_LIMIT &&
             CurrentHeartRate <= AVERAGE_HEART_RATE_VALUE_UPPER_LIMIT)
    {
        MeasurementResultRange = -1;
    }
    else
    {
        MeasurementResultRange = 0;
    }
}

/// <summary>
/// Restores heart rate limit slider value.
/// It tries to obtain this value from application properties dictionary.
/// If it is not available in the dictionary, the value is calculated based on app constants.
/// </summary>
private void RestoreHeartRateLimitSliderValue()
{
    if (_properties.ContainsKey(HEART_RATE_LIMIT_KEY))
    {
        HeartRateLimitSliderValue = (double)_properties[HEART_RATE_LIMIT_KEY];
    }
    else
    {
        HeartRateLimitSliderValue = (double)HEART_RATE_DEFAULT_LIMIT_VALUE / MAX_APP_HEART_RATE_VALUE;
    }
}

```

Step 5: Execute the UpdateMeasurementResultRange method when the CurrentHeartRate property is set.

<highlight>11</highlight>

```csharp
/// <summary>
/// Property with value representing the current heart rate.
/// </summary>
public int CurrentHeartRate
{
    set
    {
        SetProperty(ref _currentHeartRate, value);
        SetHeartRateNumbersValues(value);
        SetHeartRateProgress(value);
        UpdateMeasurementResultRange();
    }
    get { return _currentHeartRate; }
}

```

Step 6: Execute the UpdateMeasurementResultRange method when the HeartRateLimitSliderValue property is set.

<highlight>12</highlight>

```csharp
/// <summary>
/// Property with value representing heart rate limit slider value.
/// </summary>
public double HeartRateLimitSliderValue
{
    set
    {
        SetProperty(ref _heartRateLimitSliderValue, value);
        _properties[HEART_RATE_LIMIT_KEY] = value;
        UpdateHeartRateLimitIndicatorPosition(value);
        HeartRateLimitValue = (int)(value * MAX_APP_HEART_RATE_VALUE);
        UpdateMeasurementResultRange();
    }
    get { return _heartRateLimitSliderValue; }
}

```

## 13. Using the heart rate ranges

We have to replace DataTrigger with MultiTriggers and use the **MeasurementResultRange** view model property to display appropriate message content at the end of the measurement process.

We will modify the HeartRateMonitor/Views/MeasurementPage.xaml file of the project.

Step 1: Replace DataTrigger with MultiTriggers and use the MeasurementResultRange property.

<highlight>11-42</highlight>

```xml
    <Label AbsoluteLayout.LayoutBounds="0, 158, 720, 96"
           Style="{StaticResource MessageMainLabel}"
           Text="{x:Static constants:MessageConstants.READY_CONTENT}">
        <Label.Triggers>
            <DataTrigger Binding="{Binding IsMeasuring, StringFormat='{0}'}"
                         TargetType="Label"
                         Value="True">
                <Setter Property="Text"
                        Value="{x:Static constants:MessageConstants.MEASURING_CONTENT}" />
            </DataTrigger>
            <MultiTrigger TargetType="Label">
                <MultiTrigger.Conditions>
                    <BindingCondition Binding="{Binding IsFinished, StringFormat='{0}'}"
                                      Value="True" />
                    <BindingCondition Binding="{Binding MeasurementResultRange, StringFormat='{0}'}"
                                      Value="-1" />
                </MultiTrigger.Conditions>
                <Setter Property="Text"
                        Value="{x:Static constants:MessageConstants.FINISHED_CONTENT_WITHIN_AVERAGE}" />
            </MultiTrigger>
            <MultiTrigger TargetType="Label">
                <MultiTrigger.Conditions>
                    <BindingCondition Binding="{Binding IsFinished, StringFormat='{0}'}"
                                      Value="True" />
                    <BindingCondition Binding="{Binding MeasurementResultRange, StringFormat='{0}'}"
                                      Value="0" />
                </MultiTrigger.Conditions>
                <Setter Property="Text"
                        Value="{x:Static constants:MessageConstants.FINISHED_CONTENT_WITHIN_LIMIT}" />
            </MultiTrigger>
            <MultiTrigger TargetType="Label">
                <MultiTrigger.Conditions>
                    <BindingCondition Binding="{Binding IsFinished, StringFormat='{0}'}"
                                      Value="True" />
                    <BindingCondition Binding="{Binding MeasurementResultRange, StringFormat='{0}'}"
                                      Value="1" />
                </MultiTrigger.Conditions>
                <Setter Property="Text"
                        Value="{x:Static constants:MessageConstants.FINISHED_CONTENT_ABOVE_LIMIT}" />
                <Setter Property="TextColor"
                        Value="{x:Static constants:ColorConstants.BASE_APP_COLOR}" />
            </MultiTrigger>
        </Label.Triggers>
    </Label>
</AbsoluteLayout>

<!-- Animation area -->

```

Right now the application can be run on the emulator or target device. Pictures presented below show three possible messages that can be displayed at the end of the measurement process (depending on the measured value of the heart rate).

<img src="/assets/images/tutorials/14/hrm-measurement-page-code-step-4-13-average.png" style="width:30%"/>
 
<img src="/assets/images/tutorials/14/hrm-measurement-page-code-step-4-13-below.png" style="width:30%"/>
 
<img src="/assets/images/tutorials/14/hrm-measurement-page-code-step-4-13-above.png" style="width:30%"/>

## 14. Preparing the heart rate alert

We have to create **IsMeasurementResultAlert** property, which will indicate whether the application should display an alert during and at the end of the measurement process. This property should be updated each time the **CurrentHeartRate** or **HeartRateLimitSliderValue** property changes.

We will modify the HeartRateMonitor/ViewModels/MainViewModel.cs file of the project.

Step 1: Create private field for IsMeasurementResultAlert property.

<highlight>6-9</highlight>

```csharp
/// <summary>
/// DateTime object representing the starting time point of the measurement process.
/// </summary>
private DateTime _measurementStartTimestamp;

/// <summary>
/// Flag indicating whether heart rate limit is exceeded.
/// </summary>
private bool _isMeasurementResultAlert = false;

/// <summary>
/// Number representing current heart rate value.
/// </summary>
private int _currentHeartRate = 0;

```

Step 2: Create public IsMeasurementResultAlert property.

<highlight>10-17</highlight>

```csharp
/// <summary>
/// Property indicating whether the measurement process is finished.
/// </summary>
public bool IsFinished
{
    set { SetProperty(ref _isFinished, value); }
    get { return _isFinished; }
}

/// <summary>
/// Property indicating whether heart rate limit is exceeded.
/// </summary>
public bool IsMeasurementResultAlert
{
    set { SetProperty(ref _isMeasurementResultAlert, value); }
    get { return _isMeasurementResultAlert; }
}

/// <summary>
/// Property indicating whether the application is in started state.
/// </summary>
public bool IsStarted
{
    set
    {
        SetProperty(ref _isStarted, value);
        RestoreHeartRateLimitSliderValue();
    }
    get { return _isStarted; }
}

```

Step 3: Create private UpdateMeasurementResultAlert method updating the value of the IsMeasurementResultAlert property.

<highlight>21-27</highlight>

```csharp
/// <summary>
/// Updates the value of the MeasurementResultRange property.
/// </summary>
private void UpdateMeasurementResultRange()
{
    if (CurrentHeartRate > HeartRateLimitValue)
    {
        MeasurementResultRange = 1;
    }
    else if (CurrentHeartRate >= AVERAGE_HEART_RATE_VALUE_LOWER_LIMIT &&
             CurrentHeartRate <= AVERAGE_HEART_RATE_VALUE_UPPER_LIMIT)
    {
        MeasurementResultRange = -1;
    }
    else
    {
        MeasurementResultRange = 0;
    }
}

/// <summary>
/// Updates the value of the IsMeasurementResultAlert property.
/// </summary>
private void UpdateMeasurementResultAlert()
{
    IsMeasurementResultAlert = MeasurementResultRange == 1;
}

/// <summary>
/// Restores heart rate limit slider value.
/// It tries to obtain this value from application properties dictionary.
/// If it is not available in the dictionary, the value is calculated based on app constants.
/// </summary>
private void RestoreHeartRateLimitSliderValue()
{
    if (_properties.ContainsKey(HEART_RATE_LIMIT_KEY))
    {
        HeartRateLimitSliderValue = (double)_properties[HEART_RATE_LIMIT_KEY];
    }
    else
    {
        HeartRateLimitSliderValue = (double)HEART_RATE_DEFAULT_LIMIT_VALUE / MAX_APP_HEART_RATE_VALUE;
    }
}

```

Step 4: Execute the UpdateMeasurementResultAlert method when the CurrentHeartRate property is set.

<highlight>12</highlight>

```csharp
/// <summary>
/// Property with value representing current heart rate.
/// </summary>
public int CurrentHeartRate
{
    set
    {
        SetProperty(ref _currentHeartRate, value);
        SetHeartRateNumbersValues(value);
        SetHeartRateProgress(value);
        UpdateMeasurementResultRange();
        UpdateMeasurementResultAlert();
    }
    get { return _currentHeartRate; }
}

```

Step 5: Execute the UpdateMeasurementResultAlert method when the HeartRateLimitSliderValue property is set.

<highlight>13</highlight>

```csharp
/// <summary>
/// Property with value representing heart rate limit slider value.
/// </summary>
public double HeartRateLimitSliderValue
{
    set
    {
        SetProperty(ref _heartRateLimitSliderValue, value);
        _properties[HEART_RATE_LIMIT_KEY] = value;
        UpdateHeartRateLimitIndicatorPosition(value);
        HeartRateLimitValue = (int)(value * MAX_APP_HEART_RATE_VALUE);
        UpdateMeasurementResultRange();
        UpdateMeasurementResultAlert();
    }
    get { return _heartRateLimitSliderValue; }
}

```

## 15. Displaying the heart rate alert

We have to create DataTriggers and update MultiTriggers so that the application UI is able to notify the user when the heart rate value is greater than the defined limit.

We will modify the HeartRateMonitor/Views/MeasurementPage.xaml file of the project.

Step 1: Create DataTrigger in the animation area to modify the smallest heart image when the heart rate limit is exceeded.

<highlight>17-26</highlight>

```xml
<!-- Animation area -->
<AbsoluteLayout AbsoluteLayout.LayoutBounds="0, 320, 720, 363">
    <Image x:Name="chart"
           AbsoluteLayout.LayoutBounds="0, 88, 960, 154"
           Source="chart.png" />
    <Image x:Name="heart3"
           AbsoluteLayout.LayoutBounds=".5, .5, 378, 330"
           AbsoluteLayout.LayoutFlags="PositionProportional"
           Source="heart_3.png" />
    <Image x:Name="heart2"
           AbsoluteLayout.LayoutBounds=".5, .5, 252, 220"
           AbsoluteLayout.LayoutFlags="PositionProportional"
           Source="heart_2.png" />
    <Image x:Name="heart1"
           AbsoluteLayout.LayoutBounds=".5, .5, 125, 110"
           AbsoluteLayout.LayoutFlags="PositionProportional"
           Source="heart_1.png">
        <Image.Triggers>
            <DataTrigger Binding="{Binding IsMeasurementResultAlert, StringFormat='{0}'}"
                         TargetType="Image"
                         Value="True">
                <Setter Property="Source"
                        Value="heart_4.png" />
            </DataTrigger>
        </Image.Triggers>
    </Image>
</AbsoluteLayout>

```

Step 2: Create DataTriggers and modify MultiTriggers to allow the application to highlight the heart rate value when the limit is exceeded.

<highlight>10-15, 18-19, 31-36, 39-40, 54-59, 62-63</highlight>

```xml
<!-- Progress area -->
<AbsoluteLayout AbsoluteLayout.LayoutBounds="0, 683, 720, 275">
    <StackLayout AbsoluteLayout.LayoutBounds=".5, 0, AutoSize, 137"
                 AbsoluteLayout.LayoutFlags="PositionProportional"
                 Orientation="Horizontal"
                 Spacing="0">
        <Label Style="{StaticResource HeartRateValueText}"
               Text="{Binding CurrentHeartRateFirstNumber}">
            <Label.Triggers>
                <DataTrigger Binding="{Binding IsMeasurementResultAlert, StringFormat='{0}'}"
                             TargetType="Label"
                             Value="True">
                    <Setter Property="Style"
                            Value="{StaticResource HeartRateAlertValueText}" />
                </DataTrigger>
                <MultiTrigger TargetType="Label">
                    <MultiTrigger.Conditions>
                        <BindingCondition Binding="{Binding IsMeasurementResultAlert, StringFormat='{0}'}"
                                          Value="False" />
                        <BindingCondition Binding="{Binding CurrentHeartRateFirstNumber, StringFormat='{0}'}"
                                          Value="0" />
                    </MultiTrigger.Conditions>
                    <Setter Property="Style"
                            Value="{StaticResource HeartRateValueDisabledText}" />
                </MultiTrigger>
            </Label.Triggers>
        </Label>
        <Label Style="{StaticResource HeartRateValueText}"
               Text="{Binding CurrentHeartRateSecondNumber}">
            <Label.Triggers>
                <DataTrigger Binding="{Binding IsMeasurementResultAlert, StringFormat='{0}'}"
                             TargetType="Label"
                             Value="True">
                    <Setter Property="Style"
                            Value="{StaticResource HeartRateAlertValueText}" />
                </DataTrigger>
                <MultiTrigger TargetType="Label">
                    <MultiTrigger.Conditions>
                        <BindingCondition Binding="{Binding IsMeasurementResultAlert, StringFormat='{0}'}"
                                          Value="False" />
                        <BindingCondition Binding="{Binding CurrentHeartRateFirstNumber, StringFormat='{0}'}"
                                          Value="0" />
                        <BindingCondition Binding="{Binding CurrentHeartRateSecondNumber, StringFormat='{0}'}"
                                          Value="0" />
                    </MultiTrigger.Conditions>
                    <Setter Property="Style"
                            Value="{StaticResource HeartRateValueDisabledText}" />
                </MultiTrigger>
            </Label.Triggers>
        </Label>
        <Label Style="{StaticResource HeartRateValueText}"
               Text="{Binding CurrentHeartRateThirdNumber}">
            <Label.Triggers>
                <DataTrigger Binding="{Binding IsMeasurementResultAlert, StringFormat='{0}'}"
                             TargetType="Label"
                             Value="True">
                    <Setter Property="Style"
                            Value="{StaticResource HeartRateAlertValueText}" />
                </DataTrigger>
                <MultiTrigger TargetType="Label">
                    <MultiTrigger.Conditions>
                        <BindingCondition Binding="{Binding IsMeasurementResultAlert, StringFormat='{0}'}"
                                          Value="False" />
                        <BindingCondition Binding="{Binding CurrentHeartRateFirstNumber, StringFormat='{0}'}"
                                          Value="0" />
                        <BindingCondition Binding="{Binding CurrentHeartRateSecondNumber, StringFormat='{0}'}"
                                          Value="0" />
                        <BindingCondition Binding="{Binding CurrentHeartRateThirdNumber, StringFormat='{0}'}"
                                          Value="0" />
                    </MultiTrigger.Conditions>
                    <Setter Property="Style"
                            Value="{StaticResource HeartRateValueDisabledText}" />
                </MultiTrigger>
            </Label.Triggers>
        </Label>
    </StackLayout>

```

Right now the application can be run on the emulator or target device. Pictures presented below show the application screen displaying an alert during and at the end of the measurement process.

<img src="/assets/images/tutorials/14/hrm-measurement-page-code-step-4-15-measuring.png" style="width:30%"/>
 
<img src="/assets/images/tutorials/14/hrm-measurement-page-code-step-4-15-finished.png" style="width:30%"/>

## 16. Calculating the average heart rate value

We have to create private **\_measurementValues** list for storing heart rate values provided by the Tizen Sensor API. Values collected in this list should be used for calculation of the average value of the heart rate at the end of the measurement process.

We will modify the HeartRateMonitor/ViewModels/MainViewModel.cs file of the project.

Step 1: Create private \_measurementValues field.

<highlight>7-11</highlight>

```csharp
/// <summary>
/// Reference to the IDictionary object that is used to store some data,
/// so that they are available the next time the applications runs.
/// </summary>
private IDictionary<string, object> _properties;

/// <summary>
/// List of numbers storing measurement values.
/// It is used to calculate the average value of the heart rate (at the end of the measurement process).
/// </summary>
private List<int> _measurementValues;

#endregion

```

Step 2: Initialize an empty list inside the StartMeasurement method.

<highlight>16</highlight>

```csharp
/// <summary>
/// Starts the measurement process.
/// Sets the values of fields and properties
/// responsible for the correct flow of the measurement process.
/// Invokes "MeasurementStarted" event.
/// Sets timer to let the application know
/// when the measurement process should be stopped automatically.
/// Executes the StartHeartRateMonitor method of the HeartRateMonitorModel object.
/// </summary>
private void StartMeasurement()
{
    IsFinished = false;
    IsMeasuring = true;
    MeasurementCountdown = MEASUREMENT_TIME.ToString();
    _measurementStartTimestamp = DateTime.Now;
    _measurementValues = new List<int>();
    Device.StartTimer(TimeSpan.FromSeconds(MEASUREMENT_TIME), () =>
    {
        if (IsMeasuring && _measurementLock == 0)
        {
            StopMeasurement();
        }

        if (_measurementLock > 0)
        {
            _measurementLock -= 1;
        }

        return false;
    });

    Device.StartTimer(TimeSpan.FromSeconds(1), () =>
    {
        if (!IsMeasuring)
        {
            return false;
        }

        TimeSpan measurementElapsedTime = DateTime.Now - _measurementStartTimestamp;
        MeasurementCountdown = (MEASUREMENT_TIME - measurementElapsedTime.Seconds).ToString();
        return true;
    });

    _heartRateMonitorModel.StartHeartRateMonitor();
}

```

Step 3: Update the \_measurementValues list each time the new heart rate value is obtained.

<highlight>11-14</highlight>

```csharp
/// <summary>
/// Handles "HeartRateMonitorDataChanged" event of the HeartRateMonitorModel object.
/// Updates the value of the MeasurementCountdown property.
/// Updates the value of the CurrentHeartRate property.
/// Adds a new value to the list of measurement values.
/// </summary>
/// <param name="sender"></param>
/// <param name="e"></param>
private void ModelOnHeartRateMonitorDataChanged(object sender, EventArgs e)
{
    int heartRateValue = _heartRateMonitorModel.GetHeartRate();

    CurrentHeartRate = heartRateValue;
    _measurementValues.Add(heartRateValue);
}

```

Step 4: Create private GetAverageHeartRateValue method calculating average value of heart rate.

<highlight>23-40</highlight>

```csharp
/// <summary>
/// Stops the measurement process.
/// Sets values of properties responsible for indicating that the measurement process is finished.
/// Invokes "MeasurementFinished" event.
/// Executes the StopHeartRateMonitor method of the HeartRateMonitorModel object.
/// Updates the value of the CurrentHeartRate property by using GetAverageHeartRateValue method.
/// </summary>
/// <param name="canceled"></param>
private void StopMeasurement(bool canceled = false)
{
    IsMeasuring = false;
    _heartRateMonitorModel.StopHeartRateMonitor();

    if (canceled)
    {
        CurrentHeartRate = 0;
        return;
    }

    IsFinished = true;
}

/// <summary>
/// Calculates an average value of the heart rate based on values stored in the _measurementValues list.
/// </summary>
/// <returns>Average value of the heart rate.</returns>
private int GetAverageHeartRateValue()
{
    int total = 0,
        count = _measurementValues.Count;

    if (count == 0)
    {
        return total;
    }

    total = _measurementValues.Sum();

    return total / count;
}

/// <summary>
/// Updates the value of the MeasurementResultRange property.
/// </summary>
private void UpdateMeasurementResultRange()
{
    if (CurrentHeartRate > HeartRateLimitValue)
    {
        MeasurementResultRange = 1;
    }
    else if (CurrentHeartRate >= AVERAGE_HEART_RATE_VALUE_LOWER_LIMIT &&
             CurrentHeartRate <= AVERAGE_HEART_RATE_VALUE_UPPER_LIMIT)
    {
        MeasurementResultRange = -1;
    }
    else
    {
        MeasurementResultRange = 0;
    }
}

```

Step 5: Update the CurrentHeartRate property at the end of the measurement process.

<highlight>20</highlight>

```csharp
/// <summary>
/// Stops the measurement process.
/// Sets values of properties responsible for indicating that the measurement process is finished.
/// Invokes "MeasurementFinished" event.
/// Executes the StopHeartRateMonitor method of the HeartRateMonitorModel object.
/// Updates the value of the CurrentHeartRate property by using GetAverageHeartRateValue method.
/// </summary>
/// <param name="canceled"></param>
private void StopMeasurement(bool canceled = false)
{
    IsMeasuring = false;
    _heartRateMonitorModel.StopHeartRateMonitor();

    if (canceled)
    {
        CurrentHeartRate = 0;
        return;
    }

    CurrentHeartRate = GetAverageHeartRateValue();
    IsFinished = true;
}

```

## 17. Preventing of entry to the SettingsPage during measurement

We have to prevent displaying the **SettingsPage** during the measurement process.

We will modify the HeartRateMonitor/ViewModels/MainViewModel.cs file of the project.

Step 1: Modify the CanExecuteShowSettingsCommand method so that it returns false when the measurement process is in progress.

<highlight>8</highlight>

```csharp
/// <summary>
/// Checks whether the ShowSettingsCommand command can be executed.
/// </summary>
/// <param name="arg"></param>
/// <returns>Returns true if the ShowSettingsCommand can be executed, false otherwise.</returns>
private bool CanExecuteShowSettingsCommand(object arg)
{
    return !IsMeasuring;
}

```

Step 2: Execute the ChangeCanExecute method when the ExecuteToggleMeasurementCommand command is executed.

<highlight>19</highlight>

```csharp
/// <summary>
/// Executes the ToggleMeasurementCommand command.
/// Depending on the IsMeasuring property state, it starts or stops the measurement process.
/// Additionally, it calls ChangeCanExecute method
/// to update the execution state of the ShowSettingsCommand command.
/// </summary>
private void ExecuteToggleMeasurementCommand()
{
    if (IsMeasuring)
    {
        StopMeasurement(true);
        _measurementLock += 1;
    }
    else
    {
        StartMeasurement();
    }

    ((Command)ShowSettingsCommand).ChangeCanExecute();
}

```

Step 3: Execute the ChangeCanExecute method when the StartMeasurement method is called.

<highlight>22</highlight>

```csharp
/// <summary>
/// Starts the measurement process.
/// Sets the values of fields and properties
/// responsible for the correct flow of the measurement process.
/// Invokes "MeasurementStarted" event.
/// Sets timer to let the application know
/// when the measurement process should be stopped automatically.
/// Executes the StartHeartRateMonitor method of the HeartRateMonitorModel object.
/// </summary>
private void StartMeasurement()
{
    IsFinished = false;
    IsMeasuring = true;
    MeasurementCountdown = MEASUREMENT_TIME.ToString();
    _measurementStartTimestamp = DateTime.Now;
    _measurementValues = new List<int>();
    Device.StartTimer(TimeSpan.FromSeconds(MEASUREMENT_TIME), () =>
    {
        if (IsMeasuring && _measurementLock == 0)
        {
            StopMeasurement();
            ((Command)ShowSettingsCommand).ChangeCanExecute();
        }

        if (_measurementLock > 0)
        {
            _measurementLock -= 1;
        }

        return false;
    });

    Device.StartTimer(TimeSpan.FromSeconds(1), () =>
    {
        if (!IsMeasuring)
        {
            return false;
        }

        TimeSpan measurementElapsedTime = DateTime.Now - _measurementStartTimestamp;
        MeasurementCountdown = (MEASUREMENT_TIME - measurementElapsedTime.Seconds).ToString();
        return true;
    });

    _heartRateMonitorModel.StartHeartRateMonitor();
}

```

# V. IMPLEMENTING ANIMATIONS

## 1. Goal

The goal of this tutorial's part is to implement animations which are running during the measurement process. The application animates four elements in order to achieve an effect of a beating heart and a moving chart.

To do so we have to implement:

## 2. Notifying about the measurement status

We have to create public **MeasurementStarted** and **MeasurementFinished** events, which will be invoked when the measurement state changes.

We will modify the HeartRateMonitor/ViewModels/MainViewModel.cs file of the project.

Step 1: Create public MeasurementStarted and MeasurementFinished events.

<highlight>6-16</highlight>

```csharp
/// <summary>
/// Updates view model properties responsible for UI representation of heart rate limit.
/// </summary>
public ICommand UpdateHeartRateLimitCommand { private set; get; }

/// <summary>
/// MeasurementStarted event.
/// It is fired when the measurement process starts.
/// </summary>
public event EventHandler MeasurementStarted;

/// <summary>
/// MeasurementFinished event.
/// It is fired when the measurement finishes.
/// </summary>
public event EventHandler MeasurementFinished;

/// <summary>
/// Property indicating whether the measurement process is in progress.
/// </summary>
public bool IsMeasuring
{
    set { SetProperty(ref _isMeasuring, value); }
    get { return _isMeasuring; }
}

```

Step 2: Invoke the MeasurementStarted event when the StartMeasurement method is executed.

<highlight>17</highlight>

```csharp
/// <summary>
/// Starts the measurement process.
/// Sets the values of fields and properties
/// responsible for the correct flow of the measurement process.
/// Invokes "MeasurementStarted" event.
/// Sets timer to let the application know
/// when the measurement process should be stopped automatically.
/// Executes the StartHeartRateMonitor method of the HeartRateMonitorModel object.
/// </summary>
private void StartMeasurement()
{
    IsFinished = false;
    IsMeasuring = true;
    MeasurementCountdown = MEASUREMENT_TIME.ToString();
    _measurementStartTimestamp = DateTime.Now;
    _measurementValues = new List<int>();
    MeasurementStarted?.Invoke(this, new EventArgs());
    Device.StartTimer(TimeSpan.FromSeconds(MEASUREMENT_TIME), () =>
    {
        if (IsMeasuring && _measurementLock == 0)
        {
            StopMeasurement();
            ((Command)ShowSettingsCommand).ChangeCanExecute();
        }

        if (_measurementLock > 0)
        {
            _measurementLock -= 1;
        }

        return false;
    });

    Device.StartTimer(TimeSpan.FromSeconds(1), () =>
    {
        if (!IsMeasuring)
        {
            return false;
        }

        TimeSpan measurementElapsedTime = DateTime.Now - _measurementStartTimestamp;
        MeasurementCountdown = (MEASUREMENT_TIME - measurementElapsedTime.Seconds).ToString();
        return true;
    });

    _heartRateMonitorModel.StartHeartRateMonitor();
}

```

Step 3: Invoke the MeasurementFinished event when the StopMeasurement method is executed.

<highlight>12</highlight>

```csharp
/// <summary>
/// Stops the measurement process.
/// Sets the values of properties responsible for indicating that the measurement process is finished.
/// Invokes "MeasurementFinished" event.
/// Executes the StopHeartRateMonitor method of the HeartRateMonitorModel object.
/// Updates the value of the CurrentHeartRate property by using GetAverageHeartRateValue method.
/// </summary>
/// <param name="canceled"></param>
private void StopMeasurement(bool canceled = false)
{
    IsMeasuring = false;
    MeasurementFinished?.Invoke(this, new EventArgs());
    _heartRateMonitorModel.StopHeartRateMonitor();

    if (canceled)
    {
        CurrentHeartRate = 0;
        return;
    }

    CurrentHeartRate = GetAverageHeartRateValue();
    IsFinished = true;
}

```

## 3. Launching animations

We have to create handlers executed when **MeasurementStarted** and **MeasurementFinished** events occur. These handlers will start and stop animations we want to create.

We will modify the HeartRateMonitor/Views/MeasurementPage.xaml.cs and HeartRateMonitor/HeartRateMonitor.cs files of the project.

Step 1: Create private \_viewModel field for storing an instance of the MainViewModel class.

<highlight>3-6</highlight>

```csharp
#region fields

/// <summary>
/// An instance of the MainViewModel class.
/// </summary>
private MainViewModel _viewModel;

#endregion

```

Step 2: Create public Init method and initialize the \_viewModel field.

<highlight>9-17</highlight>

```csharp
/// <summary>
/// MeasurementPage class constructor.
/// </summary>
public MeasurementPage()
{
    InitializeComponent();
}

/// <summary>
/// Initializes MeasurementPage class.
/// Assigns handlers to the MeasurementStarted and MeasurementFinished events
/// of the MainViewModel class.
/// </summary>
public void Init()
{
    _viewModel = ((App)Application.Current).AppMainViewModel;
}

#endregion

```

Step 3: Create private constant integer fields, which will be used during the animation.

<highlight>6-29</highlight>

```csharp
/// <summary>
/// An instance of the MainViewModel class.
/// </summary>
private MainViewModel _viewModel;

/// <summary>
/// Number representing the duration value (in milliseconds) of the chart animation.
/// </summary>
private const int CHART_ANIMATION_DURATION = 1000;

/// <summary>
/// Number representing the duration value (in milliseconds) of hearts animation.
/// </summary>
private const int HEART_ANIMATION_DURATION = 500;

/// <summary>
/// Number representing the delay value (in milliseconds) of big hearts animation.
/// </summary>
private const int BIG_HEARTS_ANIMATION_DELAY = 500;

/// <summary>
/// Number representing the duration value (in milliseconds) of the stop animation.
/// </summary>
private const int STOP_ANIMATION_DURATION = 300;

/// <summary>
/// Number representing the length (in pixels) of the one chart wave.
/// </summary>
private const int CHART_WAVE_LENGTH = 240;

#endregion

```

Step 4: Create private StartChartAnimation method which uses TranslateTo method to animate the position of the chart element.

<highlight>9-19</highlight>

```csharp
/// <summary>
/// MeasurementPage class constructor.
/// </summary>
public MeasurementPage()
{
    InitializeComponent();
}

/// <summary>
/// Starts chart animation.
/// </summary>
private async void StartChartAnimation()
{
    while (_viewModel.IsMeasuring)
    {
        chart.TranslationX = 0;
        await chart.TranslateTo(-CHART_WAVE_LENGTH, 0, CHART_ANIMATION_DURATION);
    }
}

/// <summary>
/// Initializes MeasurementPage class.
/// Assigns handlers to the MeasurementStarted and MeasurementFinished events
/// of the MainViewModel class.
/// </summary>
public void Init()
{
    _viewModel = ((App)Application.Current).AppMainViewModel;
}

```

Step 5: Create private StartHeartAnimation method, which uses ScaleTo method to animate the size of heart elements.

<highlight>13-30</highlight>

```csharp
/// <summary>
/// Starts chart animation.
/// </summary>
private async void StartChartAnimation()
{
    while (_viewModel.IsMeasuring)
    {
        chart.TranslationX = 0;
        await chart.TranslateTo(-CHART_WAVE_LENGTH, 0, CHART_ANIMATION_DURATION);
    }
}

/// <summary>
/// Starts the animation of heart given as the first parameter
/// with delay given as the second parameter.
/// </summary>
/// <param name="heartImage"></param>
/// <param name="delay"></param>
private async void StartHeartAnimation(Image heartImage, int delay)
{
    await Task.Delay(delay);

    while (_viewModel.IsMeasuring)
    {
        if (!await heartImage.ScaleTo(1.1, HEART_ANIMATION_DURATION))
        {
            await heartImage.ScaleTo(1, HEART_ANIMATION_DURATION);
        }
    }
}

/// <summary>
/// Initializes MeasurementPage class.
/// Assigns handlers to the MeasurementStarted and MeasurementFinished events
/// of the MainViewModel class.
/// </summary>
public void Init()
{
    _viewModel = ((App)Application.Current).AppMainViewModel;
}

```

Step 6: Create private OnMeasurementStarted handler method.

<highlight>9-20</highlight>

```csharp
/// <summary>
/// MeasurementPage class constructor.
/// </summary>
public MeasurementPage()
{
    InitializeComponent();
}

/// <summary>
/// Handles "MeasurementStarted" event of the MainViewModel class.
/// </summary>
/// <param name="sender"></param>
/// <param name="e"></param>
private void OnMeasurementStarted(object sender, EventArgs e)
{
    StartChartAnimation();
    StartHeartAnimation(heart1, 0);
    StartHeartAnimation(heart2, BIG_HEARTS_ANIMATION_DELAY);
    StartHeartAnimation(heart3, BIG_HEARTS_ANIMATION_DELAY);
}

/// <summary>
/// Starts chart animation.
/// </summary>
private async void StartChartAnimation()
{
    while (_viewModel.IsMeasuring)
    {
        chart.TranslationX = 0;
        await chart.TranslateTo(-CHART_WAVE_LENGTH, 0, CHART_ANIMATION_DURATION);
    }
}

```

Step 7: Modify the Init method by adding the OnMeasurementStarted handler to the MeasurementStarted event of the MainViewModel class.

<highlight>10</highlight>

```csharp
/// <summary>
/// Initializes MeasurementPage class.
/// Assigns handlers to the MeasurementStarted and MeasurementFinished events
/// of the MainViewModel class.
/// </summary>
public void Init()
{
    _viewModel = ((App)Application.Current).AppMainViewModel;

    _viewModel.MeasurementStarted += OnMeasurementStarted;
}

```

Step 8: Create private StopChartAnimation method.

<highlight>20-27</highlight>

```csharp
/// <summary>
/// Starts the animation of heart given as the first parameter
/// with delay given as the second parameter.
/// </summary>
/// <param name="heartImage"></param>
/// <param name="delay"></param>
private async void StartHeartAnimation(Image heartImage, int delay)
{
    await Task.Delay(delay);

    while (_viewModel.IsMeasuring)
    {
        if (!await heartImage.ScaleTo(1.1, HEART_ANIMATION_DURATION))
        {
            await heartImage.ScaleTo(1, HEART_ANIMATION_DURATION);
        }
    }
}

/// <summary>
/// Stops chart animation.
/// </summary>
private void StopChartAnimation()
{
    ViewExtensions.CancelAnimations(chart);
    chart.TranslateTo(-CHART_WAVE_LENGTH, 0, STOP_ANIMATION_DURATION, Easing.SinOut);
}

/// <summary>
/// Initializes MeasurementPage class.
/// Assigns handlers to the MeasurementStarted and MeasurementFinished events
/// of the MainViewModel class.
/// </summary>
public void Init()
{
    _viewModel = ((App)Application.Current).AppMainViewModel;

    _viewModel.MeasurementStarted += OnMeasurementStarted;
}

```

Step 9: Create private StopHeartAnimation method.

<highlight>10-18</highlight>

```csharp
/// <summary>
/// Stops chart animation.
/// </summary>
private void StopChartAnimation()
{
    ViewExtensions.CancelAnimations(chart);
    chart.TranslateTo(-CHART_WAVE_LENGTH, 0, STOP_ANIMATION_DURATION, Easing.SinOut);
}

/// <summary>
/// Stops the animation of heart given as a parameter.
/// </summary>
/// <param name="heartImage"></param>
private void StopHeartAnimation(Image heartImage)
{
    ViewExtensions.CancelAnimations(heartImage);
    heartImage.ScaleTo(1, STOP_ANIMATION_DURATION, Easing.SinOut);
}

/// <summary>
/// Initializes MeasurementPage class.
/// Assigns handlers to the MeasurementStarted and MeasurementFinished events
/// of the MainViewModel class.
/// </summary>
public void Init()
{
    _viewModel = ((App)Application.Current).AppMainViewModel;

    _viewModel.MeasurementStarted += OnMeasurementStarted;
}

```

Step 10: Create private OnMeasurementFinished handler method.

<highlight>14-25</highlight>

```csharp
/// <summary>
/// Handles "MeasurementStarted" event of the MainViewModel class.
/// </summary>
/// <param name="sender"></param>
/// <param name="e"></param>
private void OnMeasurementStarted(object sender, EventArgs e)
{
    StartChartAnimation();
    StartHeartAnimation(heart1, 0);
    StartHeartAnimation(heart2, BIG_HEARTS_ANIMATION_DELAY);
    StartHeartAnimation(heart3, BIG_HEARTS_ANIMATION_DELAY);
}

/// <summary>
/// Handles "MeasurementFinished" event of the MainViewModel class.
/// </summary>
/// <param name="sender"></param>
/// <param name="e"></param>
private void OnMeasurementFinished(object sender, EventArgs e)
{
    StopChartAnimation();
    StopHeartAnimation(heart1);
    StopHeartAnimation(heart2);
    StopHeartAnimation(heart3);
}

/// <summary>
/// Starts chart animation.
/// </summary>
private async void StartChartAnimation()
{
    while (_viewModel.IsMeasuring)
    {
        chart.TranslationX = 0;
        await chart.TranslateTo(-CHART_WAVE_LENGTH, 0, CHART_ANIMATION_DURATION);
    }
}

```

Step 11: Modify the Init method by adding the OnMeasurementFinished handler to the MeasurementFinished event of the MainViewModel class.

<highlight>11</highlight>

```csharp
/// <summary>
/// Initializes MeasurementPage class.
/// Assigns handlers to the MeasurementStarted and MeasurementFinished events
/// of the MainViewModel class.
/// </summary>
public void Init()
{
    _viewModel = ((App)Application.Current).AppMainViewModel;

    _viewModel.MeasurementStarted += OnMeasurementStarted;
    _viewModel.MeasurementFinished += OnMeasurementFinished;
}

```

Step 12: Create private ResetChartPosition method which restores the initial position of the chart element.

<highlight>14-20</highlight>

```csharp
/// <summary>
/// Initializes MeasurementPage class.
/// Assigns handlers to the MeasurementStarted and MeasurementFinished events
/// of the MainViewModel class.
/// </summary>
public void Init()
{
    _viewModel = ((App)Application.Current).AppMainViewModel;

    _viewModel.MeasurementStarted += OnMeasurementStarted;
    _viewModel.MeasurementFinished += OnMeasurementFinished;
}

/// <summary>
/// Restores the initial position of the chart element.
/// </summary>
private void ResetChartPosition()
{
    chart.TranslationX = 0;
}

#endregion

```

Step 13: Override OnDisappearing method and call the ResetChartPosition method.

<highlight>14-21</highlight>

```csharp
/// <summary>
/// Initializes MeasurementPage class.
/// Assigns handlers to the MeasurementStarted and MeasurementFinished events
/// of the MainViewModel class.
/// </summary>
public void Init()
{
    _viewModel = ((App)Application.Current).AppMainViewModel;

    _viewModel.MeasurementStarted += OnMeasurementStarted;
    _viewModel.MeasurementFinished += OnMeasurementFinished;
}

/// <summary>
/// Performs action when the measurement page disappears.
/// Restores the initial position of the chart element.
/// </summary>
protected override void OnDisappearing()
{
    ResetChartPosition();
}

/// <summary>
/// Restores the initial position of the chart element.
/// </summary>
private void ResetChartPosition()
{
    chart.TranslationX = 0;
}

```

Step 14: Update the StartChartAnimation method using the ResetChartPosition method.

<highlight>8</highlight>

```csharp
/// <summary>
/// Starts chart animation.
/// </summary>
private async void StartChartAnimation()
{
    while (_viewModel.IsMeasuring)
    {
        ResetChartPosition();
        await chart.TranslateTo(-CHART_WAVE_LENGTH, 0, CHART_ANIMATION_DURATION);
    }
}

```

Step 15: Update the HeartRateMonitor/HeartRateMonitor.cs and execute the Init method of the MeasurementPage class int the constructor.

<highlight>14</highlight>

```csharp
/// <summary>
/// App class constructor.
/// </summary>
public App()
{
    MeasurementPage appMeasurementPage = new MeasurementPage();
    AppMainViewModel = new MainViewModel(Properties, new PageNavigation(appMeasurementPage.Navigation));

    MainPage = new NavigationPage(appMeasurementPage)
    {
        BarBackgroundColor = ColorConstants.BASE_APP_COLOR
    };

    appMeasurementPage.Init();
}

```
