---
layout: ../../layouts/tutorial/TextTutorial.astro
title: 'How to Create "BadgeCounter" App'
description: "This tutorial shows how to create BadgeCounter app using Xamarin Forms and Application API."
created: "2018/05/03"
modified: "2020/04/18"
profile: ["wearable"]
type: "dotnet"
level: 2
state: "open"
thumbnail: "/TizenSchool/assets/images/tutorials/106/BC_thumbnail.png"
---

#

# I. INTRODUCTION

## 1. Overview

In this tutorial, we will create a Badge Counter application. It shows how to use Application API to manage its badge counter. A badge is an image displayed on the application icon, which informs the user about notifications and events.

First, take a look at appearance of the application (final version).

<img src="/TizenSchool/assets/images/tutorials/106/overview-1.png" style="height:544px; width:400px"/>
 

The user interface consist of:

Each change of the badge counter value is also visible in home screen application (application launcher).

Content of this tutorial is under [Apache 2.0](http://www.apache.org/licenses/LICENSE-2.0) license.

## 2. Importing and building solution

In this step, we will import and build Visual Studio solution containing initial application code.

Step 1: Download and unpack [badge-counter.zip](https://tizenschool.org/assets/images/tutorials/106/badge-counter.zip) file.

Step 2: Click File > Open > Project/Solution...

<img src="/TizenSchool/assets/images/tutorials/106/badge-counter-import-1.png" style="width:90%"/>

Step 3: Go to downloaded directory and select BadgeCounter.sln file (Microsoft Visual Studio Solution), then click the "Open" button.

<img src="/TizenSchool/assets/images/tutorials/106/badge-counter-import-2.png" style="width:90%"/>

The solution structure should appear in the Solution Explorer view. It should contain two projects: BadgeCounter and BadgeCounter.Tizen.Wearable.

<img src="/TizenSchool/assets/images/tutorials/106/badge-counter-import-3.png" style="width:90%"/>

Step 4: Right-click on the solution and select "Restore NuGet Packages" from the context menu. This will set up NuGet packages for all projects.

<img src="/TizenSchool/assets/images/tutorials/106/badge-counter-import-4.png" style="width:90%"/>

Step 5: Right-click on the solution again and select "Rebuild Solution" from the context menu.

<img src="/TizenSchool/assets/images/tutorials/106/badge-counter-import-5.png" style="width:90%"/>

Step 6: Right-click on the "BadgeCounter.Tizen.Wearable" project and select "Set as StartUp Project" from the context menu.

<img src="/TizenSchool/assets/images/tutorials/106/badge-counter-import-6.png" style="width:90%"/>

Right now the application can be run on the emulator or target device. We will start with base version of the application. For now, it shows only black screen but don't worry, we will implement all features in the next steps.

<img src="/TizenSchool/assets/images/tutorials/106/badge-counter-import-7.png" style="height:544px; width:400px"/>

# II. USER INTERFACE

## 1. Goal

The goal of this chapter is to create static layout for application user interface.

We will start by creating base layout (background, header and reset button). After that we will create few custom controls for more complicated parts of the layout.

<img src="/TizenSchool/assets/images/tutorials/106/badge-counter-ui-final.png" style="height:544px; width:400px"/>

## 2. Base layout

In this tutorial part we will create base layout of the application - background, page header and reset button. Other buttons are more complicated and they will be described in next parts (we will create custom controls for them).

We will modify _BadgeCounter\Views\MainPage.xaml_ file.

1. Create container for all page elements. We will use _AbsoluteLayout_ to be able to precisely position them.<br/>

<highlight>6-12</highlight>

```xml
<?xml version="1.0" encoding="utf-8" ?>
<ContentPage xmlns="http://xamarin.com/schemas/2014/forms"
             xmlns:x="http://schemas.microsoft.com/winfx/2009/xaml"
             x:Class="BadgeCounter.Views.MainPage"
             xmlns:controls="clr-namespace:BadgeCounter.Controls">

    <ContentPage.Content>
        <AbsoluteLayout VerticalOptions="FillAndExpand"
                        HorizontalOptions="FillAndExpand">
        </AbsoluteLayout>
    </ContentPage.Content>

</ContentPage>

```

2. Add _Image_ element for application's background.

<highlight>3-8</highlight>

```xml
<AbsoluteLayout VerticalOptions="FillAndExpand"
                HorizontalOptions="FillAndExpand">

    <!-- Application background image -->
    <Image AbsoluteLayout.LayoutBounds="0, 0, 1, 1"
           AbsoluteLayout.LayoutFlags="All"
           Source="images/app_background.png" />

</AbsoluteLayout>

```

3. Add Label element for page header. It will display application name.

<highlight>9-16</highlight>

```xml
<AbsoluteLayout VerticalOptions="FillAndExpand"
                HorizontalOptions="FillAndExpand">

    <!-- Application background image -->
    <Image AbsoluteLayout.LayoutBounds="0, 0, 1, 1"
           AbsoluteLayout.LayoutFlags="All"
           Source="images/app_background.png" />

    <!-- Page header - application name -->
    <Label AbsoluteLayout.LayoutBounds="137, 60, 87, 36"
           AbsoluteLayout.LayoutFlags="None"
           Text="BADGE COUNTER"
           FontSize="6"
           FontFamily="BreezeSans:style=Medium"
           HorizontalTextAlignment="Center"
           TextColor="#c34a58" />

</AbsoluteLayout>

```

4. Add _Image_ element for reset button (it will be placed in the middle of the screen).

<highlight>18-22</highlight>

```xml
<AbsoluteLayout VerticalOptions="FillAndExpand"
                HorizontalOptions="FillAndExpand">

    <!-- Application background image -->
    <Image AbsoluteLayout.LayoutBounds="0, 0, 1, 1"
           AbsoluteLayout.LayoutFlags="All"
           Source="images/app_background.png" />

    <!-- Page header - application name -->
    <Label AbsoluteLayout.LayoutBounds="137, 60, 87, 36"
           AbsoluteLayout.LayoutFlags="None"
           Text="BADGE COUNTER"
           FontSize="6"
           FontFamily="BreezeSans:style=Medium"
           HorizontalTextAlignment="Center"
           TextColor="#c34a58" />

    <!-- Icon under the counter - Reset button -->
    <Image AbsoluteLayout.LayoutBounds="128, 118, 104, 104"
           AbsoluteLayout.LayoutFlags="None"
           Source="images/app_icon.png">
    </Image>

</AbsoluteLayout>

```

Right now the application can be run on the emulator or target device. It should contain background, header with application name and reset button in the middle of the screen.

<img src="/TizenSchool/assets/images/tutorials/106/badge-counter-base-layout-1.png" style="height:544px; width:400px"/>

## 3. Increase/decrease buttons (custom control)

In this tutorial part we will create custom control for "increase" and "decrease" buttons. The buttons are responsible for changing the current badge counter value.

The reason for creating custom control is necessity of simulating a press effect (different appearance for this state) and avoiding duplication of code (there are two buttons which need to behave that way).

Our control (we will call it ImageButton) allows to specify two images for available states (default, pressed). When the user presses the button, the displayed image is changed for a specified time (300 milliseconds by default). The control also allows to specify a command which will execute when user taps on it.

The files for the control are already created (we need to fill them up):

1. In the code behind file, create constant for default pressed state timeout.

<highlight>2-8</highlight>

```csharp
#region fields

/// <summary>
/// Default timeout for control's pressed state (in milliseconds).
/// After that time, the control returns to normal state.
/// </summary>
private const int DEFAULT_TIMEOUT = 300;

#endregion

```

2. Create backing stores (definitions) for control's bindable properties.

<highlight>2-26</highlight>

```csharp
#region properties

/// <summary>
/// Bindable property definition for normal state image source.
/// </summary>
public static readonly BindableProperty SourceProperty = BindableProperty.Create(
    "Source", typeof(ImageSource), typeof(ImageButton));

/// <summary>
/// Bindable property definition for pressed state image source.
/// </summary>
public static readonly BindableProperty PressedSourceProperty = BindableProperty.Create(
    "PressedSource", typeof(ImageSource), typeof(ImageButton));

/// <summary>
/// Bindable property definition for pressed state timeout (in milliseconds).
/// </summary>
public static readonly BindableProperty PressedTimeoutProperty = BindableProperty.Create(
    "PressedTimeout", typeof(int), typeof(ImageButton), DEFAULT_TIMEOUT);

/// <summary>
/// Bindable property definition for control's default command (executed when control is tapped).
/// </summary>
public static readonly BindableProperty CommandProperty = BindableProperty.Create(
    "Command", typeof(ICommand), typeof(ImageButton));

#endregion

```

3. Define bindable properties accessors.

<highlight>7-43</highlight>

```csharp
/// <summary>
/// Bindable property definition for control's default command (executed when control is tapped).
/// </summary>
public static readonly BindableProperty CommandProperty = BindableProperty.Create(
    "Command", typeof(ICommand), typeof(ImageButton));

/// <summary>
/// Image source for control's default/normal state.
/// </summary>
public ImageSource Source
{
    get => (ImageSource)GetValue(SourceProperty);
    set => SetValue(SourceProperty, value);
}

/// <summary>
/// Image source for control's pressed state.
/// Image is displayed for specified amount of time when control is tapped.
/// </summary>
public ImageSource PressedSource
{
    get => (ImageSource)GetValue(PressedSourceProperty);
    set => SetValue(PressedSourceProperty, value);
}

/// <summary>
/// Timeout for displaying pressed state image (pressed state simulation).
/// </summary>
public int PressedTimeout
{
    get => (int)GetValue(PressedTimeoutProperty);
    set => SetValue(PressedTimeoutProperty, value);
}

/// <summary>
/// Control's default command.
/// Executed when control is tapped.
/// </summary>
public ICommand Command
{
    get => (ICommand)GetValue(CommandProperty);
    set => SetValue(CommandProperty, value);
}

#endregion

```

4. In the XAML file, add two Image elements which display images for two available states. The control toggles visibility of them to simulate press effect.

<highlight>6-25</highlight>

```xml
<?xml version="1.0" encoding="UTF-8"?>
<ContentView xmlns="http://xamarin.com/schemas/2014/forms"
             xmlns:x="http://schemas.microsoft.com/winfx/2009/xaml"
             x:Class="BadgeCounter.Controls.ImageButton"
             x:Name="Root">

    <ContentView.Content>
        <AbsoluteLayout VerticalOptions="FillAndExpand"
                        HorizontalOptions="FillAndExpand">

            <!-- Image for pressed state -->
            <Image AbsoluteLayout.LayoutBounds="0, 0, 1, 1"
                   AbsoluteLayout.LayoutFlags="All"
                   Source="{Binding Source={x:Reference Root}, Path=PressedSource}"
                   x:Name="PressedSourceImage" />

            <!-- Image for normal/default state -->
            <Image AbsoluteLayout.LayoutBounds="0, 0, 1, 1"
                   AbsoluteLayout.LayoutFlags="All"
                   Source="{Binding Source={x:Reference Root}, Path=Source}"
                   x:Name="SourceImage" />

        </AbsoluteLayout>
    </ContentView.Content>

</ContentView>

```

5. Add private fields - flags which indicate disabled and pressed state of the control.

<highlight>9-17</highlight>

```csharp
#region fields

/// <summary>
/// Default timeout for control's pressed state (in milliseconds).
/// After that time, the control returns to normal state.
/// </summary>
private const int DEFAULT_TIMEOUT = 300;

/// <summary>
/// Flag indicating if control is in disabled state.
/// </summary>
private bool _disabled = false;

/// <summary>
/// Flag indicating if press animation (displaying image for pressed state) is in progress.
/// </summary>
private bool _pressed = false;

#endregion

```

6. Register handler for tap event.

<highlight>9, 12-31</highlight>

```csharp
#region methods

/// <summary>
/// The control constructor.
/// </summary>
public ImageButton()
{
    InitializeComponent();
    InitializeEventsListeners();
}

/// <summary>
/// Initializes event listeners of the control.
/// </summary>
private void InitializeEventsListeners()
{
    ((AbsoluteLayout)Content).GestureRecognizers.Add(new TapGestureRecognizer
    {
        Command = new Command(OnTapped)
    });
}

/// <summary>
/// Handles tap on the control body.
/// Simulates pressed state by changing control appearance (proper images) for specified time.
/// When press animation ends, the control's default command is executed.
/// </summary>
private void OnTapped()
{

}

#endregion

```

7. Implement the tap event handler. It will use timer to switch image for a specified period of time. It will also execute default command if the control is not disabled.

<highlight>8-24</highlight>

```csharp
/// <summary>
/// Handles tap on the control body.
/// Simulates pressed state by changing control appearance (proper images) for specified time.
/// When press animation ends, the control's default command is executed.
/// </summary>
private void OnTapped()
{
    if (PressedSource != null && !_disabled && !_pressed)
    {
        SourceImage.IsVisible = false;
        _pressed = true;
        Device.StartTimer(TimeSpan.FromMilliseconds(PressedTimeout), () =>
        {
            _pressed = false;
            SourceImage.IsVisible = true;

            if (!_disabled)
            {
                Command?.Execute(null);
            }

            return false;
        });
    }
}

```

8. Add a code which will handle "Command" property change. It will also updates "\_disabled" flag by monitoring command's "CanExecute" method result.

<highlight>27-67</highlight>

```csharp
/// <summary>
/// Handles tap on the control body.
/// Simulates pressed state by changing control appearance (proper images) for specified time.
/// When press animation ends, the control's default command is executed.
/// </summary>
private void OnTapped()
{
    if (PressedSource != null && !_disabled && !_pressed)
    {
        SourceImage.IsVisible = false;
        _pressed = true;
        Device.StartTimer(TimeSpan.FromMilliseconds(PressedTimeout), () =>
        {
            _pressed = false;
            SourceImage.IsVisible = true;

            if (!_disabled)
            {
                Command?.Execute(null);
            }

            return false;
        });
    }
}

/// <summary>
/// Handles control's properties change.
/// Forwards the action to property specific method.
/// </summary>
/// <param name="propertyName">Name of property which changed.</param>
protected override void OnPropertyChanged(string propertyName = null)
{
    base.OnPropertyChanged(propertyName);
    if (propertyName == CommandProperty.PropertyName)
    {
        OnCommandPropertyChanged();
    }
}

/// <summary>
/// Handles change of the command property.
/// Updates disabled state and start listening for command's execution possibility change.
/// </summary>
private void OnCommandPropertyChanged()
{
    if (Command != null)
    {
        _disabled = !Command.CanExecute(null);
        Command.CanExecuteChanged += CommandOnCanExecuteChanged;
    }
    else
    {
        _disabled = false;
    }
}

/// <summary>
/// Handles change of command's execution possibility.
/// Updates disabled state of the control.
/// </summary>
/// <param name="sender">Event sender.</param>
/// <param name="eventArgs">Event arguments.</param>
private void CommandOnCanExecuteChanged(object sender, EventArgs eventArgs)
{
    _disabled = !Command.CanExecute(null);
}

#endregion

```

The custom control implementation is completed. Let's use it in the main view of the application.

9. In main page XAML file, add two buttons using created control.

<highlight>7-17</highlight>

```xml
<!-- Icon under the counter - Reset button -->
<Image AbsoluteLayout.LayoutBounds="128, 118, 104, 104"
       AbsoluteLayout.LayoutFlags="None"
       Source="images/app_icon.png">
</Image>

<!-- Minus button - decrease badge counter -->
<controls:ImageButton AbsoluteLayout.LayoutBounds="51, 146, 60, 60"
                      AbsoluteLayout.LayoutFlags="None"
                      Source="images/normal_state_minus.png"
                      PressedSource="images/hover_state_minus.png" />

<!-- Plus button - increase badge counter -->
<controls:ImageButton AbsoluteLayout.LayoutBounds="249, 146, 60, 60"
                      AbsoluteLayout.LayoutFlags="None"
                      Source="images/normal_state_plus.png"
                      PressedSource="images/hover_state_plus.png" />

```

Right now the application can be run on the emulator or target device. When "increase" and "decrease" buttons are tapped, their appearance should change for a moment.

<img src="/TizenSchool/assets/images/tutorials/106/badge-counter-inc-dec-1.png" style="height:544px; width:400px"/>

## 4. Toggle auto-increment button (custom control)

In this tutorial part we will create custom control for "toggle auto-increment" button. The button is responsible for turning on/off the automatic incremenation of badge counter value.

Our new custom control (we will call it _ToggleButton_ ) behaves just a regular toggle switch but it allows to define images for on/off states and provides simple images transition when the state is toggled. State of the control can be get or set using the _Checked_ bindable property. The control allows also to specify a text displayed on top of it using the _Text_ bindable property.

The files for the control are already created (we need to fill them up):

1. In the code behind file, create constant for toggle animation time.

<highlight>2-7</highlight>

```csharp
#region fields

/// <summary>
/// Toggling state animation time (in milliseconds).
/// </summary>
private const int ANIMATION_TIME = 1000;

#endregion

```

2. Create backing stores (definitions) for control's bindable properties.

<highlight>2-26</highlight>

```csharp
#region properties

/// <summary>
/// Bindable property definition for an image displayed as control's "off" state.
/// </summary>
public static readonly BindableProperty OffStateSourceProperty = BindableProperty.Create(
    "OffStateSource", typeof(ImageSource), typeof(ToggleButton));

/// <summary>
/// Bindable property definition for an image displayed as control's "on" state.
/// </summary>
public static readonly BindableProperty OnStateImageProperty = BindableProperty.Create(
    "OnStateSource", typeof(ImageSource), typeof(ToggleButton));

/// <summary>
/// Bindable property definition for the control's state.
/// </summary>
public static readonly BindableProperty CheckedProperty = BindableProperty.Create(
    "Checked", typeof(bool), typeof(ToggleButton), false, BindingMode.TwoWay);

/// <summary>
/// Bindable property definition for the text displayed in the foreground of the control.
/// </summary>
public static readonly BindableProperty TextProperty = BindableProperty.Create(
    "Text", typeof(string), typeof(ToggleButton), default(string));

#endregion

```

3. Define bindable properties accessors.

<highlight>7-42</highlight>

```csharp
/// <summary>
/// Bindable property definition for the text displayed in the foreground of the control.
/// </summary>
public static readonly BindableProperty TextProperty = BindableProperty.Create(
    "Text", typeof(string), typeof(ToggleButton), default(string));

/// <summary>
/// Source of an image displayed as control's "off" state.
/// </summary>
public ImageSource OffStateSource
{
    get => (ImageSource)GetValue(OffStateSourceProperty);
    set => SetValue(OffStateSourceProperty, value);
}

/// <summary>
/// Source of an image displayed as control's "on" state.
/// </summary>
public ImageSource OnStateSource
{
    get => (ImageSource)GetValue(OnStateImageProperty);
    set => SetValue(OnStateImageProperty, value);
}

/// <summary>
/// State of the toggle button.
/// True value represents "on" state, false value represents "off" state respectively.
/// </summary>
public bool Checked
{
    get => (bool)GetValue(CheckedProperty);
    set => SetValue(CheckedProperty, value);
}

/// <summary>
/// Text displayed in the foreground of the control.
/// </summary>
public string Text
{
    get => (string)GetValue(TextProperty);
    set => SetValue(TextProperty, value);
}

#endregion

```

4. In the XAML file, add two _Image_ elements which display images for two available states (on/off) and _Label_ element to display button text. Bind them with proper control's properties ( _OnStateSource_ , _OffStateSource_ , _Text_ ).

<highlight>5-34</highlight>

```xml
<ContentView xmlns="http://xamarin.com/schemas/2014/forms"
             xmlns:x="http://schemas.microsoft.com/winfx/2009/xaml"
             x:Class="BadgeCounter.Controls.ToggleButton"
             x:Name="Root">

    <ContentView.Content>
        <AbsoluteLayout WidthRequest="177"
                        HeightRequest="83">

            <!-- Image for "off" state -->
            <Image AbsoluteLayout.LayoutBounds="0, 0, 1, 1"
                       AbsoluteLayout.LayoutFlags="All"
                       Source="{Binding Source={x:Reference Root}, Path=OffStateSource}"
                       x:Name="OffStateImage"
                       Opacity="0" />

            <!-- Image for "on" state -->
            <Image AbsoluteLayout.LayoutBounds="0, 0, 1, 1"
                       AbsoluteLayout.LayoutFlags="All"
                       Source="{Binding Source={x:Reference Root}, Path=OnStateSource}"
                       x:Name="OnStateImage" />

            <!-- Button text -->
            <Label AbsoluteLayout.LayoutBounds="38, 34, 101, 32"
                   AbsoluteLayout.LayoutFlags="None"
                   Text="{Binding Source={x:Reference Root}, Path=Text}"
                   TextColor="White"
                   HorizontalTextAlignment="Center"
                   FontSize="4"
                   FontFamily="BreezeSans:style=Medium" />

        </AbsoluteLayout>
    </ContentView.Content>

</ContentView>

```

5. Add a method which synchronizes state of the images with the _Checked_ property. The appearance and animation of the control is based on changing images opacity so it updates only this value. Call the method in the control's constructor. It will be also used later.

<highlight>7, 10-19</highlight>

```csharp
/// <summary>
/// Creates instance of the control.
/// </summary>
public ToggleButton()
{
    InitializeComponent();
    SyncImagesWithState();
}

/// <summary>
/// Synchronizes images appearance with control's state.
/// The appearance of the control is based on changing images opacity
/// so it updates only this value.
/// </summary>
private void SyncImagesWithState()
{
    OffStateImage.Opacity = Checked ? 0 : 1;
    OnStateImage.Opacity = Checked ? 1 : 0;
}

```

6. Register handler for tap event.

<highlight>7, 22-40</highlight>

```csharp
/// <summary>
/// Creates instance of the control.
/// </summary>
public ToggleButton()
{
    InitializeComponent();
    InitializeEventsListeners();
    SyncImagesWithState();
}

/// <summary>
/// Synchronizes images appearance with control's state.
/// The appearance of the control is based on changing images opacity
/// so it updates only this value.
/// </summary>
private void SyncImagesWithState()
{
    OffStateImage.Opacity = Checked ? 0 : 1;
    OnStateImage.Opacity = Checked ? 1 : 0;
}

/// <summary>
/// Initializes event listeners of the control.
/// </summary>
private void InitializeEventsListeners()
{
    ((AbsoluteLayout)Content).GestureRecognizers.Add(new TapGestureRecognizer
    {
        Command = new Command(OnTapped)
    });
}

/// <summary>
/// Handles tap on the control body.
/// Performs tap animation (simple images morphing)
/// which finally results in toggling the control's state.
/// </summary>
private async void OnTapped()
{
}

```

7. Implement the tap event handler. It performs toggle state animation by fading images. If there is ongoing animation, it will do nothing.

<highlight>1-23, 32-38</highlight>

```csharp
/// <summary>
/// Performs the state change animation (simple images morphing).
/// </summary>
/// <param name="targetState">Animation direction (target state after animation completes).</param>
/// <returns>A task that represents the animation operation.</returns>
private Task AnimateStateChange(bool targetState)
{
    return Task.WhenAll(new List<Task>
    {
        OffStateImage.FadeTo(targetState ? 0 : 1, ANIMATION_TIME),
        OnStateImage.FadeTo(targetState ? 1 : 0, ANIMATION_TIME)
    });
}

/// <summary>
/// Returns true if state change animation is running, false otherwise.
/// </summary>
/// <returns>True in case of running animation, false otherwise.</returns>
private bool StateChangeAnimationIsRunning()
{
    return OnStateImage.AnimationIsRunning("FadeTo") ||
        OffStateImage.AnimationIsRunning("FadeTo");
}

/// <summary>
/// Handles tap on the control body.
/// Performs tap animation (simple images morphing)
/// which finally results in toggling the control's state.
/// </summary>
private async void OnTapped()
{
    if (StateChangeAnimationIsRunning())
    {
        return;
    }

    await AnimateStateChange(!Checked);
    Checked = !Checked;
}

```

8. Override _OnPropertyChanged_ handler in order to handle _Checked_ property change. This is important becuase state of the control may be changed not only by tapping the button but also by changing the value of mentioned property directly from code (two way binding). In this case, we do not perform animation (we even stop it if there is ongoing one) but only update the appearance of the control according to the current state of the property.

<highlight>1-8, 36-52</highlight>

```csharp
/// <summary>
/// Cancels the state change animation.
/// </summary>
private void CancelStateChangeAnimation()
{
    ViewExtensions.CancelAnimations(OffStateImage);
    ViewExtensions.CancelAnimations(OnStateImage);
}

/// <summary>
/// Returns true if state change animation is running, false otherwise.
/// </summary>
/// <returns>True in case of running animation, false otherwise.</returns>
private bool StateChangeAnimationIsRunning()
{
    return OnStateImage.AnimationIsRunning("FadeTo") ||
        OffStateImage.AnimationIsRunning("FadeTo");
}

/// <summary>
/// Handles tap on the control body.
/// Performs tap animation (simple images morphing)
/// which finally results in toggling the control's state.
/// </summary>
private async void OnTapped()
{
    if (StateChangeAnimationIsRunning())
    {
        return;
    }

    await AnimateStateChange(!Checked);
    Checked = !Checked;
}

/// <summary>
/// Handles bound property change.
/// If "Checked" property was changed, it updates the control's appearance.
/// This is crucial when state was changed by changing
/// the property directly (not by the user).
/// </summary>
/// <param name="propertyName">Name of the property which was changed.</param>
protected override void OnPropertyChanged(string propertyName = null)
{
    base.OnPropertyChanged(propertyName);

    if (propertyName == nameof(Checked))
    {
        CancelStateChangeAnimation();
        SyncImagesWithState();
    }
}

```

The custom control implementation is completed. Let's use it in the main view of the application.

9. In main page XAML file, add "TOGGLE AUTOINCREMENT" button using created control.

<highlight>7-12</highlight>

```xml
<!-- Plus button - increase badge counter -->
<controls:ImageButton AbsoluteLayout.LayoutBounds="249, 146, 60, 60"
                      AbsoluteLayout.LayoutFlags="None"
                      Source="images/normal_state_plus.png"
                      PressedSource="images/hover_state_plus.png" />

<!-- Toggle autoincrement button -->
<controls:ToggleButton AbsoluteLayout.LayoutBounds="92, 240, AutoSize, AutoSize"
                       AbsoluteLayout.LayoutFlags="None"
                       OffStateSource="images/toggle_off.png"
                       OnStateSource="images/toggle_on.png"
                       Text="TOGGLE AUTOINCREMENT" />

```

Right now the application can be run on the emulator or target device. When "TOGGLE AUTONCREMENT" button is tapped, it should toggle between two states (on/off) with animation.

<img src="/TizenSchool/assets/images/tutorials/106/badge-counter-toggle-button-1.png" style="height:544px; width:400px"/>

<img src="/TizenSchool/assets/images/tutorials/106/badge-counter-toggle-button-2.png" style="height:544px; width:400px"/>

## 5. Counter (custom control)

In this tutorial part we will create custom control for counter element. It is responsible for displaying numeric value and perfoming animation when the value changes. We will use it to display current value of the badge count.

Our new custom control (we will call it _Counter_ ) displays a circle (build from images) with the current value inside. The current value of the control can be get or set using the _Value_ bindable property.

The files for the control are already created (we need to fill them up):

1. In the code behind file, create constant for toggle animation time, maximum value and text displayed when value exceeds maximum value.

<highlight>2-18</highlight>

```csharp
#region fields

/// <summary>
/// Value change animation time (in milliseconds).
/// </summary>
private const int ANIMATION_TIME = 600;

/// <summary>
/// Maximum value which the control can display.
/// Everything above this value is displayed as "99+".
/// </summary>
private const int MAX_VALUE = 99;

/// <summary>
/// Text displayed when the counter value exceeds maximum value.
/// </summary>
private const string MAX_VALUE_EXCEEDED_TEXT = "99+";

#endregion

```

2. Add a private field which holds control's previous value (during animation).

<highlight>6-9</highlight>

```csharp
/// <summary>
/// Text displayed when the counter value exceeds maximum value.
/// </summary>
private const string MAX_VALUE_EXCEEDED_TEXT = "99+";

/// <summary>
/// Snapshot of previous value (available till animation end).
/// </summary>
private int _valueSnapshot = 0;

```

3. Create backing stores (definitions) for control's bindable properties.

<highlight>2-8</highlight>

```csharp
#region properties

/// <summary>
/// Bindable property definition for the counter value.
/// </summary>
public static readonly BindableProperty ValueProperty = BindableProperty.Create(
    "Value", typeof(int), typeof(Counter), 0);

#endregion

```

4. Define bindable properties accessors.

<highlight>7-14</highlight>

```csharp
/// <summary>
/// Bindable property definition for the counter value.
/// </summary>
public static readonly BindableProperty ValueProperty = BindableProperty.Create(
    "Value", typeof(int), typeof(Counter), 0);

/// <summary>
/// Counter value.
/// </summary>
public int Value
{
    get => (int)GetValue(ValueProperty);
    set => SetValue(ValueProperty, value);
}

```

5. In the XAML file, add two _Image_ elements for background and foreground of the control and two _Label_ elements to display and animate the value.

<highlight>5-50</highlight>

```xml
<?xml version="1.0" encoding="UTF-8"?>
<ContentView xmlns="http://xamarin.com/schemas/2014/forms"
             xmlns:x="http://schemas.microsoft.com/winfx/2009/xaml"
             x:Class="BadgeCounter.Controls.Counter">

    <ContentView.Content>
        <AbsoluteLayout WidthRequest="46"
                        HeightRequest="46">

            <!-- Counter background image -->
            <Image AbsoluteLayout.LayoutBounds="0, 0, 1, 1"
                   AbsoluteLayout.LayoutFlags="All"
                   Source="images/counter_background.png"
                   x:Name="PressedSourceImage" />

            <!-- Container to prevent labels going out of the control's bounds during animation -->
            <AbsoluteLayout AbsoluteLayout.LayoutBounds="0, 0, 1, 1"
                            AbsoluteLayout.LayoutFlags="All"
                            Margin="5">

                <!-- Label for current value (animation) -->
                <Label AbsoluteLayout.LayoutBounds="0, 0, 1, 1"
                       AbsoluteLayout.LayoutFlags="All"
                       FontSize="6"
                       FontFamily="BreezeSans:style=Bold"
                       TextColor="White"
                       VerticalTextAlignment="Center"
                       HorizontalTextAlignment="Center"
                       x:Name="CurrentLabel" />

                <!-- Label for next value (animation) -->
                <Label AbsoluteLayout.LayoutBounds="0, 0, 1, 1"
                       AbsoluteLayout.LayoutFlags="All"
                       FontSize="6"
                       FontFamily="BreezeSans:style=Bold"
                       TextColor="White"
                       VerticalTextAlignment="Center"
                       HorizontalTextAlignment="Center"
                       x:Name="NextLabel" />

            </AbsoluteLayout>

            <!-- Counter foreground image -->
            <Image AbsoluteLayout.LayoutBounds="0, 0, 1, 1"
                   AbsoluteLayout.LayoutFlags="All"
                   Source="images/counter_alpha_frame.png" />

        </AbsoluteLayout>
    </ContentView.Content>

</ContentView>

```

6. Add a method which will format text displayed in the control. It returns "99+" when value exceeds maximum value and adds preceding zero if value is range 0-9.

<highlight>9-23</highlight>

```csharp
/// <summary>
/// Creates the control instance.
/// </summary>
public Counter()
{
    InitializeComponent();
}

/// <summary>
/// Formats text displayed in the control.
/// </summary>
/// <param name="value">Counter value.</param>
/// <returns>Formatted value.</returns>
private string FormatValue(int value)
{
    if (value > MAX_VALUE)
    {
        return MAX_VALUE_EXCEEDED_TEXT;
    }

    // precede with 0 in case of 0-9
    return value.ToString("D2");
}

```

7. Add a method which updates value dispalyed in the control (labels). Call it in the constructor.

<highlight>7-8, 27-36</highlight>

```csharp
/// <summary>
/// Creates the control instance.
/// </summary>
public Counter()
{
    InitializeComponent();
    SyncLabelsWithValue();
    _valueSnapshot = Value;
}

/// <summary>
/// Formats text displayed in the control.
/// </summary>
/// <param name="value">Counter value.</param>
/// <returns>Formatted value.</returns>
private string FormatValue(int value)
{
    if (value > MAX_VALUE)
    {
        return MAX_VALUE_EXCEEDED_TEXT;
    }

    // precede with 0 in case of 0-9
    return value.ToString("D2");
}

/// <summary>
/// Synchronizes text displayed in control's labels with the counter value.
/// </summary>
private void SyncLabelsWithValue()
{
    CurrentLabel.TranslationX = 0;
    CurrentLabel.Text = FormatValue(Value);
    NextLabel.TranslationX = 0;
    NextLabel.Text = FormatValue(Value);
}

```

8. Add a method which performs animation and a method which provides information if animation is running. The first one uses simple image translation (moving images from right or to left) to create animation effect.

<highlight>12-53</highlight>

```csharp
/// <summary>
/// Synchronizes text displayed in control's labels with the counter value.
/// </summary>
private void SyncLabelsWithValue()
{
    CurrentLabel.TranslationX = 0;
    CurrentLabel.Text = FormatValue(Value);
    NextLabel.TranslationX = 0;
    NextLabel.Text = FormatValue(Value);
}

/// <summary>
/// Returns true if value change animation is running, false otherwise.
/// </summary>
/// <returns>True in case of running animation, false otherwise.</returns>
private bool ValueChangeAnimationIsRunning()
{
    return CurrentLabel.AnimationIsRunning("TranslateTo") ||
        NextLabel.AnimationIsRunning("TranslateTo");
}

/// <summary>
/// Animates counter value change.
/// The animation consists in smooth entering of next value
/// from the left or from the right.
/// </summary>
/// <returns>A task that represents the animation operation.</returns>
private async Task AnimateValueChange()
{
    // both labels have the same width, take one of them
    double width = CurrentLabel.Width;

    // if animation is running, just update displayed values
    if (ValueChangeAnimationIsRunning())
    {
        NextLabel.Text = FormatValue(Value);
        CurrentLabel.Text = FormatValue(_valueSnapshot);
        return;
    }

    // make sure that labels are at proper start position
    NextLabel.TranslationX = Value > _valueSnapshot ? width : -width;
    NextLabel.Text = FormatValue(Value);
    CurrentLabel.TranslationX = 0;
    CurrentLabel.Text = FormatValue(_valueSnapshot);

    // start animation
    await Task.WhenAll(new List<Task>
    {
        CurrentLabel.TranslateTo(Value > _valueSnapshot ? -width : width, 0, ANIMATION_TIME),
        NextLabel.TranslateTo(0, 0, ANIMATION_TIME)
    });
}

```

9. Add property changed handler. It will handle "Value" property change case by updating control's UI and triggering animation if it is necessary.

<highlight>34-54</highlight>

```csharp
/// <summary>
/// Animates counter value change.
/// The animation consists in smooth entering of next value
/// from the left or from the right.
/// </summary>
/// <returns>A task that represents the animation operation.</returns>
private async Task AnimateValueChange()
{
    // both labels have the same width, take one of them
    double width = CurrentLabel.Width;

    // if animation is running, just update displayed values
    if (ValueChangeAnimationIsRunning())
    {
        NextLabel.Text = FormatValue(Value);
        CurrentLabel.Text = FormatValue(_valueSnapshot);
        return;
    }

    // make sure that labels are at proper start position
    NextLabel.TranslationX = Value > _valueSnapshot ? width : -width;
    NextLabel.Text = FormatValue(Value);
    CurrentLabel.TranslationX = 0;
    CurrentLabel.Text = FormatValue(_valueSnapshot);

    // start animation
    await Task.WhenAll(new List<Task>
    {
        CurrentLabel.TranslateTo(Value > _valueSnapshot ? -width : width, 0, ANIMATION_TIME),
        NextLabel.TranslateTo(0, 0, ANIMATION_TIME)
    });
}

/// <summary>
/// Handles bound property change.
/// If "Value" property was changed, it updates the control's appearance.
/// Value change animation is performed if value does not exceed the maximum supported value.
/// </summary>
/// <param name="propertyName">Name of the property which was changed.</param>
protected override async void OnPropertyChanged(string propertyName = null)
{
    base.OnPropertyChanged(propertyName);

    if (propertyName == nameof(Value))
    {
        if (Value <= MAX_VALUE || _valueSnapshot <= MAX_VALUE)
        {
            await AnimateValueChange();
        }

        _valueSnapshot = Value;
        SyncLabelsWithValue();
    }
}

```

9. In main page XAML file, add a badge counter element using created control.

<highlight>7-10</highlight>

```xml
<!-- Icon under the counter - Reset button -->
<Image AbsoluteLayout.LayoutBounds="128, 118, 104, 104"
       AbsoluteLayout.LayoutFlags="None"
       Source="images/app_icon.png">
</Image>

<!-- Current value of the badge counter -->
<controls:Counter AbsoluteLayout.LayoutBounds="196, 114, AutoSize, AutoSize"
                  AbsoluteLayout.LayoutFlags="None"
                  Value="10" />

```

Right now the application can be run on the emulator or target device. The counter is displyed in the top right corner of reset button. For now it displays static value (10). Animation will be visible when we implement increase and decrease buttons logic.

<img src="/TizenSchool/assets/images/tutorials/106/badge-counter-counter-1.png" style="height:544px; width:400px"/>

# III. APPLICATION MODEL

## 1. Goal

The goal of this chapter is to implement model layer of the application. It will provide methods and properties to get and set current value of badge count, as well as turn on/off the auto-incrementation.

First, we will implement service which will handle platform dependant logic. After that we will implement the actual model class. So, let's begin.

## 2. The badge control service

In this tutorial part we will create a service for the application model.

A service in architecture we used is a part of the model which implements platform depenedant features. If it implements things that varies from platform to platform, we cannot place it in the portable project. We will implement it in the platform specific project ( _BadgeCounter.Tizen.Wearable_ ).

The model class will obtain reference to the service using **Dependency Injection** ( _DependencyService_ class from _Xamarin Forms_ library). In order to be able to do that, in portable project, the service interface must be specified. The service in platform specific project will implement it.

The service interface is already created in the base code we provided ( _BadgeCounter\Models\IBadgeControlService.cs_ ). It is quite simple. There are only one property to get and set the value of badge count and one event notifying that this value changed.

```csharp
using System;

namespace BadgeCounter.Models
{
    /// <summary>
    /// Interface of services which allow to manage badge count for current application.
    /// </summary>
    public interface ICurrentAppBadgeControlService
    {
        #region properties

        /// <summary>
        /// Badge count for current application.
        /// </summary>
        int BadgeCount { get; set; }

        /// <summary>
        /// Event invoked when badge count for current application was changed.
        /// </summary>
        event EventHandler Changed;

        #endregion
    }
}
```

The actual service will be implemented in _BadgeCounter.Tizen.Wearable\Services\CurrentAppBadgeControlService.cs_ file. We will use _Tizen.Applications_ API.

1. Modify the class declaration so it implements a service interface we prepared.

<highlight>11, 17-27</highlight>

```csharp
using System;
using BadgeCounter.Models;
using BadgeCounter.Tizen.Wearable.Services;
using global::Tizen.Applications;

namespace BadgeCounter.Tizen.Wearable.Services
{
    /// <summary>
    /// Service which allows to manage badge count for current application.
    /// </summary>
    class CurrentAppBadgeControlService : ICurrentAppBadgeControlService
    {
        #region fields
        #endregion

        #region properties

        /// <summary>
        /// Badge count for current application.
        /// </summary>
        public int BadgeCount { get; set; }

        /// <summary>
        /// Event invoked when badge count for current application was changed.
        /// </summary>
        public event EventHandler Changed;

        #endregion

        #region methods

        /// <summary>
        /// Creates instance of the service.
        /// </summary>
        public CurrentAppBadgeControlService()
        {
        }

        #endregion
    }
}

```

2. Register our service in
   `DependencyService`
   via a metadata attribute. Registration enables
   `DependencyService`
   to find the implementing class and supply it in place of the interface at run time.

<highlight>6</highlight>

```csharp
using System;
using BadgeCounter.Models;
using BadgeCounter.Tizen.Wearable.Services;
using global::Tizen.Applications;

[assembly: Xamarin.Forms.Dependency(typeof(CurrentAppBadgeControlService))]

namespace BadgeCounter.Tizen.Wearable.Services

```

3. Add a private fields which store current application identifier and corresponding badge information object.

<highlight>2-13</highlight>

```csharp
#region fields

/// <summary>
/// Identifier of current application.
/// Required to find and change badge count for it.
/// </summary>
private string _currentAppId;

/// <summary>
/// Badge information for current application.
/// </summary>
private Badge _currentAppBadge;

#endregion

```

4. In the service constructor, obtain reference to badge object containing information about current value of the counter. Add listener to badge information change.

<highlight>8-21, 24-32</highlight>

```csharp
#region methods

/// <summary>
/// Creates instance of the service.
/// </summary>
public CurrentAppBadgeControlService()
{
    _currentAppId = Application.Current.ApplicationInfo.ApplicationId;

    // try to find existing badge instance, if not exist create new one
    try
    {
        _currentAppBadge = BadgeControl.Find(_currentAppId);
    }
    catch (InvalidOperationException)
    {
        _currentAppBadge = new Badge(_currentAppId, count: 0, visible: true);
        BadgeControl.Add(_currentAppBadge);
    }

    BadgeControl.Changed += OnBadgeChanged;
}

/// <summary>
/// Handles badge changes events.
/// Filters for current application badge change and invokes own (service) event.
/// </summary>
/// <param name="sender">Event sender.</param>
/// <param name="e">Event arguments.</param>
private void OnBadgeChanged(object sender, BadgeEventArgs e)
{
}

#endregion

```

5. Implement BadgeCount property getter and setter using obtained badge object.

<highlight>6-16</highlight>

```csharp
/// <summary>
/// Badge count for current application.
/// </summary>
public int BadgeCount
{
    get => _currentAppBadge == null ? 0 : _currentAppBadge.Count;
    set
    {
        if (_currentAppBadge == null)
        {
            return;
        }

        _currentAppBadge.Count = value;
        BadgeControl.Update(_currentAppBadge);
    }
}

```

6. Implement _OnBadgeChanged_ handler. If current application badge count was changed, update local badge object and invoke service event.

<highlight>9-15</highlight>

```csharp
/// <summary>
/// Handles badge changes events.
/// Filters for current application badge change and invokes own (service) event.
/// </summary>
/// <param name="sender">Event sender.</param>
/// <param name="e">Event arguments.</param>
private void OnBadgeChanged(object sender, BadgeEventArgs e)
{
    if (e.Badge.AppId != _currentAppId)
    {
        return;
    }

    _currentAppBadge = e.Badge;
    Changed?.Invoke(this, new EventArgs());
}

```

Now, when the service is ready, we can proceed to implementing the model class.

## 3. The badge counter model

In this tutorial part we will create a model for the application. The model class allows to read and change the value of the application badge count. It also provides an event which notifies about value changes. Additionally it allows to turn on/off the auto-incrementation.

We will modify _BadgeCounter\Model\BadgeCounterModel.cs_ file.

1. Add a private field to store service instance.

<highlight>2-7</highlight>

```csharp
#region fields

/// <summary>
/// Service which allows to manage badge count for current application.
/// </summary>
private ICurrentAppBadgeControlService _badgeControlService;

#endregion

```

2. Obtain service instance using _DependencyService_ class. Register a listener to badge count value change.

<highlight>8-9, 12-21</highlight>

```csharp
#region methods

/// <summary>
/// Creates instance of the model.
/// </summary>
public BadgeCounterModel()
{
    _badgeControlService = DependencyService.Get<ICurrentAppBadgeControlService>();
    _badgeControlService.Changed += OnBadgeCountChanged;
}

/// <summary>
/// Handles change of the badge count for current application.
/// Invokes own (model) event.
/// </summary>
/// <param name="sender">Event sender (service).</param>
/// <param name="e">Event arguments.</param>
private void OnBadgeCountChanged(object sender, EventArgs e)
{

}

#endregion

```

3. Add a property which allow to read and change the value of the badge count. It uses the service directly.

<highlight>2-11</highlight>

```csharp
#region properties

/// <summary>
/// Current value of the badge counter.
/// </summary>
public int Value
{
    get => _badgeControlService.BadgeCount;
    set => _badgeControlService.BadgeCount = value;
}

#endregion

```

4. Add an event which will be invoked when badge count value changes.

<highlight>10-13</highlight>

```csharp
/// <summary>
/// Current value of the badge counter.
/// </summary>
public int Value
{
    get => _badgeControlService.BadgeCount;
    set => _badgeControlService.BadgeCount = value;
}

/// <summary>
/// Event invoked when badge counter value was changed.
/// </summary>
public event EventHandler Changed;

```

5. Invoke created event in _OnBadgeCountChanged_ method.

<highlight>9</highlight>

```csharp
/// <summary>
/// Handles change of the badge count for current application.
/// Invokes own (model) event.
/// </summary>
/// <param name="sender">Event sender (service).</param>
/// <param name="e">Event arguments.</param>
private void OnBadgeCountChanged(object sender, EventArgs e)
{
    Changed?.Invoke(this, new EventArgs());
}

```

6. Add a constant with default value of the badge count.

<highlight>3-7</highlight>

```csharp
#region fields

/// <summary>
/// Default value of the badge counter.
/// Used to reset the value.
/// </summary>
private static readonly int DEFAULT_VALUE = 0;

/// <summary>
/// Service which allows to manage badge count for current application.
/// </summary>
private ICurrentAppBadgeControlService _badgeControlService;

#endregion

```

7. Add a _Reset_ method. It will reset the badge counter to default value. Use created constant.

<highlight>12-18</highlight>

```csharp
/// <summary>
/// Handles change of the badge count for current application.
/// Invokes own (model) event.
/// </summary>
/// <param name="sender">Event sender (service).</param>
/// <param name="e">Event arguments.</param>
private void OnBadgeCountChanged(object sender, EventArgs e)
{
    Changed?.Invoke(this, new EventArgs());
}

/// <summary>
/// Resets the badge counter to default value.
/// </summary>
public void Reset()
{
    Value = DEFAULT_VALUE;
}

```

8. Add a constant for auto-increment feature interval (milliseconds) and a backing field for _AutoIncrement_ property.

<highlight>9-12, 19-23</highlight>

```csharp
#region fields

/// <summary>
/// Default value of the badge counter.
/// Used to reset the value.
/// </summary>
private static readonly int DEFAULT_VALUE = 0;

/// <summary>
/// Interval for auto-increment feature (in milliseconds).
/// </summary>
private static readonly int AUTOINCREMENT_INTERVAL = 1500;

/// <summary>
/// Service which allows to manage badge count for current application.
/// </summary>
private ICurrentAppBadgeControlService _badgeControlService;

/// <summary>
/// Backing field for "AutoIncrement" property.
/// Indicates if auto-increment feature is enabled.
/// </summary>
private bool _autoIncrement = false;

#endregion

```

9. Implement AutoIncrement property. It will turn on/off the auto-incrementation by creating and destroying the timer which increments the timer.

<highlight>10-44</highlight>

```csharp
/// <summary>
/// Current value of the badge counter.
/// </summary>
public int Value
{
    get => _badgeControlService.BadgeCount;
    set => _badgeControlService.BadgeCount = value;
}

/// <summary>
/// Indicates if auto-increment feature is enabled.
/// If so, the badge counter is automatically incremented using defined interval.
/// </summary>
public bool AutoIncrement
{
    get => _autoIncrement;
    set
    {
        if (value == _autoIncrement)
        {
            return;
        }

        _autoIncrement = value;

        // start timer (using defined interval) which increase badge counter value
        if (_autoIncrement)
        {
            Device.StartTimer(TimeSpan.FromMilliseconds(AUTOINCREMENT_INTERVAL), () =>
            {
                if (AutoIncrement)
                {
                    Value++;

                    // return true to keep timer running
                    return true;
                }

                // return false to stop the timer
                return false;
            });
        }
    }
}

```

Now, the model layer is ready. We can proceed to linking view and model layers by implementing view-model layer.

# IV. APPLICATION LOGIC

## 1. Goal

The goal of this chapter is to implement logic for all user interface elements (counter and all buttons). We will write a lot of code for view-model layer (abstraction of the view) and utilize application model which have been created in previous chapter.

So, let's begin.

## 2. Counter element logic

In this tutorial part we will make the counter element start displaying real values (from model).

To do that, we need to create a property in view-model which provides current badge count value for view layer. After that we will bind this value with proper property of _Counter_ custom control instance (XAML).

We will modify _BadgeCounter\ViewModels\MainViewModel.cs_ and _BadgeCounter\Views\MainPage.xaml_ files.

1. In view-model file, create private field which will store reference to application model.

<highlight>2-8</highlight>

```csharp
#region fields

/// <summary>
/// Instance of badge counter model.
/// Allows to manage badge counter for current application.
/// </summary>
private BadgeCounterModel _badgeCounterModel;

#endregion

```

2. Create instance of the application model and register _Changed_ event listener.

<highlight>8-9, 12-20</highlight>

```csharp
#region methods

/// <summary>
/// Creates instance of the view model.
/// </summary>
public MainViewModel()
{
    _badgeCounterModel = new BadgeCounterModel();
    _badgeCounterModel.Changed += OnBadgeCounterModelChanged;
}

/// <summary>
/// Handles "Changed" event of badge counter model.
/// Notifies about update of badge counter value.
/// </summary>
/// <param name="sender">Event sender.</param>
/// <param name="e">Event arguments.</param>
private void OnBadgeCounterModelChanged(object sender, EventArgs e)
{
}

#endregion

```

3. Create _BadgeCounterValue_ property. It will get and set the value by directly accessing the application model.

<highlight>2-11</highlight>

```csharp
#region properties

/// <summary>
/// Current value of the badge counter.
/// </summary>
public int BadgeCounterValue
{
    get => _badgeCounterModel.Value;
    set => _badgeCounterModel.Value = value;
}

#endregion

```

4. Implement _Changed_ event listener method. It will notify that _BadgeCounterValue_ property has been changed. It will allow the view layer to update itself (binding).

<highlight>9</highlight>

```csharp
/// <summary>
/// Handles "Changed" event of badge counter model.
/// Notifies about update of badge counter value.
/// </summary>
/// <param name="sender">Event sender.</param>
/// <param name="e">Event arguments.</param>
private void OnBadgeCounterModelChanged(object sender, EventArgs e)
{
    OnPropertyChanged(nameof(BadgeCounterValue));
}

```

5. In _MainPage.xaml_ file, create binding between Value property of Counter control instance and BadgeCounterValue property of the view-model.

<highlight>4</highlight>

```xml
<!-- Current value of the badge counter -->
<controls:Counter AbsoluteLayout.LayoutBounds="196, 114, AutoSize, AutoSize"
                  AbsoluteLayout.LayoutFlags="None"
                  Value="{Binding BadgeCounterValue}" />

```

Right now the application can be run on the emulator or target device. The value displayed in the counter element is no longer static. Now, it shows current value of the application badge count.

<img src="/TizenSchool/assets/images/tutorials/106/badge-counter-counter-logic.png" style="height:544px; width:400px"/>

## 3. Increase/decrease buttons logic

In this tutorial part we will make _Increase_ and _Decrease_ buttons work. We will accomplish that by creating corresponding commands in view-model and binding them with these buttons actions.

We will modify _BadgeCounter\ViewModels\MainViewModel.cs_ and _BadgeCounter\Views\MainPage.xaml_ files.

1.  In view-model file, create public properties for increase and decrease commands.

<highlight>10-18</highlight>

```csharp
/// <summary>
/// Current value of the badge counter.
/// </summary>
public int BadgeCounterValue
{
    get => _badgeCounterModel.Value;
    set => _badgeCounterModel.Value = value;
}

/// <summary>
/// Increases the badge counter value by one.
/// </summary>
public ICommand IncreaseCommand { get; }

/// <summary>
/// Decreases the badge counter value by one.
/// </summary>
public ICommand DecreaseCommand { get; }

```

2. Initialize created commands ( _Command_ class). The _DecreaseCommand_ provides also a method which returns boolean indicating if this command can be executed.

<highlight>9-10, 24-47</highlight>

```csharp
/// <summary>
/// Creates instance of the view model.
/// </summary>
public MainViewModel()
{
    _badgeCounterModel = new BadgeCounterModel();
    _badgeCounterModel.Changed += OnBadgeCounterModelChanged;

    IncreaseCommand = new Command(ExecuteIncreaseCommand);
    DecreaseCommand = new Command(ExecuteDecreaseCommand, CanExecuteDecrease);
}

/// <summary>
/// Handles "Changed" event of badge counter model.
/// Notifies about update of badge counter value.
/// </summary>
/// <param name="sender">Event sender.</param>
/// <param name="e">Event arguments.</param>
private void OnBadgeCounterModelChanged(object sender, EventArgs e)
{
    OnPropertyChanged(nameof(BadgeCounterValue));
}

/// <summary>
/// Handles execution of the "IncreaseCommand" command.
/// Increases value of the badge counter by one.
/// </summary>
private void ExecuteIncreaseCommand()
{
}

/// <summary>
/// Handles execution of the "DecreaseCommand" command.
/// Decreases value of the badge counter by one.
/// </summary>
private void ExecuteDecreaseCommand()
{
}

/// <summary>
/// Returns true if "DecreaseCommand" can be executed, false otherwise.
/// </summary>
/// <returns>True if "DecreaseCommand" can be executed.</returns>
private bool CanExecuteDecrease()
{
    return false;
}

```

3. Implement _IncreaseCommand_ execution handler. It will just increment the _BadgeCounterValue_ property.

<highlight>7</highlight>

```csharp
/// <summary>
/// Handles execution of the "IncreaseCommand" command.
/// Increases value of the badge counter by one.
/// </summary>
private void ExecuteIncreaseCommand()
{
    BadgeCounterValue++;
}

```

4. Implement _DecreaseCommand_ execution handler. It will do nothing if current badge count value is zero, otherwise it will decrement the _BadgeCounterValue_ property.

<highlight>7-12</highlight>

```csharp
/// <summary>
/// Handles execution of the "DecreaseCommand" command.
/// Decreases value of the badge counter by one.
/// </summary>
private void ExecuteDecreaseCommand()
{
    if (BadgeCounterValue == 0)
    {
        return;
    }

    BadgeCounterValue--;
}

```

5. Implement _CanExecuteDecrease_ method. It should return true only if current badge count value is greater than 0.

<highlight>7</highlight>

```csharp
/// <summary>
/// Returns true if "DecreaseCommand" can be executed, false otherwise.
/// </summary>
/// <returns>True if "DecreaseCommand" can be executed.</returns>
private bool CanExecuteDecrease()
{
    return BadgeCounterValue > 0;
}

```

6. Add calling ChangeCanExecute of DecreaseCommand when model changes. This will call CanExecute again, and then enable itself based on the return value of that method.

<highlight>10</highlight>

```csharp
/// <summary>
/// Handles "Changed" event of badge counter model.
/// Notifies about update of badge counter value.
/// </summary>
/// <param name="sender">Event sender.</param>
/// <param name="e">Event arguments.</param>
private void OnBadgeCounterModelChanged(object sender, EventArgs e)
{
    OnPropertyChanged(nameof(BadgeCounterValue));
    ((Command)DecreaseCommand).ChangeCanExecute();
}

```

7. In _MainPage.xaml_ file, bind _Command_ properties (button default action) of "decrease" and "increase" buttons ( _ImageButton_ control) with created commands from the view-model.

<highlight>6, 13</highlight>

```xml
<!-- Minus button - decrease badge counter -->
<controls:ImageButton AbsoluteLayout.LayoutBounds="51, 146, 60, 60"
                      AbsoluteLayout.LayoutFlags="None"
                      Source="images/normal_state_minus.png"
                      PressedSource="images/hover_state_minus.png"
                      Command="{Binding DecreaseCommand}" />

<!-- Plus button - increase badge counter -->
<controls:ImageButton AbsoluteLayout.LayoutBounds="249, 146, 60, 60"
                      AbsoluteLayout.LayoutFlags="None"
                      Source="images/normal_state_plus.png"
                      PressedSource="images/hover_state_plus.png"
                      Command="{Binding IncreaseCommand}" />

```

Right now the application can be run on the emulator or target device. By pressing "decrease" and "increase" buttons we should be able to modify value of application badge count.

## 4. Auto-increment button logic

In this tutorial part we will make the auto-increment button work. We will accomplish that by creating corresponding boolean property in view-model and binding it with  _Checked_ property of toggle-autoincrement button.

We will modify _BadgeCounter\ViewModels\MainViewModel.cs_ and _BadgeCounter\Views\MainPage.xaml_ files.

1. In view-model file, create public _AutoIncrement_ property. It will get and set the value by directly accessing the application model.

<highlight>10-26</highlight>

```csharp
/// <summary>
/// Current value of the badge counter.
/// </summary>
public int BadgeCounterValue
{
    get => _badgeCounterModel.Value;
    set => _badgeCounterModel.Value = value;
}

/// <summary>
/// Indicates if badge counter auto-increment feature in turned on.
/// </summary>
public bool AutoIncrement
{
    get => _badgeCounterModel.AutoIncrement;
    set
    {
        if (value == AutoIncrement)
        {
            return;
        }

        _badgeCounterModel.AutoIncrement = value;
        OnPropertyChanged();
    }
}

```

2. In _MainPage.xaml_ file, bind _Checked_ property of "TOGGLE AUTOINCREMENT" button ( _ToggleButton_ control) with created property from the view-model.

<highlight>6-7</highlight>

```xml
<!-- Toggle autoincrement button -->
<controls:ToggleButton AbsoluteLayout.LayoutBounds="92, 240, AutoSize, AutoSize"
                       AbsoluteLayout.LayoutFlags="None"
                       OffStateSource="images/toggle_off.png"
                       OnStateSource="images/toggle_on.png"
                       Text="TOGGLE AUTOINCREMENT"
                       Checked="{Binding AutoIncrement}" />

```

Right now the application can be run on the emulator or target device. Pressing "TOGGLE AUTOINCREMENT" button should result with turning on/off the auto-incrementation of application badge count.

## 5. Reset button logic

In this tutorial part we will make _Reset_ button work. We will accomplish that by creating corresponding command in view-model and binding it with tap gesture recognizer of image representing _Reset_ button.

We will modify _BadgeCounter\ViewModels\MainViewModel.cs_ and _BadgeCounter\Views\MainPage.xaml_ files.

1. In view-model file, create _ResetCommand_ property.

<highlight>6-9</highlight>

```csharp
/// <summary>
/// Decreases the badge counter value by one.
/// </summary>
public ICommand DecreaseCommand { get; }

/// <summary>
/// Resets the badge counter to default value.
/// </summary>
public ICommand ResetCommand { get; }

```

2. Initialize created command (with empty execution handler for now).

<highlight>11, 57-63</highlight>

```csharp
/// <summary>
/// Creates instance of the view model.
/// </summary>
public MainViewModel()
{
    _badgeCounterModel = new BadgeCounterModel();
    _badgeCounterModel.Changed += OnBadgeCounterModelChanged;

    IncreaseCommand = new Command(ExecuteIncreaseCommand);
    DecreaseCommand = new Command(ExecuteDecreaseCommand, CanExecuteDecrease);
    ResetCommand = new Command(ExecuteResetCommand);
}

/// <summary>
/// Handles "Changed" event of badge counter model.
/// Notifies about update of badge counter value.
/// </summary>
/// <param name="sender">Event sender.</param>
/// <param name="e">Event arguments.</param>
private void OnBadgeCounterModelChanged(object sender, EventArgs e)
{
    OnPropertyChanged(nameof(BadgeCounterValue));
}

/// <summary>
/// Handles execution of the "IncreaseCommand" command.
/// Increases value of the badge counter by one.
/// </summary>
private void ExecuteIncreaseCommand()
{
    BadgeCounterValue++;
}

/// <summary>
/// Handles execution of the "DecreaseCommand" command.
/// Decreases value of the badge counter by one.
/// </summary>
private void ExecuteDecreaseCommand()
{
    if (BadgeCounterValue == 0)
    {
        return;
    }

    BadgeCounterValue--;
}

/// <summary>
/// Returns true if "DecreaseCommand" can be executed, false otherwise.
/// </summary>
/// <returns>True if "DecreaseCommand" can be executed.</returns>
private bool CanExecuteDecrease()
{
    return BadgeCounterValue > 0;
}

/// <summary>
/// Handles execution of the "ResetCommand" command.
/// Calls model to reset badge counter to default value.
/// </summary>
private void ExecuteResetCommand()
{
}

```

3. Implement the command's execution handler by calling directly the model ( _Reset_ method).

<highlight>7</highlight>

```csharp
/// <summary>
/// Handles execution of the "ResetCommand" command.
/// Calls model to reset badge counter to default value.
/// </summary>
private void ExecuteResetCommand()
{
    _badgeCounterModel.Reset();
}

```

4. In _MainPage.xaml_ file, bind created command with image representing _Reset_ button using tap gesture recognizer.

<highlight>5-7</highlight>

```xml
<!-- Icon under the counter - Reset button -->
<Image AbsoluteLayout.LayoutBounds="128, 118, 104, 104"
       AbsoluteLayout.LayoutFlags="None"
       Source="images/app_icon.png">
    <Image.GestureRecognizers>
        <TapGestureRecognizer Command="{Binding ResetCommand}" />
    </Image.GestureRecognizers>
</Image>

```

Right now the application can be run on the emulator or target device. Reset button (application icon in the middle of the screen) should change the badge count value to zero.

<img src="/TizenSchool/assets/images/tutorials/106/badge-counter-reset-button-logic.png" style="height:544px; width:400px"/>

The reset button was last thing that we had to do. The application is now fully functional. Enjoy it.
