---
layout: ../../layouts/tutorial/TextTutorial.astro
title: 'How to create "Music Player" App'
description: "The Music Player application demonstrates how to display and play music using Tizen Media Content and Player APIs."
created: "2018/07/14"
modified: "2018/10/15"
profile: ["tv"]
type: "dotnet"
level: 3
state: "open"
thumbnail: "/assets/images/tutorials/108/ThumbnailMusicPlayerTV.png"
---

# I. Introduction

## 1. Overview

In this tutorial, we will create a Music Player application which will use Tizen Media Content and Player APIs to take information about tracks from device and to play them on TV.

The final version of the application consists of 3 pages:

The **Welcome Page** is displayed at the application startup and it is visible only once per application run.

It contains the “Get started” button which navigates to the Soundtrack List Page.

<img src="/assets/images/tutorials/108/welcome_page.png" style="height:480px; width:853px"/>

The **Soundtrack List Page** displays the list of tracks with basic information about them - covers, titles, albums and artists names.

It is possible to select the track and navigate to **Preview Page** by pressing the big cover at the left side of the screen.

<img src="/assets/images/tutorials/108/soundtrack_list_page_2.png" style="height:480px; width:853px"/>

The **Preview Page** displays the information about the track as well as its duration and current position of the playback in time in the form of progress bar and label.

It allows also to manage the playback - play or pause the track, rewind or forward the track as well as change the track to next or previous one.

Going back to  **Soundtrack List Page** is performed by pressing the back button on remote.

<img src="/assets/images/tutorials/108/_preview_page.png" style="height:480px; width:853px"/>



Content of this tutorial is under [Flora](http://floralicense.org/license) license.

## 2. Base code

The goal of **Soundtrack List Page** is to:

<img src="/assets/images/tutorials/108/soundtrack_list_page_2.png" style="height:480px; width:853px"/>

## 3. Track model

To import the project which will be explained in this tutorial, download the [base code](https://s3-us-west-1.amazonaws.com/tizenschool/108/MusicPlayer.zip), and refer to this [tutorial](http://tizenschool.org/tutorial/110/contents/1), which will explain how to import project to the Visual Studio.

Application source code has been organized in such way, that it is possible to easily expand to other platforms and devices.

<img src="/assets/images/tutorials/108/application_structure.PNG" style="height:480px; width:312px"/>

As you can see the main solution is divided into two parts:

To access platform specific part from the portable part the **DependencyService** mechanism is used - portable part uses interfaces to perform an actions on objects, which by DependencyService are directed to the proper implementation for platform specific part.



The base code already contains the **Welcome Page** , which briefly describes the purpose of this application as well as all of the classes which will be used later, however classes are not implemented yet, except those related to navigation and base for ViewModels implementing **INotifyPropertyChanged** interface. There are also present the bodies of interfaces which will be used to implement the native functionalities and the Track model, which just represents the single track present on the device.

# II. Soundtrack List View

## 1. Goal

Application consists of 2 pages - **Soundtracks List Page** and **Preview Page** . Both of them utilizes almost the same properties, that's why application will use only one ViewModel - **MainViewModel** , which will be shared by both views.



The first step in our application will be displaying the basic information about the current track at the left side of the **Soundtracks List Page** . To achieve this goal firstly add the property to the ViewModel and initialize it, so it can be used in a View.



_MusicPlayer/ViewModels/ **MainViewModel** .cs_

<highlight>5-8,20</highlight>

```csharp
#region properties

...

/// <summary>
/// Gets current track.
/// </summary>
public Track CurrentTrack { get; }

#endregion

#region methods

/// <summary>
/// The view model constructor.
/// </summary>
public MainViewModel()
{
    _navigation = DependencyService.Get<IViewNavigation>();
    CurrentTrack = new Track("Title", "Artist", "Album", null, "somepath", 0);
    InitCommands();
}

...

#endregion
```

This is only temporary solution, because later the **_CurrentTrack_** will be initialized and provided by the **PlayerModel** , current code is only the way to test our view if it properly displays information about the track.



_MusicPlayer/Views/ **SoundtracksListPage** .xaml_

<highlight>3-14</highlight>

```xml
...
<ContentPage.Content>
    <Grid>
        <Grid.RowDefinitions>
            <RowDefinition Height="406" />
            <RowDefinition Height="*" />
        </Grid.RowDefinitions>
        <Grid.ColumnDefinitions>
            <ColumnDefinition Width="96" />
            <ColumnDefinition Width="406" />
            <ColumnDefinition Width="60" />
            <ColumnDefinition Width="1420" />
        </Grid.ColumnDefinitions>
    </Grid>
</ContentPage.Content>
...
```

Tha base layout of our view will be the **Grid** . It enables easy elements placement, even on top of each other (which will be used in this solution), by dividing the screen into **Rows** and **Columns** defined by the programmer.



_MusicPlayer/Views/ **SoundtracksListPage** .xaml_

<highlight>6-20</highlight>

```xml
...
<ContentPage.Content>
    <Grid>
        ...
        </Grid.ColumnDefinitions>
        <Image Source="images/img_music_info_nocover.png"
               Grid.Row="0"
               Grid.Column="1"
               InputTransparent="True" />
        <Image Source="images/btn_music_info_play.png"
               Grid.Row="0"
               Grid.Column="1"
               VerticalOptions="Center"
               HorizontalOptions="Center" />
        <Button Grid.Row="0"
                Grid.Column="1"
                Command="{Binding GoToPreviewPageCommand}"
                BackgroundColor="Transparent"
                BorderColor="Transparent"
                Opacity="0.5" />
    </Grid>
</ContentPage.Content>
...
```

To achieve the appearance and behaviour of the left panel, especially the album cover, which is focusable and after pressing it, application should navigate to the **Preview Page** , we will place few elements on top of each other. The first element will be an  **Image** of album cover (for now it is only the default cover, later it will be changed to the cover assigned to track). The second element will be the **Image**  which is the icon indicating if there is ongoing playback or if player is paused. Connecting this icon to the player will be added later, for now it is only the placeholder, which is centered in a cell, on top of the cover of the track. The last element is the **Button** . It is placed on top of the two previous elements and it has **_BackgroundColor_**  and **_BorderColor_**  set to "Transparent", so this doesn't hide anything what is under it. The  **_Opacity_**  is set to 0.5, so this doesn't also hide anything when the button is focused, what is more - it simulates the focus on the album cover. **Button**  is also used here, because it has the  **_Command_**  property, which allows to bind the **Command** performing some operations to be fired when **Button**  is pressed.

Presented approach is beneficial for our application, because this allows to simulate, that the album cover with player indicator is the one element, which is focusable, but we keep it separeted in a code, by what the elements work independently from each other, so we can easily change them during the application run.



_MusicPlayer/Views/ **SoundtracksListPage** .xaml_

<highlight>10-24</highlight>

```xml
...
<ContentPage.Content>
    ...
    <Button Grid.Row="0"
            Grid.Column="1"
            Command="{Binding GoToPreviewPageCommand}"
            BackgroundColor="Transparent"
            BorderColor="Transparent"
            Opacity="0.5" />
    <StackLayout Grid.Row="1"
                 Grid.Column="1">
        <Label Text="{Binding CurrentTrack.Title}"
               FontSize="60"
               TextColor="#FFFFFF"
               Margin="0, 6, 0, 0" />
        <Label Text="{Binding CurrentTrack.Artist}"
               FontSize="47"
               TextColor="#FFFFFF"
               Margin="0, 0, 0, 0" />
        <Label Text="{Binding CurrentTrack.Album}"
               FontSize="47"
               FontFamily="BreezeSans:style=Light"
               Margin="0, -12, 0, 0" />
    </StackLayout>
    ...
</ContentPage.Content>
...
```

The last thing added to the left side panel is the **_Title_** ,  **_Artist_** and  **_Album_**  of the **_CurrentTrack_** . These will be shown using the **Labels**  (placed in **StackLayout** which is inside the **Grid** layout) with  **_Text_**  property binded to the properties of the **_CurrentTrack_** , this will make the information provided by these **Labels** consistent with the currently selected **Track** .



After building and executing the application the **Soundtracks List Page** should look like this:

<img src="/assets/images/tutorials/108/soundtrack_list_page_first.png" style="height:480px; width:853px"/>

After pressing the albums cover, we should be navigated to the **Preview Page** .

What is still missing is the tracklist at the right side of the screen. Due to rather complex implementation of this element, we will add it in a next step as a custom control, which can be placed and used easily in our view.

## 2. Info about current track

Application requires the control which allows to display the list of tracks in form which is horizontally scrollable. Unfortunately, Xamarin Forms doesn't provide such a control, but don't worry! This is a problem where we can create own custom control, which will behave in a way suitable for our application and it will be highly reusable in other projects!



Our scrollable list should look like on the following figure

<img src="/assets/images/tutorials/108/scrollable_grid_no_covers_big.PNG" style="height:390px; width:816px"/>

To achieve such look of the control in XAML part only **ScrollView** element will be added with orientation set to "Horizontal" option. This is control available in the Xamarin Forms and it allows to scroll the elements which are inside this control. Generating elements of our custom control will be handled in code behind part of the control, so this is the reason why it also required to add x:Name="scroll" to **ScrollView** element to make access from code behind possible.



_MusicPlayer/Control/ **ScollableGrid** .xaml_

<highlight>4-8</highlight>

```xml
...

<ContentView.Content>
    <ScrollView Orientation="Horizontal"
                VerticalScrollBarVisibility="Never"
                HorizontalScrollBarVisibility="Never"
                x:Name="scroll">
    </ScrollView>
</ContentView.Content>

...
```

After that let's jump into the code behind part of the control and let's create few properties which will be necessary to implement the expected behaviour of our custom control.



_MusicPlayer/Control/ **ScrollableGrid** .xaml.cs_

<highlight>3-21</highlight>

```csharp
#region properties

/// <summary>
/// Allows to set number of rows in list.
/// </summary>
public static readonly BindableProperty RowsProperty = BindableProperty.Create(
                                        nameof(Rows),
                                        typeof(int),
                                        typeof(ScrollableGrid),
                                        0,
                                        BindingMode.OneWay,
                                        propertyChanged: OnPropertyChanged);

/// <summary>
/// Gets or sets number of rows in list.
/// </summary>
public int Rows
{
    get => (int)GetValue(RowsProperty);
    set => SetValue(RowsProperty, value);
}

#endregion
```

This property will allow the user of control to set the maximum number of rows of items in each column. Properties in this control will get and set data to **BindableProperty** object, because it allows to use binding on this property when it is being set by user and to handle the **propertyChanged** event (and in our case generating the control again, which will be shown later).



_MusicPlayer/Control/ **ScrollableGrid** .xaml.cs_

<highlight>5-63</highlight>

```csharp
#region properties

...

/// <summary>
/// Allows to set width of single item.
/// </summary>
public static readonly BindableProperty WidthOfItemProperty = BindableProperty.Create(
                                        nameof(WidthOfItem),
                                        typeof(int),
                                        typeof(ScrollableGrid),
                                        0,
                                        BindingMode.OneWay,
                                        propertyChanged: OnPropertyChanged);

/// <summary>
/// Gets or sets width of single item.
/// </summary>
public int WidthOfItem
{
    get => (int)GetValue(WidthOfItemProperty);
    set => SetValue(WidthOfItemProperty, value);
}

/// <summary>
/// Allows to set height of single item.
/// </summary>
public static readonly BindableProperty HeightOfItemProperty = BindableProperty.Create(
                                        nameof(HeightOfItem),
                                        typeof(int),
                                        typeof(ScrollableGrid),
                                        0,
                                        BindingMode.OneWay,
                                        propertyChanged: OnPropertyChanged);

/// <summary>
/// Gets or sets height of single item.
/// </summary>
public int HeightOfItem
{
    get => (int)GetValue(HeightOfItemProperty);
    set => SetValue(HeightOfItemProperty, value);
}

/// <summary>
/// Allows to set space between lists.
/// </summary>
public static readonly BindableProperty SpaceBetweenColumnsProperty = BindableProperty.Create(
                                        nameof(SpaceBetweenColumns),
                                        typeof(int),
                                        typeof(ScrollableGrid),
                                        0,
                                        BindingMode.OneWay,
                                        propertyChanged: OnPropertyChanged);

/// <summary>
/// Gets or sets space between lists.
/// </summary>
public int SpaceBetweenColumns
{
    get => (int)GetValue(SpaceBetweenColumnsProperty);
    set => SetValue(SpaceBetweenColumnsProperty, value);
}

#endregion
```

There are few properties being introduced, but their purpose is almost the same - it is to get and set the width and height of single item in our **ScrollableGrid**  as well as the space between the columns. Using this properties allows our control to be as much flexible as it is possible.



_MusicPlayer/Control/ **ScrollableGrid** .xaml.cs_

<highlight>5-42</highlight>

```csharp
#region properties

...

/// <summary>
/// Allows to set the item source.
/// </summary>
public static readonly BindableProperty ItemsSourceProperty = BindableProperty.Create(
                                        nameof(ItemsSource),
                                        typeof(IEnumerable),
                                        typeof(ScrollableGrid),
                                        default(IEnumerable),
                                        BindingMode.OneWay,
                                        propertyChanged: OnPropertyChanged);

/// <summary>
/// Gets or sets the item source.
/// </summary>
public IEnumerable ItemsSource
{
    get => (IEnumerable)GetValue(ItemsSourceProperty);
    set => SetValue(ItemsSourceProperty, value);
}

/// <summary>
/// Allows to set data template for item.
/// </summary>
public static readonly BindableProperty ItemTemplateProperty = BindableProperty.Create(
                                        nameof(ItemTemplate),
                                        typeof(DataTemplate),
                                        typeof(ScrollableGrid),
                                        null,
                                        propertyChanged: OnPropertyChanged);

/// <summary>
/// Gets or sets data template for item.
/// </summary>
public DataTemplate ItemTemplate
{
    get => (DataTemplate)GetValue(ItemTemplateProperty);
    set => SetValue(ItemTemplateProperty, value);
}

#endregion
```



_MusicPlayer/Control/ **ScrollableGrid** .xaml.cs_

<highlight>5-27</highlight>

```csharp
#region properties

...

/// <summary>
/// Allows to set command to invoke when the grid item is pressed.
/// </summary>
public static readonly BindableProperty CommandProperty = BindableProperty.Create(
                                        nameof(Command),
                                        typeof(ICommand),
                                        typeof(ScrollableGrid),
                                        null,
                                        propertyChanged: OnPropertyChanged);

/// <summary>
/// The command to invoke when grid item is pressed.
/// </summary>
public ICommand Command
{
    get => (ICommand)GetValue(CommandProperty);
    set => SetValue(CommandProperty, value);
}

/// <summary>
/// Gets the lists of items.
/// </summary>
public List<List<object>> DividedList { get; private set; }

#endregion
```

The last two properties, which will be used are **_Command_** and **_DividedList_** .

That's all properties which will be used in the control. Now let's jump into the methods which will be responsible for generating the grid.



_MusicPlayer/Control/ **ScrollableGrid** .xaml.cs_

<highlight>5-29</highlight>

```csharp
#region methods

...

/// <summary>
/// Divides the items source into lists of specified length.
/// </summary>
private void DivideItemsIntoColumns()
{
    int i = 0;
    DividedList = new List<List<object>>();
    if (ItemsSource != null)
    {
         foreach (var t in ItemsSource)
         {
              if (Rows != 0)
              {
                   if (i % Rows == 0)
                   {
                        DividedList.Add(new List<object>());
                   }

                   DividedList[i / Rows].Add(t);
              }

              i++;
          }
     }
}

#endregion
```

The above method just divides the given **_ItemSource_** collection into the list of lists of maximum length specfied in  **_Rows_** property and it saves the result into the property  **_DividedList_** , which as mentioned before is used internally by the custom control. This method prepares the data for futher processing and displaying it in the **GenerateGrid** method.



_MusicPlayer/Control/ **ScrollableGrid** .xaml.cs_

<highlight>5-61</highlight>

```csharp
#region methods

...

/// <summary>
/// Displays the grid.
/// </summary>
private void GenerateGrid()
{
    int x = 0;
    int index = 0;
    Grid grid = new Grid();
    for (int i = 0; i < Rows; i++)
    {
       grid.RowDefinitions.Add(new RowDefinition { Height = HeightOfItem });
    }

    grid.RowSpacing = 2;
    scroll.Content = grid;
    foreach (var t in DividedList)
    {
        int y = 0;
        grid.ColumnDefinitions.Add(new ColumnDefinition { Width = WidthOfItem });
        grid.ColumnDefinitions.Add(new ColumnDefinition { Width = SpaceBetweenColumns });
        foreach (var item in t)
        {
            Button btn = new Button();
            btn.HeightRequest = HeightOfItem;
            btn.WidthRequest = WidthOfItem;
            btn.Opacity = 0;
            btn.Command = Command;
            btn.CommandParameter = index;

            View cell = ItemTemplate.CreateContent() as View;
            cell.BindingContext = item;

            grid.Children.Add(cell);
            Grid.SetRow(cell, y);
            Grid.SetColumn(cell, x);

            grid.Children.Add(btn);
            Grid.SetRow(btn, y);
            Grid.SetColumn(btn, x);

            btn.Focused += (s, e) =>
            {
                btn.Opacity = 0.1;
            };

            btn.Unfocused += (s, e) =>
            {
                btn.Opacity = 0;
            };

            y++;
            index++;
        }

        x += 2;
    }
}

#endregion
```

Purpose of this method is to generate the grid with the elements given in the  **_ItemSource_**  property which are displayed in a way specified in  **_ItemTemplate_** property. It also has to enable the possibility to focus and to press an item in a list (which causes executing the Command binded in  **_Command_**  property of our custom control).

To create new **Grid** and to generate the rows and assign the grid to the view ( **SrollView** element in XAML part of the control) it does the following:

```csharp
Grid grid = new Grid();
for (int i = 0; i < Rows; i++)
{
    grid.RowDefinitions.Add(new RowDefinition { Height = HeightOfItem });
}

grid.RowSpacing = 2;
scroll.Content = grid;
```

Later, method adds two columns to the existing grid for each list in **_DividedList_**  property - one with width equal to  **_WidthOfItem_**  property and second one as a space between actual columns with width equal to  **_SpaceBetweenColumns_** :

```csharp
foreach (var t in DividedList)
{
    int y = 0;
    grid.ColumnDefinitions.Add(new ColumnDefinition { Width = WidthOfItem });
    grid.ColumnDefinitions.Add(new ColumnDefinition { Width = SpaceBetweenColumns });
    ...
}

```

After that, for each item inside the certain list there is created the **Button** with width and height equal to those specified by user. Under the button there will be the item with view given in **_ItemTemplate_** , that's why opacity of a button is 0 (and this value is being changed to 0.1 when **Button**  fires **Focused** event, to simulate the focus on an item). **Button**  also has Command property set to  **_Command_**  property of our **ScrollableGrid** control and CommandParameter equal to variable called index - this variable will be passed when executing Command and it represents the index of the item in  **_ItemSource_**  property, this allows the user to properly identify pressed item. Later the item view is being created from the given  **_ItemTemplate_** . The **BindingContext**  of this single cell is set to the certain item in the list. After everything being set up, item view is being placed in a proper cell in a grid and on top of it **Button** created before is placed.

```csharp
foreach (var item in t)
{
    Button btn = new Button();
    btn.HeightRequest = HeightOfItem;
    btn.WidthRequest = WidthOfItem;
    btn.Opacity = 0;
    btn.Command = Command;
    btn.CommandParameter = index;

    View cell = ItemTemplate.CreateContent() as View;
    cell.BindingContext = item;

    grid.Children.Add(cell);
    Grid.SetRow(cell, y);
    Grid.SetColumn(cell, x);

    grid.Children.Add(btn);
    Grid.SetRow(btn, y);
    Grid.SetColumn(btn, x);

    btn.Focused += (s, e) =>
    {
        btn.Opacity = 0.1;
    };

    btn.Unfocused += (s, e) =>
    {
        btn.Opacity = 0;
    };

    y++;
    index++;
}
```

Ok, so now we have all of the methods, which are required to generate the grid, but there is one more thing which have to be implemented inside **ScrollableGrid** .



_MusicPlayer/Control/ **ScrollableGrid** .xaml.cs_

<highlight>5-19</highlight>

```csharp
#region methods

...

/// <summary>
/// Handles the property changed event for properties.
/// </summary>
/// <param name="bindable">BindableObject which raised the event.</param>
/// <param name="oldValue">Old value of property.</param>
/// <param name="newValue">New value of property</param>
private static void OnPropertyChanged(BindableObject bindable, object oldValue, object newValue)
{
    ScrollableGrid scrollableGrid = (ScrollableGrid)bindable;
    scrollableGrid.DivideItemsIntoColumns();
    if (scrollableGrid.ItemTemplate != null)
    {
        scrollableGrid.GenerateGrid();
    }
}

#endregion
```

This method is a callback for the change of **BindableProperty** , it just re-assigns the **_DividedList_**  property by firing the **DivideItemsIntoColumns** method and if the  **_ItemTemplate_**  property is set it fires **GenerateGrid** function to display the **ScrollableGrid** with updated properties. Using this callback on properties ensures that the view of the custom control is proper for given properties.



That's the whole implementation of the **ScrollableGrid** , so we can try to test how this control will look on our **Soundtrack List Page** .



Firstly, we have to create some property which will be  **_ItemSource_**  for our custom control in ViewModel.



_MusicPlayer/ViewModels/ **MainViewModel** .cs_

<highlight>5-8,21-34</highlight>

```csharp
#region properties

...

/// <summary>
/// Gets list of loaded tracks.
/// </summary>
public List<Track> Tracks { get; }

#endregion

#region methods

/// <summary>
/// Initializes class instance.
/// </summary>
public MainViewModel()
{
    ...

    Tracks = new List<Track>
    {
        new Track("Title_1", "Artist_1", "Album_1", null, "somepath", 0),
        new Track("Title_2", "Artist_2", "Album_2", null, "somepath", 0),
        new Track("Title_3", "Artist_3", "Album_3", null, "somepath", 0),
        new Track("Title_4", "Artist_4", "Album_4", null, "somepath", 0),
        new Track("Title_5", "Artist_5", "Album_5", null, "somepath", 0),
        new Track("Title_6", "Artist_6", "Album_6", null, "somepath", 0),
        new Track("Title_7", "Artist_7", "Album_7", null, "somepath", 0),
        new Track("Title_8", "Artist_8", "Album_8", null, "somepath", 0),
        new Track("Title_9", "Artist_9", "Album_9", null, "somepath", 0),
        new Track("Title_10", "Artist_10", "Album_10", null, "somepath", 0),
        new Track("Title_11", "Artist_11", "Album_11", null, "somepath", 0)
    };

    ...
}

...

#endregion
```

To display this list on the view add the following code, which just binds the **_Tracks_** from the **MainViewModel**  to  **_ItemSource_**  property of **ScrollableGrid**  and sets other properties of the control to achieve the final appereance of the page. The  **_ItemTemplate_**  for now is simply taking only Title, Artist and Album properties of a **_Tracks_** , it will be later replaced with **TrackListViewCell**  template, which will be our final template.



_MusicPlayer/Views/ **SoundtrackListPage** .xaml_

<highlight>4-21</highlight>

```xml
<Grid>
    ...
    </StackLayout>
    <controls:ScrollableGrid Rows="4"
                             ItemsSource="{Binding Tracks}"
                             Grid.Column="3"
                             Grid.Row="0"
                             Grid.RowSpan="2"
                             WidthOfItem="570"
                             SpaceBetweenColumns="25"
                             HeightOfItem="134">
        <controls:ScrollableGrid.ItemTemplate>
            <DataTemplate>
                <StackLayout BackgroundColor="#1b1b1b">
                    <Label Text="{Binding Title}" />
                    <Label Text="{Binding Artist}" />
                    <Label Text="{Binding Album}" />
                </StackLayout>
            </DataTemplate>
        </controls:ScrollableGrid.ItemTemplate>
    </controls:ScrollableGrid>
</Grid>
```

The final result after rebuilding the project should look like on the following screen:

<img src="/assets/images/tutorials/108/scrollable_grid_part_1.png" style="height:480px; width:853px"/>

The list should scroll horizontally when we are pressing arrows on the remote control. This solution doesn't look like we want for now, but it behaves like we expected. Final item template will be added in another step as well as the behaviour after selecting the item.



We will later come back to this part, but for now the next step is the **Preview Page** view.

## 3. Scrollable Grid (Custom Control)

Application will use model _MusicPlayer/Models/ **Track** .cs_  to store the information about the single track. This model is already implemented and it won't be changed in this tutorial, however let's quickly go through the code implemented inside this class.



_MusicPlayer/Models/ **Track** .cs_

```csharp
#region properties

/// <summary>
/// Title of the track.
/// </summary>
public string Title { get; set; }

/// <summary>
/// Represents the artist name.
/// </summary>
public string Artist { get; set; }

/// <summary>
/// Represents the album name.
/// </summary>
public string Album { get; set; }

...

#endregion
```

These are the basic properties, which represent the Title of the track, Artists and Albums name.



_MusicPlayer/Models/ **Track** .cs_

```csharp
#region properties

...

/// <summary>
/// Represents the track artwork.
/// </summary>
public byte[] Artwork { get; set; }

...

#endregion
```

**_Artwork_** represents the image assigned to the track (it will be taken from the files metadata). It is stored as a byte array for the flexibility (later it can be changed to required objects by converters).



_MusicPlayer/Models/ **Track** .cs_

```csharp
#region properties

...

/// <summary>
/// Path to the track.
/// </summary>
public string Path { get; set; }

/// <summary>
/// Duration of the track (in milliseconds).
/// </summary>
public int Duration { get; set; }

#endregion
```

These two properties stores information about path to track file and duration of the track in milliseconds.



_MusicPlayer/Models/ **Track** .cs_

```csharp
#region methods

/// <summary>
/// Initializes Track class instance.
/// </summary>
/// <param name="title">Title of the track.</param>
/// <param name="artist">Name of the artist.</param>
/// <param name="album">Title of the album.</param>
/// <param name="artwork">Artwork of the track.</param>
/// <param name="path">Path to the track.</param>
/// <param name="duration">Duration of the track (in milliseconds).</param>
public Track(string title, string artist, string album, byte[] artwork, string path, int duration)
{
    Title = title;
    Artist = artist;
    Album = album;
    Artwork = artwork;
    Path = path;
    Duration = duration;
}
```

The only method available in the model is the constructor of the class, which just assignsproperties with values given as an arguments of the constructor.



Track model will be used in almost every place in our application, so now we will be able to use it properly as we are familiarized with it.

# III. Preview Page View

## 1. Goal

The goal of  **Preview Page**  is to:

<img src="/assets/images/tutorials/108/_preview_page.png" style="height:480px; width:853px"/>

## 2. Info about current track

There is nothing more to add to the ViewModel, because as long as the **Soundtrack List Page** and **Preview Page** share the same instance of the **MainViewModel** , the data between the views is persistent, including the current track.



_MusicPlayer/Views/ **PreviewPage** .xaml_

<highlight>4-19</highlight>

```xml
...

<ContentPage.Content>
    <StackLayout Margin="97, 67, 97, 0">
        <Label Text="{Binding CurrentTrack.Title}"
               FontSize="76"
               FontFamily="BreezeSans:style=Bold"
               TextColor="#FFFFFF" />
         <Label Text="{Binding CurrentTrack.Artist}"
               FontSize="50"
               FontFamily="BreezeSans:style=Light"
               TextColor="#FFFFFF" />
         <Image Source="images/img_music_info_nocover.png"
                Margin="0, 79, 0, 0"
                HorizontalOptions="Center"
                VerticalOptions="Center"
                HeightRequest="578"
                WidthRequest="578" />
    </StackLayout>
</ContentPage.Content>

...
```

Let's start building the page from displaying the information about **_Title_** and **_Artist_** of the current track by adding the **Labels**  with **_Text_**  properties binded to the corresponding properties inside the **_CurrentTrack_** . **_Artwork_** assigned to the track will be added later, because logic of displaying the actual artwork or the default one will be handled later by the converter, so for now let's stick to the **Image** at the center of the screen with **_Source_** assigned to default cover.

Next thing to add is the **ProgressBar** and the information about track playback and duration. To use the **ProgressBar** it will be useful to get some property from ViewModel defining the progress of the track as value from 0 to 1 (beacuse the **ProgressBar** given by Xamarin Forms utilizes the **_Progress_** property, which takes the value from 0 to 1).



_MusicPlayer/ViewModels/ **MainViewModel** .cs_

<highlight>5-8,18-25,40</highlight>

```csharp
#region fields

...

/// <summary>
/// Specifying progress of the track as value from 0 to 1.
/// </summary>
private double _trackProgress;

...

#endregion

#region properties

...

/// <summary>
/// Gets or sets progress of the track as value from 0 to 1.
/// </summary>
public double TrackProgress
{
    get => _trackProgress;
    set => SetProperty(ref _trackProgress, value);
}

...

#endregion

#region methods

/// <summary>
/// Initializes class instance.
/// </summary>
public MainViewModel()
{
    ...

    TrackProgress = 0.4;

    ...
}
...

#endregion
```

**_TrackProgress_**  is property with backing field. This property is initialized in a ViewModel constructor, later it will be updated during the track playback to reflect the change in the playback position of the player.

Now, let's go back to **Preview Page**  layout and let's add the **ProgressBar** .



_MusicPlayer/Views/ **PreviewPage** .xaml_

<highlight>5-8</highlight>

```xml
...
<ContentPage.Content>
    <StackLayout Margin="97, 67, 97, 0">
        ...
        <ProgressBar Progress="{Binding TrackProgress}"
                     BackgroundColor="Black"
                     Margin="-97, 103, -97, 0"
                     WidthRequest="1920" />
    </StackLayout>
</ContentPage.Content>
...

```

**ProgressBar**  just binds **_TrackProgress_**  property to its own  **_Progress_** property. Also the **_BackgroundColor_**  is set to "Black" for better appearance.



After executing the application and navigating to the **Preview Page** the result should look like this:
<img src="/assets/images/tutorials/108/preview_page_with_progress_bar_without_duration.png" style="height:480px; width:853px"/>

There are still two things missing. One thing are the **Labels**  representing **Track**  duration and current playback position of a player. Due to lack of the **PlayerModel**  and converter which will convert the integer with number of milliseconds to time string, let's just place the **Labels**  with placeholder data, this will be changed later.



_MusicPlayer/Views/ **PreviewPage** .xaml_

<highlight>5-16</highlight>

```xml
...
<ContentPage.Content>
    <StackLayout Margin="97, 67, 97, 0">
        ...
        <AbsoluteLayout>
            <Label Text="00:01:30"
                   FontSize="55"
                   FontFamily="BreezeSans:style=Light"
                   Margin="66, 46, 0, 0"
                   TextColor="#0081C6" />
            <Label Text="00:03:50"
                   FontSize="55"
                   FontFamily="BreezeSans:style=Light"
                   Margin="200, 46, 0, 0"
                   TextColor="#F5F5F5" />
        </AbsoluteLayout>
    </StackLayout>
</ContentPage.Content>
...
```

The final result for this part will be like on the following figure:
<img src="/assets/images/tutorials/108/preview_page_with_progress_bar_with_duration.png" style="height:480px; width:853px"/>

The second thing which is missing in this view are the buttons at the bottom for controlling the player. Because there is no easy way to add the buttons with custom focus/pressing effect and irregular shape of the focus/press overlay (by default focusing an element and pressing it is in form of rectangular overlay), we will implement such custom control with this features in a next step.

## 3. Image Button (Custom Control)

In our application we want to add the buttons in the **Preview Page**  which shape is non rectangular as well as its focus and pressing image. With default **Button**  it is not possible. However we might be smart and we can simulate something similar in a tricky way with help of the own custom control - **ImageButton** . Of course using this custom control in other project will be possible without any problems.



Our assumption for this control is that it will deliver:

<img src="/assets/images/tutorials/108/_image_buttons.PNG" style="height:85px; width:404px"/>

As a first step let's just copy the whole snippet into the **ImageButton** .xaml.



_MusicPlayer/Control/ **ImageButton** .xaml_

<highlight>1-18</highlight>

```xml
<?xml version="1.0" encoding="UTF-8"?>
<ContentView xmlns="http://xamarin.com/schemas/2014/forms"
             xmlns:x="http://schemas.microsoft.com/winfx/2009/xaml"
             x:Class="MusicPlayer.Control.ImageButton"
             x:Name="Root">
  <ContentView.Content>
        <StackLayout Spacing="2000">
            <Image Source="{Binding DisplayedImage, Source={x:Reference Root}}"
                   x:Name="imageButtonImage" />
            <Button Command="{Binding Command, Source={x:Reference Root}}"
                    Focused="OnFocused"
                    Unfocused="OnUnfocused"
                    Clicked="OnClicked"
                    WidthRequest="1"
                    HeightRequest="1" />
        </StackLayout>
    </ContentView.Content>
</ContentView>

```

This is the final layout of the custom control, because all other things will be handled in the code behind. As you can see the whole **ContentView**  has its own x:Name="Root", this will be used for enabling the possibility to utilize custom controls own properties in the bindings, not from the current  **BindingContext** of a parent by adding to the **Binding** the " _Source={x:Reference Root}_ ". The content of this control is put inside the **StackLayout** with **_Spacing_** property set to 2000 - to place the first element in the visible area of the screen and hide the other elements of the control under the screen. The first - visible - element is an  **Image** with the **_Source_**  property set to **_DisplayedImage_** (present in code behind of our custom control), which will represent the **Button** , despite of that **Image** itself is not focusable or pressable. That's why the second element, hence not visible on the screen, is **Button** , which allows to raise the Focused, Unfocused and Clicked events as well as execute the **Command** . This is the thing that does the trick, because we put callbacks on this events in code behind and they will change the appearance of the **Image** above by modifying **_DisplayImage_** property.



_MusicPlayer/Control/ **ImageButton** .xaml.cs_

<highlight>5-18,24-181</highlight>

```csharp
...

#region fields

/// <summary>
/// Duration for pressed state of button in milliseconds.
/// </summary>
private const int PRESSED_TIME = 200;

/// <summary>
/// Gives information if button is focused.
/// </summary>
private bool _isFocused;

/// <summary>
/// Path of currently displayed image.
/// </summary>
private string _displayedImage;

#endregion

#region properties

/// <summary>
/// Gets the currently displayed image.
/// </summary>
public string DisplayedImage
{
    get => _displayedImage;
    private set
    {
        _displayedImage = value;
        OnPropertyChanged();
    }
}

/// <summary>
/// Allows to set the image of default button.
/// </summary>
public static readonly BindableProperty DefaultImageProperty = BindableProperty.Create(
                                        nameof(DefaultImage),
                                        typeof(string),
                                        typeof(ImageButton),
                                        null,
                                        propertyChanged: OnDefaultImageChanged);

/// <summary>
/// Gets or sets the default image.
/// </summary>
public string DefaultImage
{
    get => (string)GetValue(DefaultImageProperty);
    set => SetValue(DefaultImageProperty, value);
}

/// <summary>
/// Allows to set the image of second state default button.
/// </summary>
public static readonly BindableProperty SecondStateDefaultImageProperty = BindableProperty.Create(
                                        nameof(SecondStateDefaultImage),
                                        typeof(string),
                                        typeof(ImageButton),
                                        null);

/// <summary>
/// Gets or sets the second state default image.
/// </summary>
public string SecondStateDefaultImage
{
    get => (string)GetValue(SecondStateDefaultImageProperty);
    set => SetValue(SecondStateDefaultImageProperty, value);
}

/// <summary>
/// Allows to set the image of focused button.
/// </summary>
public static readonly BindableProperty FocusedImageProperty = BindableProperty.Create(
                                        nameof(FocusedImage),
                                        typeof(string),
                                        typeof(ImageButton),
                                        null);

/// <summary>
/// Gets or sets the focused state image.
/// </summary>
public string FocusedImage
{
    get => (string)GetValue(FocusedImageProperty);
    set => SetValue(FocusedImageProperty, value);
}

/// <summary>
/// Allows to set the image of second state focused button.
/// </summary>
public static readonly BindableProperty SecondStateFocusedImageProperty = BindableProperty.Create(
                                        nameof(SecondStateFocusedImage),
                                        typeof(string),
                                        typeof(ImageButton),
                                        null);

/// <summary>
/// Gets or sets the second state focused image.
/// </summary>
public string SecondStateFocusedImage
{
    get => (string)GetValue(SecondStateFocusedImageProperty);
    set => SetValue(SecondStateFocusedImageProperty, value);
}

/// <summary>
/// Allows to set the image of pressed button.
/// </summary>
public static readonly BindableProperty PressedImageProperty = BindableProperty.Create(
                                        nameof(PressedImage),
                                        typeof(string),
                                        typeof(ImageButton),
                                        null);

/// <summary>
/// Gets or sets the pressed state image.
/// </summary>
public string PressedImage
{
    get => (string)GetValue(PressedImageProperty);
    set => SetValue(PressedImageProperty, value);
}

/// <summary>
/// Allows to set the image of second state pressed button.
/// </summary>
public static readonly BindableProperty SecondStatePressedImageProperty = BindableProperty.Create(
                                        nameof(SecondStatePressedImage),
                                        typeof(string),
                                        typeof(ImageButton),
                                        null);

/// <summary>
/// Gets or sets the second state pressed image.
/// </summary>
public string SecondStatePressedImage
{
    get => (string)GetValue(SecondStatePressedImageProperty);
    set => SetValue(SecondStatePressedImageProperty, value);
}

/// <summary>
/// Allows to set command to invoke when the button is pressed.
/// </summary>
public static readonly BindableProperty CommandProperty = BindableProperty.Create(
                                        nameof(Command),
                                        typeof(ICommand),
                                        typeof(ImageButton),
                                        null);

/// <summary>
/// The command to invoke when the button is pressed.
/// </summary>
public ICommand Command
{
    get => (ICommand)GetValue(CommandProperty);
    set => SetValue(CommandProperty, value);
}

/// <summary>
/// Allows to define if button is in second state.
/// </summary>
public static readonly BindableProperty IsInSecondStateProperty = BindableProperty.Create(
                                        nameof(IsInSecondState),
                                        typeof(bool),
                                        typeof(ImageButton),
                                        false,
                                        propertyChanged: OnIsInSecondStateChanged);

/// <summary>
/// Gives information if button is in second state.
/// </summary>
public bool IsInSecondState
{
    get => (bool)GetValue(IsInSecondStateProperty);
    set => SetValue(IsInSecondStateProperty, value);
}

#endregion

...
```

This quite long snippet is the definition of all fields and properties, which will be needed in our custom control. **_PRESSED_TIME_** constant is the number, which represents the duration (in milliseconds) for  **ImageButton** persistence in pressed state, after pressing the **Button** . **_\_isFocused_** field is for internal information of the control if **Button**  is currently in the focused state. **_\_displayedImage_**  is backing field for the **_DisplayedImage_** property, to which **Image** in the xaml part of the custom control binds its **_Source_** property to. Setter of the **_DisplayedImage_**  performs OnPropertyChanged() method to refresh the binded data. All of the following properties goes with **BindableProperties** , to allow the final user of this custom control to bind own properties to our **ImageButton** :



The next thing is to implement methods which will build the logic of our control.



_MusicPlayer/Control/ **ImageButton** .xaml.cs_

<highlight>7-16</highlight>

```csharp
...

#region methods

...

/// <summary>
/// Event handler for focusing the button.
/// </summary>
/// <param name="sender">Sender of the event.</param>
/// <param name="e">Focus event arguments.</param>
private void OnFocused(object sender, FocusEventArgs e)
{
    DisplayedImage = IsInSecondState ? SecondStateFocusedImage : FocusedImage;
    _isFocused = true;
}

#endregion
```

OnFocused method is fired by the **Button** (placed inside the xaml part of the control), when it is focused. Then the **_DisplayedImage_** property changes to the path to the image of the focused button in first or second state, depending on **_IsInSecondState_** property. The other thing is that **_\_isFocused_**  is set to _true_ for informing the control internally that it is currently in focused state.



_MusicPlayer/Control/ **ImageButton** .xaml.cs_

<highlight>7-16</highlight>

```csharp
...

#region methods

...

/// <summary>
/// Event handler for unfocusing the button.
/// </summary>
/// <param name="sender">Sender of the event.</param>
/// <param name="e">Focus event arguments.</param>
private void OnUnfocused(object sender, FocusEventArgs e)
{
     DisplayedImage = IsInSecondState ? SecondStateDefaultImage : DefaultImage;
     _isFocused = false;
}

#endregion
```

OnUnfocused method is fired by the **Button** (placed inside the xaml part of the control), when it is unfocused. Then the **_DisplayedImage_** property changes to the path to the image of the unfocused button in first or second state, depending on **_IsInSecondState_** property.   **_\_isFocused_**  is set to _false_ for informing the control internally that it is currently in unfocused state.



_MusicPlayer/Control/ **ImageButton** .xaml.cs_

<highlight>7-24</highlight>

```csharp
...

#region methods

...

/// <summary>
/// Event handler for clicking the button.
/// </summary>
/// <param name="sender">Sender of the event.</param>
/// <param name="e">Clicked event arguments.</param>
private void OnClicked(object sender, EventArgs e)
{
    DisplayedImage = IsInSecondState ? SecondStatePressedImage : PressedImage;
    Device.StartTimer(TimeSpan.FromMilliseconds(PRESSED_TIME), () =>
    {
        if (SecondStateDefaultImage == null)
        {
            DisplayedImage = FocusedImage;
        }

        return false;
    });
}

#endregion
```

OnClicked method is fired by the **Button** (placed inside the xaml part of the control), when it is pressed. Then the **_DisplayedImage_** property changes to the path to the image of the pressed button in first or second state, depending on **_IsInSecondState_** property for number of milliseconds specified in PRESSED_TIME constant. If **_SecondStateDefaultImage_**  is not set, it means that **_ImageButton_**  doesn't have second state, so **_DisplayedImage_**  goes back to **_FocusedImage_** (in other case it is changed in the callback for changing  **_IsInSecondState_**  property according to current state of the **ImageButton** ). At the end of the method _false_  is being returned, because Device.StartTimer performs its operation in loop until the return statement is equal to  _false_ .



_MusicPlayer/Control/ **ImageButton** .xaml.cs_

<highlight>7-24</highlight>

```csharp
...

#region methods

...

/// <summary>
/// Handler for changing the value of IsInSecondState property.
/// </summary>
/// <param name="bindable">BindableObject which raised the event.</param>
/// <param name="oldvalue">Old value of property.</param>
/// <param name="newvalue">New value of property</param>
private static void OnIsInSecondStateChanged(BindableObject bindable, object oldvalue, object newvalue)
{
    ImageButton myself = (ImageButton)bindable;
    if (myself._isFocused)
    {
        myself.DisplayedImage = (bool)newvalue ? myself.SecondStateFocusedImage : myself.FocusedImage;
    }
    else
    {
        myself.DisplayedImage = (bool)newvalue ? myself.SecondStateDefaultImage : myself.DefaultImage;
    }
}

#endregion
```

This method is a handler for changing the  **_IsInSecondState_**  property. It checks if **Button**  is currently focused and then assigns to  **_DisplayedImage_**  proper path to image of a button, suitable for current state of a control.



_MusicPlayer/Control/ **ImageButton** .xaml.cs_

<highlight>7-17</highlight>

```csharp
...

#region methods

...

/// <summary>
/// Handler for changing the value of DefaultImage property.
/// </summary>
/// <param name="bindable">BindableObject which raised the event.</param>
/// <param name="oldvalue">Old value of property.</param>
/// <param name="newvalue">New value of property</param>
private static void OnDefaultImageChanged(BindableObject bindable, object oldvalue, object newvalue)
{
    ImageButton myself = (ImageButton)bindable;
    myself.DisplayedImage = (string)newvalue;
}

#endregion
```

The last method in code behind of **ImageButton**  custom control is handler for changing the **_DefaultImage_** property. This method ensures, that **_DisplayedImage_** is consistent with current **_DefaultImage_** value if it is changed.



Now, our custom control is ready to use, so let's place it on the **Preview Page** of our application.



_MusicPlayer/Views/ **PreviewPage** .xaml_

<highlight>10-38</highlight>

```xml
...
<StackLayout Margin="97, 67, 97, 0">
    <AbsoluteLayout>
        ...
        <Label Text="00:03:50"
               FontSize="55"
               FontFamily="BreezeSans:style=Light"
               Margin="200, 46, 0, 0"
               TextColor="#F5F5F5" />
        <control:ImageButton DefaultImage="images/btn_viewer_control_previous_normal.png"
                             FocusedImage="images/btn_viewer_control_previous_focused.png"
                             PressedImage="images/btn_viewer_control_previous_pressed.png"
                             Command="{Binding GoToPreviousTrackCommand}"
                             Margin="610, 26, 0, 0" />
        <control:ImageButton DefaultImage="images/btn_viewer_control_rewind_normal.png"
                             FocusedImage="images/btn_viewer_control_rewind_focused.png"
                             PressedImage="images/btn_viewer_control_rewind_pressed.png"
                             Command="{Binding RewindTrackCommand}"
                             Margin="726, 26, 0, 0" />
        <control:ImageButton DefaultImage="images/btn_viewer_control_pause_normal.png"
                             FocusedImage="images/btn_viewer_control_pause_focused.png"
                             PressedImage="images/btn_viewer_control_pause_pressed.png"
                             SecondStateDefaultImage="images/btn_viewer_control_play_normal.png"
                             SecondStateFocusedImage="images/btn_viewer_control_play_focused.png"
                             SecondStatePressedImage="images/btn_viewer_control_play_pressed.png"
                             IsInSecondState="{Binding IsPaused}"
                             Command="{Binding PlayOrPauseTrackCommand}"
                             Margin="822, 26, 0, 0" />
        <control:ImageButton DefaultImage="images/btn_viewer_control_forward_normal.png"
                             FocusedImage="images/btn_viewer_control_forward_focused.png"
                             PressedImage="images/btn_viewer_control_forward_pressed.png"
                             Command="{Binding ForwardTrackCommand}"
                             Margin="918, 26, 0, 0" />
        <control:ImageButton DefaultImage="images/btn_viewer_control_next_normal.png"
                             FocusedImage="images/btn_viewer_control_next_focused.png"
                             PressedImage="images/btn_viewer_control_next_pressed.png"
                             Command="{Binding GoToNextTrackCommand}"
                             Margin="1014, 26, 0, 0" />
        </AbsoluteLayout>
    </StackLayout>
...
```

So these are all of the 5 buttons which are needed to manage the player on **Preview Page** . **_Command_** properties are binded to various  **Command** s inside ViewModel as well as **_IsInSecondState_** property of **ImageButton** representing play/pause button is binded to **_IsPaused_**  property of **MainViewModel** , so let's create these properties.



_MusicPlayer/ViewModels/ **MainViewModel** .cs_

<highlight>5-36</highlight>

```csharp
#region properties

...

/// <summary>
/// Determines if track is paused.
/// </summary>
public bool IsPaused
{
    get => false;
}

/// <summary>
/// Command which executes the procedure of changing to the previous track.
/// </summary>
public ICommand GoToPreviousTrackCommand { get; private set; }

/// <summary>
/// Command which executes the procedure of seeking backward.
/// </summary>
public ICommand RewindTrackCommand { get; private set; }

/// <summary>
/// Command which executes the procedure of pausing/playing the track.
/// </summary>
public ICommand PlayOrPauseTrackCommand { get; private set; }

/// <summary>
/// Command which executes the procedure of seeking forward.
/// </summary>
public ICommand ForwardTrackCommand { get; private set; }

/// <summary>
/// Command which executes the procedure of changing to the next track.
/// </summary>
public ICommand GoToNextTrackCommand { get; private set; }

#endregion
```

Currently the  **_IsPaused_**  property is just returning _false,_ because for now we don't have **PlayerModel** , which will provide later the current state of a player. The other properties are **Command** s for managing the player. As a last thing in this part of tutorial just initialize those **Commands** and point them to actual methods, which will be implemented later.



_MusicPlayer/ViewModels/ **MainViewModel** .cs_

<highlight>11-57</highlight>

```csharp
#region methods

...

/// <summary>
/// Initializes commands.
/// </summary>
private void InitCommands()
{
    ...
    GoToPreviousTrackCommand = new Command(GoToPreviousTrack);
    RewindTrackCommand = new Command(RewindTrack);
    PlayOrPauseTrackCommand = new Command(PlayOrPauseTrack);
    ForwardTrackCommand = new Command(ForwardTrack);
    GoToNextTrackCommand = new Command(GoToNextTrack);
}

/// <summary>
/// Handles the execution of "GoToPreviousTrackCommand"
/// </summary>
private void GoToPreviousTrack()
{

}

/// <summary>
/// Handles the execution of "RewindTrackCommand"
/// </summary>
private void RewindTrack()
{

}

/// <summary>
/// Handles the execution of "PlayOrPauseTrackCommand"
/// </summary>
private void PlayOrPauseTrack()
{

}

/// <summary>
/// Handles the execution of "ForwardTrackCommand"
/// </summary>
private void ForwardTrack()
{

}

/// <summary>
/// Handles the execution of "GoToNextTrackCommand"
/// </summary>
private void GoToNextTrack()
{

}

#endregion
```

Now layout of our **Preview Page** is finished and it should look like this:

<img src="/assets/images/tutorials/108/_preview_page_without_logic.png" style="height:480px; width:853px"/>

# IV. Converters

## 1. MillisecondsToTimeConverter

In this chapter we will implement converters, which we already need (and after we implement them, they will be used in proper places in the application) or will be needed in future, when more logic of the application will be implemented.



Do you remember track duration and track playback position labels on the  **Preview Page** ? As told before the text values was just given as placeholders. Now let's implement the converter, which will change the milliseconds given in an integer to properly formatted string, which can be placed as a **_Text_**  property in our labels.



_MusicPlayer/Converters/ **MillisecondsToTimeConverter** .cs_

<highlight>13</highlight>

```csharp
...

/// <summary>
/// Converts milliseconds to time string.
/// </summary>
/// <param name="value">Number of milliseconds.</param>
/// <param name="targetType">Target type of conversion.</param>
/// <param name="parameter">Parameters of conversion.</param>
/// <param name="culture">Provides information about a specific culture.</param>
/// <returns>String representing time (in format "hh:mm:ss").</returns>
public object Convert(object value, Type targetType, object parameter, System.Globalization.CultureInfo culture)
{
    return TimeSpan.FromMilliseconds((int)value).ToString(@"hh\:mm\:ss");
}

...
```

So just change this one line in the **Convert** method. This method creates object of type **TimeSpan** (which represents a length of time and provides easy way to manipulate this time) from the integer representing the number of milliseconds given as an input to the converter. This **TimeSpan** object is later converted to string of specified format - in this case " _hh:mm:ss_ " (hours:minutes:seconds) and this string is the return statement of the converter.

That's all the code which have to be present in the converter, now let's try to use this to display the duration of a track and current position of the playback.

Firstly, add the backing field and a property in the ViewModel which will represent the current playback position.



_MusicPlayer/ViewModels/ **MainViewModel** .cs_

<highlight>5-8,16-23,38</highlight>

```csharp
#region fields

...

/// <summary>
/// Specifying the information about playback position of the track (in milliseconds).
/// </summary>
private int _trackPlaybackPosition;

#endregion

#region properties

...

/// <summary>
/// Gets or sets information about playback position of the track (in milliseconds).
/// </summary>
public int TrackPlaybackPosition
{
    get => _trackPlaybackPosition;
    set => SetProperty(ref _trackPlaybackPosition, value);
}

#endregion

#region methods

/// <summary>
/// Initializes class instance.
/// </summary>
public MainViewModel()
{
    ...

    TrackProgress = 0.4;

    TrackPlaybackPosition = 0;

    ...
}

...

#endregion
```

Initializing this property inside constructor with 0 is just temporary, because later this will be updated periodically with data from the player. Now let's add the code which will utilize this property and our converter. Normally it will be necessary also to somehow point the converter and give it the key, so it can be used in the xaml parts of the code, but in case of our base code it is already done in the _MusicPlayer/_ **_MusicPlayer_** _.xaml_ file in the **_ResourceDictionary_** of the whole application. The **_x:Key_** given for this converter is " _MillisecondsToTime_ ", so the usage will be like in the following code:



_MusicPlayer/Views/ **PreviewPage** .xaml_

<highlight>4,9</highlight>

```xml
...

<AbsoluteLayout>
    <Label Text="{Binding TrackPlaybackPosition, Converter={StaticResource MillisecondsToTime}}"
           FontSize="55"
           FontFamily="BreezeSans:style=Light"
           Margin="66, 46, 0, 0"
           TextColor="#0081C6" />
    <Label Text="{Binding CurrentTrack.Duration, Converter={StaticResource MillisecondsToTime}}"
           FontSize="55"
           FontFamily="BreezeSans:style=Light"
           Margin="200, 46, 0, 0"
           TextColor="#F5F5F5" />
    ...
</AbsoluteLayout>

...
```

Let's try to build the solution and run it. After navigating to the **Preview Page**  the labels representing the track playback position and duration looks like this:

<img src="/assets/images/tutorials/108/preview_page_duration_converter.PNG" style="height:91px; width:261px"/>

Now it shows only "00:00:00" and this is consistent with the data in the **MainViewModel** . Later it will properly display the data which will be taken from the player.

## 2. ByteArrayToImageSourceConverter

In the metadata of an audio file there is present the artwork metadata field. If this field is set then it represents the image which is the track cover. It is in a form of a byte array and it is not stored anywhere directly on device as a separate file, so to display this image we can't just set the path to this, assigning byte array directly to **Image**  object is also not possible, so our solution will use the converter, which will convert byte array into **ImageSource** , which can be assigned to **_Source_** property of an **Image** object. If the given byte array is empty, then method will return the **ImageSource** with image taken from the file, which path is passed to the **Converter** method as a parameter.



_MusicPlayer/Converters/ **ByteArrayToImageSourceConverter** .cs_

<highlight>13-22</highlight>

```csharp
...

/// <summary>
/// Converts byte array to image source.
/// </summary>
/// <param name="value">Value of the byte array.</param>
/// <param name="targetType">Target type of conversion.</param>
/// <param name="parameter">Parameters of conversion.</param>
/// <param name="culture">Provides information about a specific culture.</param>
/// <returns>Image source object from byte array or cover for unknown artwork.</returns>
public object Convert(object value, Type targetType, object parameter, System.Globalization.CultureInfo culture)
{
    if (value != null)
    {
        byte[] imageAsBytes = (byte[])value;
        var stream = new MemoryStream(imageAsBytes);
        return ImageSource.FromStream(() => stream);
    }
    else
    {
        return ImageSource.FromFile((string)parameter);
    }
}

...
```

So let's explain this code step by step. If the input passed to the parameter is not null, then we create new byte array from byte array given as an input, next two lines creates the **MemoryStream** from the recently created byte array, because in the next line it is necessary to use this stream to create and return the **ImageSource** . If the given value is null, then it means that there is no any artwork attached to the file, so the image from the file specified as a converter parameter is being returned (the path to image with default cover).



This converter will be used in the **Soundtracks List Page** for the cover at the left side of the screen and in the **Preview Page**  for the cover displayed at the center. For now it will always display only the default cover, however after implementing the logic taking the tracks from the device it will display the cover assigned to the certain track. To use the converter it is again, as in a case of the **MillisecondsToTimeConverter** , nothing more to add, because in the given base code the converter is being added to the **_ResourceDictionary_** of the application under the **_x:Key_** equal to " _ByteArrayToImageSource_ ".



_MusicPlayer/Views/ **SoundtracksListPage** .xaml_

<highlight>8-9</highlight>

```xml
...
<ContentPage.Content>
    <Grid>
        ...
        <Grid.ColumnDefinitions>
            ...
        </Grid.ColumnDefinitions>
        <Image Source="{Binding CurrentTrack.Artwork, Converter={StaticResource ByteArrayToImageSource},
                        ConverterParameter='images/img_music_info_nocover.png'}"
                Grid.Row="0"
                Grid.Column="1"
                InputTransparent="True" />
        <Image Source="images/btn_music_info_play.png"
               Grid.Row="0"
               Grid.Column="1"
               VerticalOptions="Center"
               HorizontalOptions="Center" />
        ...
    </Grid>
</ContentPage.Content>
```



_MusicPlayer/Views/ **PreviewPage** .xaml_

<highlight>9-10</highlight>

```xml
...
<ContentPage.Content>
    <StackLayout Margin="97, 67, 97, 0">
        ...
        <Label Text="{Binding CurrentTrack.Artist}"
               FontSize="50"
               FontFamily="BreezeSans:style=Light"
               TextColor="#FFFFFF" />
        <Image Source="{Binding CurrentTrack.Artwork, Converter={StaticResource ByteArrayToImageSource},
                                    ConverterParameter='images/img_music_info_nocover.png'}"
               Margin="0, 79, 0, 0"
               HorizontalOptions="Center"
               VerticalOptions="Center"
               HeightRequest="578"
               WidthRequest="578" />
        ...
    </StackLayout>
</ContentPage.Content>
...
```

So as you can see, the **_Source_**  property of an **Image**  is being binded to the **_Artwork_** of a **Track** which is byte array, however it is passed to the new converter, alongside with the **_ConverterParameter_** , which is the path to the image representing default cover.



After running the project now, nothing should be changed and this is the expected behavior, because no **_Artwork_** is set for our **_CurrentTrack_** . Later after adding the logic taking the tracks from the device the covers assigned to the certain file will be automatically displayed.

## 3. BooleanToStringConverter

In the **SoundtrackListPage**  there is a left side panel with indicator if player is playing or if it is paused. It will be nice to just change the **_Source_**  of the **Image** with the path to the image, which we want to display for current state of a player. So our idea is to make the converter which will take the boolean value as an input and will output the string with path to the image, which we want to display.



_MusicPlayer/Converters/ **BooleanToStringConverter** .cs_

<highlight>13-26</highlight>

```csharp
...

/// <summary>
/// Converters boolean value to string (possible values passed as parameter).
/// </summary>
/// <param name="value">Boolean value.</param>
/// <param name="targetType">Target type of conversion.</param>
/// <param name="parameter">String array with possible values.</param>
/// <param name="culture">Provides information about a specific culture.</param>
/// <returns>Proper string for given boolean value.</returns>
public object Convert(object value, Type targetType, object parameter, System.Globalization.CultureInfo culture)
{
    string[] possibleStrings = parameter as string[];
    if (possibleStrings.Length < 2)
    {
        return string.Empty;
    }

    if ((bool)value)
    {
        return possibleStrings[0];
    }
    else
    {
        return possibleStrings[1];
    }
}

...
```

Our converter takes the parameter which should be an array of strings, so as a first step, method casts the parameter object to the string array and it checks if length of the array is not lower than 2, because we want to have 2 strings, which represent the path - one for  _true_  input value and another for  _false_ , so the value of the input is being checked and the corresponding values from array are being returned.



This converter can be used now, however to make it work and display the current state of a player it is required to implement the player service logic, which will be done later.



To use the converter there is nothing more to add, because it is already given to the **_ResourceDictionary_** of the application under the **x:Key** set to " _BooleanToString_ ". So let's just place it inside the code.



Our converter requires not only the value to be passed, but also the parameter, which is string array of possible return values, so to achieve this goal let's create such array inside the xaml part of **SoundtracksListPage** .



_MusicPlayer/Views/ **SoundtracksListPage** .xaml_

<highlight>2-7</highlight>

```xml
...
<ContentPage.Resources>
    <x:Array x:Key="ImageArray" Type="{x:Type x:String}">
        <x:String>images/btn_music_info_play.png</x:String>
        <x:String>images/btn_music_info_pause.png</x:String>
    </x:Array>
</ContentPage.Resources>
<ContentPage.Content>
    ...
</ContentPage.Content>
...

```

To create array inside xaml, you can place it inside **_Reources_** of the **ContentPage** . Then you create an array ( **x:Array** ), give it an  **_x:Key_**  - in this case " _ImageArray_ " and set **_Type_** of the array to string. Then inside the array element there are two items placed within tag " **x:String** ", which represents the string and it is the place to specify the paths to the images. Later the usage of such array and passing it to the converter is the following:



_MusicPlayer/Views/ **SoundtracksListPage** .xaml_

<highlight>7-8</highlight>

```xml
...
<Image Source="{Binding CurrentTrack.Artwork, Converter={StaticResource ByteArrayToImageSource},
                        ConverterParameter='images/img_music_info_nocover.png'}"
       Grid.Row="0"
       Grid.Column="1"
       InputTransparent="True" />
<Image Source="{Binding IsPaused, Converter={StaticResource BooleanToString},
                        ConverterParameter={StaticResource ImageArray}}"
       Grid.Row="0"
       Grid.Column="1"
       VerticalOptions="Center"
       HorizontalOptions="Center" />
...
```

**_Source_**  of the **Image**  is binded to **_IsPaused_**  property of a ViewModel (which is already present in our **MainViewModel** , beacuse we have been using this property inside **Preview Page** ), however **_IsPaused_**  is boolean value, so it is passed to our new converter **BooleanToString**  alongside with  **ImageArray** . This solution displays the **Image** we want for certain boolean value, which is passed directly from the ViewModel, so after changing the **_IsPaused_** property, appearance of the indicator will be consistent with state of the player and nothing more has to be done here.

## 4. NegateBooleanConverter

One more converter, which will be useful in our application is a converter which will just take the boolean value and return its opposite value. The code for this converter will be very simple and it will be just:



_MusicPlayer/Converters/ **NegateBooleanConverter** .cs_

<highlight>13</highlight>

```csharp
...

/// <summary>
/// Converts boolean value to opposite value.
/// </summary>
/// <param name="value">Boolean value.</param>
/// <param name="targetType">Target type of conversion.</param>
/// <param name="parameter">Parameters of conversion.</param>
/// <param name="culture">Provides information about a specific culture.</param>
/// <returns>Opposite boolean value.</returns>
public object Convert(object value, Type targetType, object parameter, CultureInfo culture)
{
    return !(bool)value;
}

...
```

This code just takes the input value and returns the negation of the input. This will be used when we will be building the logic for the information about no tracks available to play, however it will be implemented later (again it is not required to do anything more to use this converter, because it is already added to the **_ResourceDictionary_** of the application under the **_x:Key_** equal to " _NegateBoolean_ ").



This is all of the converters, which will be used in the application, as you can see they are simple, yet powerful feature. Anyway, now let's jump to the next chapter!

# V. Player

## 1. Music Content Service

Before we will be able to play any track, we have to load an audio file from a device with its metadata to be able to display information about it. To achieve this, we have to implement the **MusicContentService**  from native part of the project which implements **IMusicContentService** , thus it is accessible from the shared part of the project through **DependencyService** .



Let's jump into native part of the project and let's add few fields.



_MusicPlayer.Tizen.TV/Services/ **MusicContentService** .cs_

<highlight>5-18</highlight>

```csharp
...

#region fields

/// <summary>
/// Sample log tag for Music Player application.
/// </summary>
private const string SAMPLE_LOG_TAG = "MusicPlayerSample";

/// <summary>
/// Represents the music type in filter query.
/// </summary>
private const int TYPE_MUSIC = 3;

/// <summary>
/// An instance of MediaDatabase class.
/// </summary>
private MediaDatabase _mediaDatabase;

#endregion

...
```

The above fields represents the tag of the application, which will be displayed in the log in case of error. **_TYPE_MUSIC_** constant represents the type which we want to search in the filesystem. According to the Tizen documentation audio files are represented by the "3", so this is why this constant is set to "3". Last field **_\_mediaDatabase_**  represents an instance of the **MediaDatabase**  class which stores information about the files in the system and we will be taking the information about audio files from it. This database is updated by the system when new files appear on the device or when system is being restarted (it can be also done by the application, but we won't do this, because it takes big amount of time to update this database, so it will be better if we leave the updates to the system). To use the database, let's initialize it in the constructor of our service.



_MusicPlayer.Tizen.TV/Services/ **MusicContentService** .cs_

<highlight>10</highlight>

```csharp
...

#region methods

/// <summary>
/// MusicContentService class constructor.
/// </summary>
public MusicContentService()
{
    _mediaDatabase = new MediaDatabase();
}

...

#endregion
```

We will also add the destructor of our service which will dispose the **MediaDatabase**  to release the resources, when database won't be longer used.



_MusicPlayer.Tizen.TV/Services/ **MusicContentService** .cs_

<highlight>7-13</highlight>

```csharp
...

#region methods

...

/// <summary>
/// MusicContentService class destructor.
/// </summary>
~MusicContentService()
{
    _mediaDatabase.Dispose();
}

...

#endregion
```

Now we are ready to implement the method which is given by the **IMusicContentService** interface - **GetTracksFromDevice** which returns the list of **Track** s.



_MusicPlayer.Tizen.TV/Services/ **MusicContentService** .cs_

<highlight>7-39</highlight>

```csharp
...

#region methods

...

/// <summary>
/// Gets tracks from device.
/// </summary>
/// <returns>A collection of audio tracks.</returns>
public List<Track> GetTracksFromDevice()
{
    List<Track> tracklist = new List<Track>();
    try
    {
        _mediaDatabase.Connect();
        var selectArgs = new SelectArguments
        {
            FilterExpression = "MEDIA_TYPE = " + TYPE_MUSIC
        };

        var mediaInfoCommand = new MediaInfoCommand(_mediaDatabase);
        var selectedMedia = mediaInfoCommand.SelectMedia(selectArgs);
        while (selectedMedia.Read())
        {
            tracklist.Add(MediaInfoToTrack((AudioInfo)selectedMedia.Current));
        }
    }
    catch (Exception e)
    {
        Log.Error(SAMPLE_LOG_TAG, e.Message);
    }
    finally
    {
        _mediaDatabase.Disconnect();
    }

    return tracklist;
}

#endregion
```

This method will be responsible for providing information about the tracks stored on the device to our application. Let's go through it step by step. Firstly, the **_tracklist_** variable is being initialized - it will be later returned at the end of the method execution. The next thing is connecting to the database by executing the  **Connect**  method of the **MediaDatabase** . This will open the database connection and it will enable the possibility to search for the files. To filter out only the audio files we have to create the **SelectArguments** with proper filter expression which later will be passed to the **MediaDatabase** . We set the **_FilterExpression_** property of the **SelectArguments** equal to _"MEDIA_TYPE = " + TYPE_MUSIC_ which is basically the query filtering out only the files with MEDIA_TYPE equal to " _3_ " (audio files). Later the **MediaInfoCommand** is being created in the **MediaDatabase**  and there is variable **_selectedMedia_** being introduced which takes the **MediaDataReader**  to which **_selectedArgs_** is being passed, so only audio files is being filtered and later in the while loop during reading the result from **MediaDataReader** we are able to take the info about this files. As you can see we are adding items to the **_tracklist_**  by passing the current **_selectedMedia_**  to **MediaInfoToTrack** method which we will implement in a next snippet. Basically it takes the metadata of a file stored in  **MediaInfo** / **AudioInfo** and it creates **Track**  based on passed object. Our implementation also catches each **Exception**  and it prints the Message from the exception to the **Log**  under the tag specified in the **_SAMPLE_LOG_TAG_** constant. After all of the above operations method disconnects from the database and returns the **_tracklist_**  which now is filled with **Track** objects. Now let's implement missing  **MediaInfoToTrack** method.



_MusicPlayer.Tizen.TV/Services/ **MusicContentService** .cs_

<highlight>7-24</highlight>

```csharp
...

#region methods

...

/// <summary>
/// Converts 'AudioInfo' object to 'Track' object.
/// </summary>
/// <param name="audioInfo">'AudioInfo' object which is to be converted.</param>
/// <returns>Created 'Track' object.</returns>
private Track MediaInfoToTrack(AudioInfo audioInfo)
{
    MetadataEditor metadataEditor = new MetadataEditor(audioInfo.Path);
    int pictureCount = metadataEditor.PictureCount;
    byte[] art = null;
    if (pictureCount > 0)
    {
        Artwork artwork = metadataEditor.GetPicture(0);
        art = artwork.Data;
    }

    return new Track(audioInfo.Title, audioInfo.Artist, audioInfo.Album, art, audioInfo.Path, audioInfo.Duration);
}

#endregion
```

As you can see this method takes the **AudioInfo** as an argument and later it creates the **MetadataEditor**  object initialized with **_Path_** of the **_audioInfo_** . It takes the number of assigned pictures to the file and creates byte array which is set to _null_ . Byte array is later used for assigning the first artwork from the file if number of the pictures assigned is bigger than 0. At the end it returns the new **Track** object with properties corresponding to the properties of the file.



Actually it is the end of the implementation of the **MusicContentService** , however to use it inside the shared part of the project we have to complete few more things. First is to implement some methods inside the **PlayerModel** , so it can utilize the service methods and work as proxy between the service and the ViewModel, to do that just let's go to the next step!

## 2. Usage of the MusicContentService (PlayerModel)

**PlayerModel**  will allow to handle all of the things related to providing the information about the tracks and managing the player. Also it will allow to control the player from the other classes (in our case from the **MainViewModel** ). Firstly, we will implement usage of the **MusicContentService**  to load the information about the tracks to the **PlayerModel** and to display this information on the **SoundtrackListPage** .



_MusicPlayer/Models/ **PlayerModel** .cs_

<highlight>5-8,14-17,28-29</highlight>

```csharp
...

#region fields

/// <summary>
/// Instance of music content service.
/// </summary>
private IMusicContentService _musicContentService;

#endregion

#region properties

/// <summary>
/// Collection of loaded tracks.
/// </summary>
public List<Track> Tracks { get; private set; }

#endregion

#region methods

/// <summary>
/// Initializes class instance.
/// </summary>
public PlayerModel()
{
    _musicContentService = DependencyService.Get<IMusicContentService>();
    Tracks = _musicContentService.GetTracksFromDevice();
}

#endregion
```

We define the field **_\_musicContentService_**  which later in constructor is being initialized through the **DependencyService**  which provides the correct implementation of the **IMusicContentService** for the current system platform. From now on,  **MusicContentService**  is ready to use in the **PlayerModel** , so as a first thing we assign the result of the **GetTracksFromDevice()**  method from the service to the **_Tracks_**  property defined before. **_Tracks_** property now holds all of the information about the tracks stored on the device. However, to display this information on the **SoundtracksListPage** we have to make few improvements inside **MainViewModel** .



_MusicPlayer/ViewModels/ **MainViewModel** .cs_

<highlight>7-10,20,36</highlight>

```csharp
...

#region fields

...

/// <summary>
/// Current player model.
/// </summary>
private PlayerModel _musicPlayerModel;

#endregion

#region properties

...

public List<Track> Tracks
{
    get => _musicPlayerModel.Tracks;
}

...

#endregion

#region methods

/// <summary>
/// Initializes class instance.
/// </summary>
public MainViewModel()
{
    _navigation = DependencyService.Get<IViewNavigation>();
    CurrentTrack = new Track("Title", "Artist", "Album", null, "somepath", 0);
    _musicPlayerModel = new PlayerModel();

    TrackProgress = 0.4;

    TrackPlaybackPosition = 0;

    InitCommands();
}

...

#endregion

```

We have created the new field **_\_playerModel_**  which is supposed to be the instance of the **PlayerModel** class. **PlayerModel**  is now able to provide the tracks which are present on the device and it provides it through **_Tracks_** property, so we are now returning the list of tracks from the **_\_playerModel_**  on **MainViewModels**   **_Tracks_** property getter. Because our **_Tracks_** property is now returning the **_Tracks_** property of a **PlayerModel** , we can delete the initialization of the **_Tracks_** inside the constructor of a ViewModel and instead of that we can just initialize the **_\_musicPlayerModel_** field.



After buidling and launching the project on the device you will see nothing on the list, but don't worry! It is caused by lack of any audio files on your device storage. So let's upload some tracks on the device! To achieve that perform the following steps:



Now files should be present on the emulator storage and visible in the MusicPlayer application.

<img src="/assets/images/tutorials/108/player_model_music_content_service.png" style="height:480px; width:853px"/>

## 3. Selecting the current track

Now as we have the actual tracks listed on the **SoundtracksListPage** , we can implement selecting the current track. **ScrollableGrid** custom control already provides the property which allows to bind own  **Command**  to, so let's add this command to our ViewModel.



_MusicPlayer/ViewModels/ **MainViewModel** .cs_

<highlight>7-10,24,29-36</highlight>

```csharp
...

#region properties

...

/// <summary>
/// Command which sets as current track selected track.
/// </summary>
public ICommand SelectTrackCommand { get; private set; }

#endregion

#region methods

...

/// <summary>
/// Initializes commands.
/// </summary>
private void InitCommands()
{
    ...
    SelectTrackCommand = new Command<int>(ExecuteSelectTrack);
}

...

/// <summary>
/// Handles the execution of "SelectTrackCommand"
/// </summary>
/// <param name="index">Index of the selected track.</param>
private void ExecuteSelectTrack(int index)
{
    _musicPlayerModel.SetTrack(index, true);
}

#endregion
```

We create the property which will represent our **Command**  and later we initialize it with the **ExecuteSelectTrack** method taking the integer as parameter ( **ScrollableGrid**  on item selection passes and index of the item in the list). Method executes **SetTrack** method of a **PlayerModel** which is not implemented yet, so we have to create this method now.



_MusicPlayer/Models/ **PlayerModel** .cs_

<highlight>5-8,16-27,29-32,44-48,53-61</highlight>

```csharp
#region fields

...

/// <summary>
/// Current track.
/// </summary>
private Track _currentTrack;

#endregion

#region properties

...

/// <summary>
/// Current track.
/// </summary>
public Track CurrentTrack
{
    get => _currentTrack;
    private set
    {
        _currentTrack = value;
        CurrentTrackChanged?.Invoke(this, new EventArgs());
    }
}

/// <summary>
/// Event invoked when current track is changed.
/// </summary>
public event EventHandler CurrentTrackChanged;

#endregion

#region methods

/// <summary>
/// Initializes class instance.
/// </summary>
public PlayerModel()
{
    ...
    CurrentTrack = new Track(string.Empty, string.Empty, string.Empty, null, string.Empty, 0);
    if (Tracks.Count > 0)
    {
        CurrentTrack = Tracks[0];
    }
}

...

/// <summary>
/// Changes current track to track with certain index in the tracklist.
/// </summary>
/// <param name="index">Index in the tracklist.</param>
/// <param name="play">Indicates if player should start playback.</param>
public void SetTrack(int index, bool play)
{
    CurrentTrack = Tracks[index];
}

#endregion
```

**SetTrack**  method is supposed to set the current track (and later also load it to the player and start playing if second argument is  _true_ ). That's why we have added the **\_currentTrack** backing field, because later we are using it inside getter and setter of **_CurrentTrack_** property. We also initialized the **_CurrentTrack_** with empty values and if there is any track in the **_Tracks_** then we set **_CurrentTrack_** to the first **_Track_** in the list. We have also added an event  **_CurrentTrackChanged_**  which is later fired each time when **_CurrentTrack_** is being set. This is for informing the ViewModel about changing the **_CurrentTrack_** property, so it can update its own properties and it can reflect the change on the View. We have to handle this event in the **MainViewModel** .



_MusicPlayer/ViewModels/ **MainViewModel** .cs_

<highlight>11-13,28,35-43</highlight>

```csharp
...

#region properties

...

/// <summary>
/// Gets current track.
/// </summary>
public Track CurrentTrack
{
    get => _musicPlayerModel.CurrentTrack;
}

...

#endregion

#region methods

/// <summary>
/// Initializes class instance.
/// </summary>
public MainViewModel()
{
    ...

    _musicPlayerModel.CurrentTrackChanged += OnCurrentTrackChanged;

    ...
}

...

/// <summary>
/// Handles an event of changing the current track.
/// </summary>
/// <param name="sender">Sender of the event.</param>
/// <param name="eventArgs">Event arguments.</param>
private void OnCurrentTrackChanged(object sender, EventArgs eventArgs)
{
    OnPropertyChanged(nameof(CurrentTrack));
}

#endregion
```

We have to change the getter of the **_CurrentTrack_** property to provide the data stored in the **PlayerModel** . That's the reason for which we can delete the initialization of the **_CurrentTrack_** from the **MainViewModel** constructor. We also set, in the constructor, the handler for the **_CurrentTrackChanged_** event fired by **PlayerModel** . The handler **CurrentTrackChanged** just executes **OnPropertyChanged** for the **_CurrentTrack_** property. This ensures that data displayed on the view is up to date with the data inside the **_\_musicPlayerModel_** object. There is still one more thing to add. We haven't binded **_Command_** property of the **ScrollableGrid**  to **_SelectTrackCommand_** of a **MainViewModel** . So let's just add this.



_MusicPlayer/Views/ **SoundtracksListPage** .xaml_

<highlight>14</highlight>

```xml
...
<ContentPage.Content>
    ...
    <Grid>
        ...
        <controls:ScrollableGrid Rows="4"
                                 ItemsSource="{Binding Tracks}"
                                 Grid.Column="3"
                                 Grid.Row="0"
                                 Grid.RowSpan="2"
                                 WidthOfItem="570"
                                 SpaceBetweenColumns="25"
                                 HeightOfItem="134"
                                 Command="{Binding SelectTrackCommand}">
            ...
         </controls:ScrollableGrid>
    </Grid>
</ContentPage.Content>
...

```

Now after building and launching the the application you will be able to select the track from the soundtracks list and you will see that the information about the current track at the left side of the screen is being updated. You will also see the covers assigned to the tracks, because we have done everything what was required to add this feature before ( **Image _Source_** ** property is binded to the \***Artwork**_ property of the _**CurrentTrack\*\*\* and passed through converter).

<img src="/assets/images/tutorials/108/selecting_track_soundtracklists_page.png" style="height:480px; width:853px"/>

As we have only one ViewModel which is common for **SoundtracksListPage** and **PreviewPage**  the current track is also updated on the **Preview Page** .

<img src="/assets/images/tutorials/108/selecting_track_preview_page.png" style="height:480px; width:853px"/>

So while we can list the tracks present on the device and we can select the current track let's now try to play these tracks!

## 4. Player Service

As we now have all of the information about the tracks stored on the device, we are ready to play them. To achieve that we have to implement methods of the **IPlayerService** inside **PlayerService** of the native part of the project and this methods will be accessible through the object given by the **DependencyService** in the shared part of the project. Few things are already present inside the **PlayerService** , but they are not yet implemented, so as a first thing let's add few fields.



_MusicPlayer.Tizen.TV/Services/ **PlayerService** .cs_

<highlight>7-11,13-17</highlight>

```csharp
...

#region fields

...

/// <summary>
/// An instance of TizenFX API player.
/// Handles actual playback operations.
/// </summary>
private Player _player;

/// <summary>
/// Snapshot of the playback state.
/// Used to determine if state was changed since last check (change event invoking).
/// </summary>
private bool _lastPlayState = false;

#endregion

...

```

**_\_player_** field is an instance of the **Player**  from Tizen.Multimedia API. Using this object will allow to load and play the music as well as managing the play/pause functionality and seeking the playback position. The **_\_lastPlayState_**  is used for remembering the last state of the player ( _true_  if player is playing the audio or  _false_  if it is paused). It is also returned in the **_Playing_**  property getter which defines if player is currently playing or not.



_MusicPlayer.Tizen.TV/Services/ **PlayerService** .cs_

<highlight>5,7-18</highlight>

```csharp
...

#region properties

public bool Playing => _lastPlayState;

public int PlaybackPosition
{
    get
    {
        if (_player.State != PlayerState.Idle && _player.State != PlayerState.Preparing)
        {
            return _player.GetPlayPosition();
        }

        return 0;
    }
}

#endregion
```

**_PlaybackPosition_** property has quite more complex getter, but the idea is simple. It returns the playback position in milliseconds (taken from the **Player** object) if player is not in the _Idle_ state and if it is not currently preparing. Otherwise it gives 0. This property will be later used inside the **MainViewModel** to update the progress of the **_CurrentTrack_** . Next we will initialize the **_\_player_** inside the constructor.



_MusicPlayer.Tizen.TV/Services/ **PlayerService** .cs_

<highlight>10-11</highlight>

```csharp
...

#region methods

/// <summary>
/// Initializes a new instance of the service class.
/// </summary>
public PlayerService()
{
    _player = new Player();
    _player.PlaybackCompleted += PlayerOnPlaybackCompleted;
}

...

#endregion
```

We also assign the handler for the **_PlaybackCompleted_** event of the **Player** , so let's add the body of this handler.



_MusicPlayer.Tizen.TV/Services/ **PlayerService** .cs_

<highlight>7-17</highlight>

```csharp
...

#region methods

...

/// <summary>
/// Handles playback completion event from internal player (TizenFX API).
/// Updates playback state and invokes own (class) playback completion event.
/// </summary>
/// <param name="sender">Event sender.</param>
/// <param name="eventArgs">Event arguments.</param>
private void PlayerOnPlaybackCompleted(object sender, EventArgs eventArgs)
{
    CheckPlayStateChange();
    PlaybackCompleted?.Invoke(this, new EventArgs());
}

#endregion
```

As you can see this handler executes **CheckPlayStateChange** , which we will implement soon and it fires the  **_PlaybackCompleted_** event, so the objects which subscribed for it are informed that the playback of the track is finished.



_MusicPlayer.Tizen.TV/Services/ **PlayerService** .cs_

<highlight>7-19</highlight>

```csharp
...

#region methods

...

/// <summary>
/// Checks if playback state (internal player) has changed.
/// If so, it updates state snapshot and invokes state change event.
/// </summary>
private void CheckPlayStateChange()
{
    bool playing = _player.State == PlayerState.Playing;
    if (_lastPlayState != playing)
    {
        _lastPlayState = playing;
        PlayStateChanged?.Invoke(this, new EventArgs());
    }
}

#endregion
```

**CheckPlayStateChange** method checks if the current state of the **Player** from the Tizen.Multimedia API \***_ is equal to _**Playing**_ and if it is other than the state of a player remembered in the _**\_lastPlayState**_  then the _**\_lastPlayState*** is changed to *true*  if player is currently playing or *false* if it is in the other state. Also the ***PlayStateChanged**\* is being invoked, so the other objects are being informed that the state of a **Player\*\* is changed. The next thing which we are going to implement is the method which will load the audio to the player and will start the playback if it is specified in the method arguments.



_MusicPlayer.Tizen.TV/Services/ **PlayerService** .cs_

<highlight>18-47</highlight>

```csharp
...

#region methods

...

/// <summary>
/// Asynchronously loads specified audio file (by path) into player.
/// The playback can be automatically started by setting "play" parameter (false by default).
/// </summary>
/// <param name="path">Path to the audio file.</param>
/// <param name="play">Indicates if playback should be automatically started as soon as file is loaded.</param>
/// <returns>
/// A task that represents the asynchronous operation.
/// The task result indicates if operation completes successfully.</returns>
public async Task<bool> Load(string path, bool play = false)
{
    try
    {
        if (_player.State == PlayerState.Playing)
        {
            _player.Stop();
        }

        _player.Unprepare();

        _player.IsLooping = false;

        _player.SetSource(new MediaUriSource("file://" + path));

        await _player.PrepareAsync();
        await _player.SetPlayPositionAsync(0, false);

        if (play)
        {
            _player.Start();
        }

        CheckPlayStateChange();

        return true;
    }
    catch (Exception)
    {
        CheckPlayStateChange();
        return false;
    }
}

...

#endregion
```

This method is an asynchronous method, so it doesn't block the main thread. This is required, because loading the audio file can take the long time and while we won't make this method asynchronous one, then the UI of our application could freeze. It also returns the **Task<bool>** , which basically means that this method returns an information if the execution was successful or not. Method arguments are the path to the audio file and boolean value indicating if we want to start the playback immediately after loading the track or not. Method, during its execution, checks if player is currently in a playing state, if it is then it stops the player. Later it runs the **Unprepare** method of the **Player**  which just resets the source of the player, so the previously loaded file is no longer associated with the player. Method sets the **_IsLooping_** property of the player to _false_ , so the audio files won't play in a loop, later it sets the source of the **Player**  by the **SetSource**  method providing as an argument the **MediaUriSource**  object initialized with the path to the track given in the **Load** method arguments. As a next step the asynchronous method - **PrepareAsync** of the  **Player**  is executed which prepares the player for the playback. After that also asynchronous  **SetPlayPositionAsync** method is executed which sets the playback position of a player to the begining of the track. If the second argument of the **Load** method is _true_  then the **Start** method is executed and the player starts playing the loaded track. At the end **Load**  runs the **CheckPlayStateChange**  to update state of the player and it returns  _true_  because the execution was successful. If any Exception occurs during the execution then the  **CheckPlayStateChange**  is called and  _false_  is returned, because the method execution failed.



_MusicPlayer.Tizen.TV/Services/ **PlayerService** .cs_

<highlight>13-17,26-30</highlight>

```csharp
...

#region methods

...

/// <summary>
/// Asynchronously starts/resumes the playback.
/// </summary>
/// <returns>A task that represents the asynchronous operation.</returns>
public Task Play()
{
    return Task.Run(() =>
    {
        _player.Start();
        CheckPlayStateChange();
    });
}

/// <summary>
/// Asynchronously pauses the playback.
/// </summary>
/// <returns>A task that represents the asynchronous operation.</returns>
public Task Pause()
{
    return Task.Run(() =>
    {
        _player.Pause();
        CheckPlayStateChange();
    });
}

...

#endregion
```

Next two methods are the **Play** and **Pause** method. These methods runs the **Play** / **Pause** method of the native  **Player** in the background \***\* by running the separate **Task** . After performing the operation it runs the **CheckPlayStateChange\*\* method which updates the state of a player.



_MusicPlayer.Tizen.TV/Services/ **PlayerService** .cs_

<highlight>14-15</highlight>

```csharp
...

#region methods

...

/// <summary>
/// Asynchronously sets position of the playback (milliseconds).
/// </summary>
/// <param name="msec">The value indicating a desired position in milliseconds.</param>
/// <returns>A task that represents the asynchronous operation.</returns>
public async Task SeekTo(int msec)
{
    await _player.SetPlayPositionAsync(msec, false);
    CheckPlayStateChange();
}

...

#endregion
```

The last method which we are implementing inside the **PlayerService** class is the asynchronous  **SeekTo**  method which allows to set the playback position of a player to the number of milliseconds given as the method arguments. It just runs the **SetPlayPositionAsync** method of the native **Player**  and after that it runs **CheckPlayStateChange** to update the information about the state of the player.



This is the whole implementation of the native part of the player. All of the methods implemented allow us to manage the work of the Tizen.Multimedia **Player** . To check out how this works again, like in the case of the **MusicContentService** , \***\* we have to implement few things inside **PlayerModel\*\* .

## 5. Usage of the PlayerService (PlayerModel)

So now let's try to utilize the native part of the PlayerService through the **PlayerModel** . For now our goal is to be able to play the tracks after selecting them on the tracklist located on the **SoundtracksListPage** . As usual we have to add few fields to achieve the goal.



_MusicPlayer/Models/ **PlayerModel** .cs_

<highlight>12-15,17-20,22-25</highlight>

```csharp
...

#region fields

...

/// <summary>
/// Event invoked when current track is changed.
/// </summary>
public event EventHandler CurrentTrackChanged;

/// <summary>
/// Instance of player service.
/// </summary>
private IPlayerService _player;

/// <summary>
/// Event invoked when playback state is changed.
/// </summary>
public event EventHandler PlaybackStateChanged;

/// <summary>
/// Step of single seek operation (in milliseconds).
/// </summary>
private const int SEEK_STEP = 5000;

#endregion

...
```

First added field is the **_\_player_** field of a **IPlayerService**  which will be used to represent the **PlayerService** of the native part of the project. Second field is an **EventHandler _PlaybackStateChanged_** which is going to be invoked when the state of the playback is changed (based on raising an event by the **PlayerService** ). The last introduced field is the constant representing the number of milliseconds which the playback position is going to be moved each time when the track is being rewinded/forwarded.



_MusicPlayer/Models/ **PlayerModel** .cs_

<highlight>20-26,28-35,37-51</highlight>

```csharp
...

#region properties

...

/// <summary>
/// Current track.
/// </summary>
public Track CurrentTrack
{
    get => _currentTrack;
    private set
    {
        _currentTrack = value;
        CurrentTrackChanged?.Invoke(this, new EventArgs());
    }
}

/// <summary>
/// Indicates if there is ongoing playback.
/// </summary>
public bool Playing
{
    get => _player.Playing;
}

/// <summary>
/// Current playback position (in milliseconds).
/// In case of no loaded file, 0 value is returned.
/// </summary>
public int PlaybackPosition
{
    get => _player.PlaybackPosition;
}

/// <summary>
/// Progress of the ongoing track as value from 0 to 1.
/// </summary>
public double Progress
{
    get
    {
        if (CurrentTrack.Duration == 0)
        {
            return 0;
        }

        return (double)PlaybackPosition / (double)CurrentTrack.Duration;
    }
}

#endregion
```

**_Playing_** is the boolean property which at its getter just returns **_Playing_** property of the **PlayerService** . This enables the possibility for the ViewModel to check the current state of the player. Similarly to **_Playing_** -  **_PlaybackPosition_** property is just returning the **_PlaybackPosition_** property of the **PlayerService** . The last property which we are adding to the **PlayerModel** is the **_Progress_** property. This will return the current progress of the track as a value between 0 and 1. Firstly, if the **_CurrentTrack_** duration is equal to 0 it means that it is at the beginning, so to avoid dividing by 0 - just 0 is being returned. In the other case the **_PlaybackPosition_**  of a **PlayerModel**  is being divided by **_Duration_** of a **_CurrentTrack_** which gives us the expected result.



_MusicPlayer/Models/ **PlayerModel** .cs_

<highlight>13-15,22-25</highlight>

```csharp
...

#region methods

/// <summary>
/// Initializes class instance.
/// </summary>
public PlayerModel()
{
    _musicContentService = DependencyService.Get<IMusicContentService>();
    Tracks = _musicContentService.GetTracksFromDevice();
    CurrentTrack = new Track(string.Empty, string.Empty, string.Empty, null, string.Empty, 0);
    _player = DependencyService.Get<IPlayerService>();
    _player.PlayStateChanged += OnPlaybackStateChanged;
    _player.PlaybackCompleted += OnPlaybackCompleted;

    if (Tracks.Count > 0)
    {
        CurrentTrack = Tracks[0];
    }

    if (_player.PlaybackPosition == 0)
    {
        _player.Load(CurrentTrack.Path, false);
    }
}

...

#endregion
```

We have to get the proper implementation of the **IPlayerService** from the **DependencyService** . Later we add the handlers for its events (we will implement them in the next snippet). We also add the condition if the **_PlaybackPosition_** of the **_\_player_** is equal to 0 then we load the **_CurrentTrack_** to the **Player** .



_MusicPlayer/Models/ **PlayerModel** .cs_

<highlight>7-15,17-25</highlight>

```csharp
...

#region methods

...

/// <summary>
/// Event handler for changing the playback state of player.
/// </summary>
/// <param name="sender">Sender of the event.</param>
/// <param name="e">Event arguments.</param>
private void OnPlaybackStateChanged(object sender, EventArgs e)
{
    PlaybackStateChanged?.Invoke(this, new EventArgs());
}

/// <summary>
/// Event handler for completing the playback.
/// </summary>
/// <param name="sender">Sender of the event.</param>
/// <param name="e">Event arguments.</param>
private void OnPlaybackCompleted(object sender, EventArgs e)
{

}

#endregion
```

When **OnPlaybackStateChanged** \***\* handler is executing we just want to inform the ViewModel that the state of the **Player** is changed, that's why we are just invoking the \***PlaybackStateChanged**\* event of the **PlayerModel** . **OnPlaybackCompleted**  will be implemented later, during the implementation of the **PreviewPage\*\* buttons logic.



_MusicPlayer/Models/ **PlayerModel** .cs_

<highlight>15</highlight>

```csharp
...

#region methods

...

/// <summary>
/// Changes current track to track with certain index in the tracklist.
/// </summary>
/// <param name="index">Index in the tracklist.</param>
/// <param name="play">Indicates if player should start playback.</param>
public void SetTrack(int index, bool play)
{
    ...
    _player.Load(CurrentTrack.Path, play);
}

...

#endregion
```

The last thing inside the **PlayerModel** , which will make us to achieve our goal for this part of tutorial is this one line inside the **SetTrack** method which is being called by the handler of the **_SelectTrackCommand_** of the **MainViewModel** . This just loads the **_CurrentTrack_** which is already changed and it starts the playback if second argument of the **SetTrack** is _true_ .



Now after building and running the application you will be able to listen to the tracks after selecting them, so we have achieved our goal!

<img src="/assets/images/tutorials/108/selecting_track_soundtracklists_page.png" style="height:480px; width:853px"/>

# VI. Finishing touches

## 1. Soundtracks list item template (TrackListViewCell)

What is still required to achieve our goals, regarding the **SoundtracksListPage** , is the appearance of the single item in the list. For now, it displays only the three labels. Template is specified directly inside the **SoundtrackListPage** xaml part. What we want to achieve is to have the item template which displays the artwork of the album (if it exists) and presents the title of the track as well as the artists and albums name. It will be also nice to have it in a separate part of the project, not directly inside the **SoundtrackListPage** xaml part.

<img src="/assets/images/tutorials/108/soundtrack_list_item_template_zoom.PNG" style="height:447px; width:926px"/>

Our code responsible for the appearance of the single item will be placed inside the **\*TrackListViewCell** .xaml\* .



_MusicPlayer/Control/ **TrackListViewCell** .xaml_

<highlight>4-5,7-40</highlight>

```xml
<ContentView xmlns="http://xamarin.com/schemas/2014/forms"
             xmlns:x="http://schemas.microsoft.com/winfx/2009/xaml"
             x:Class="MusicPlayer.Control.TrackListViewCell"
             x:Name="Root"
             BackgroundColor="#1b1b1b">
    <ContentView.Content>
        <Grid>
            <Grid.RowDefinitions>
                <RowDefinition Height="Auto" />
            </Grid.RowDefinitions>
            <Grid.ColumnDefinitions>
                <ColumnDefinition Width="Auto" />
                <ColumnDefinition Width="*" />
            </Grid.ColumnDefinitions>
            <Image Source="{Binding Artwork, Converter={StaticResource ByteArrayToImageSource},
                   Source={x:Reference Root}, ConverterParameter='images/img_music_info_nocover.png'}"
                   Grid.Row="0"
                   Grid.Column="0"
                   WidthRequest="134"
                   HeightRequest="134" />
            <StackLayout Grid.Row="0"
                         Grid.Column="1">
                <Label Text="{Binding Title, Source={x:Reference Root}}"
                       FontSize="55"
                       TextColor="#FFFFFF"
                       Margin="20, 10, 0, 0"
                       LineBreakMode="TailTruncation" />
                <Label Text="{Binding Artist, Source={x:Reference Root}}"
                       FontSize="42"
                       TextColor="#FFFFFF"
                       Margin="20, 0, 0, 0"
                       LineBreakMode="TailTruncation" />
                <Label Text="{Binding Album, Source={x:Reference Root}}"
                       FontSize="42"
                       FontFamily="BreezeSans:style=Light"
                       TextColor="#FFFFFF"
                       Margin="20, -6, 0, 0"
                       LineBreakMode="TailTruncation" />
            </StackLayout>
        </Grid>
    </ContentView.Content>
</ContentView>
```

The above code firstly sets the property **_BackgroundColor_** of the **ContentView**  to the color which we want to have in a background, it also specifies the **_x:Name_**  to " _Root_ ", so we can bind properties to the properties present inside the code behind part of our item view. We create a **Grid** inside which, in a first column and first row, we place the **Image**  which **_Source_** is binded to the **_Artwork_**  inside code behind part - which is passed through the **ByteArrayToImageSourceConverter** with **_ConverterParameter_** set to the path to the image of a default cover. The **_Height_** of the only row of the **Grid** is set to _Auto_ , so that's why we specify directly the **_Height_** and **_Width_** of the **Image** , so the **Grid** can fit the cell properly. In the second column **Labels**  are being placed in the **StackLayout** , which **_Texts_** properties are binded to the corresponding properties inside the code behind part. There also one more property of a **Label** being set - **_LineBreakMode_** . If it is set to the _TailTruncation_ it cuts the text if it doesn't fit to the given space and it places the "..." at the end of the label. Now let's just add the missing properties to code behind.



_MusicPlayer/Control/ **TrackListViewCell** .xaml.cs_

<highlight>5-13,15-22,24-32,34-41,43-51,53-60,62-70,72-79</highlight>

```csharp
...

#region properties

/// <summary>
/// Allows to set title of the track item.
/// </summary>
public static readonly BindableProperty TitleProperty = BindableProperty.Create(
                                        nameof(Title),
                                        typeof(string),
                                        typeof(TrackListViewCell),
                                        "",
                                        BindingMode.OneWay);

/// <summary>
/// Gets or sets title of the track item.
/// </summary>
public string Title
{
    get => (string)GetValue(TitleProperty);
    set => SetValue(TitleProperty, value);
}

/// <summary>
/// Allows to set artist of the track item.
/// </summary>
public static readonly BindableProperty ArtistProperty = BindableProperty.Create(
                                        nameof(Artist),
                                        typeof(string),
                                        typeof(TrackListViewCell),
                                        "",
                                        BindingMode.OneWay);

/// <summary>
/// Gets or sets artist of the track item.
/// </summary>
public string Artist
{
    get => (string)GetValue(ArtistProperty);
    set => SetValue(ArtistProperty, value);
}

/// <summary>
/// Allows to set album of the track item.
/// </summary>
public static readonly BindableProperty AlbumProperty = BindableProperty.Create(
                                        nameof(Album),
                                        typeof(string),
                                        typeof(TrackListViewCell),
                                        "",
                                        BindingMode.OneWay);

/// <summary>
/// Gets or sets album of the track item.
/// </summary>
public string Album
{
    get => (string)GetValue(AlbumProperty);
    set => SetValue(AlbumProperty, value);
}

/// <summary>
/// Allows to set artwork of the track item.
/// </summary>
public static readonly BindableProperty ArtworkProperty = BindableProperty.Create(
                                        nameof(Artwork),
                                        typeof(byte[]),
                                        typeof(TrackListViewCell),
                                        null,
                                        BindingMode.OneWay);

/// <summary>
/// Gets or sets artwork of the track item.
/// </summary>
public byte[] Artwork
{
    get => (byte[])GetValue(ArtworkProperty);
    set => SetValue(ArtworkProperty, value);
}

#endregion
```

This code creates the **BindableProperties** inside code behind, so we can utilize these properties inside the xaml part of the **TrackListViewCell**  and we can specify the bindings later inside the **SoundtracksListPage** , so we will display the correct information about the tracks. Now our item template is ready to use, so let's place it as the **_ItemTemplate_** of the **ScrollableGrid** .



_MusicPlayer/Views/ **SoundtracksListPage** .xaml_

<highlight>16-20</highlight>

```xml
...
<ContentPage.Content>
    <Grid>
        ...
        <controls:ScrollableGrid Rows="4"
                                 ItemsSource="{Binding Tracks}"
                                 Grid.Column="3"
                                 Grid.Row="0"
                                 Grid.RowSpan="2"
                                 WidthOfItem="570"
                                 SpaceBetweenColumns="25"
                                 HeightOfItem="134"
                                 Command="{Binding SelectTrackCommand}">
            <controls:ScrollableGrid.ItemTemplate>
                <DataTemplate>
                    <controls:TrackListViewCell
                        Title="{Binding Title}"
                        Artist="{Binding Artist}"
                        Album="{Binding Album}"
                        Artwork="{Binding Artwork}" />
                </DataTemplate>
            </controls:ScrollableGrid.ItemTemplate>
        </controls:ScrollableGrid>
    </Grid>
</ContentPage.Content>


```

So we replace the **Labels**  in the **_ItemTemplate_**  with our **TrackListViewCell** with the properties binded to the corresponding properties of the **Tracks** present in the **_ItemSource_** of the **ScrollableGrid** . After rebuilding and running the application we should see the expected (and final) appearance of the Soundtracks List with the single item represented as a track cover at the left side of it and the information about the track at the right.

<img src="/assets/images/tutorials/108/soundtrack_list_item_template.png" style="height:480px; width:853px"/>

## 2. Preview Page buttons logic

We are able to select the track which we want to play, but still we can't control the playback and we can't change the track from the Preview Page. That's because of the lack of proper methods inside the **PlayerModel**  and usage of these methods in the methods handling the **Commands** execution of the **PreviewPage** buttons. We will add these methods now, so we will enable the possibility for our player to begin to work as expected and to become fully functional.



_MusicPlayer/Models/ **PlayerModel** .cs_

<highlight>7-82</highlight>

```csharp
...

#region methods

...

/// <summary>
/// Changes track to previous.
/// </summary>
public void Previous()
{
    if (Tracks.Count == 0)
    {
        return;
    }

    int index = Tracks.FindIndex(x => x.Path == CurrentTrack.Path);
    if (index - 1 < 0)
    {
        index = Tracks.Count - 1;
    }
    else
    {
        index--;
    }

    SetTrack(index, Playing);
}

/// <summary>
/// Seeks ongoing track backward.
/// </summary>
public void Rewind()
{
    _player.SeekTo(_player.PlaybackPosition - SEEK_STEP);
}

/// <summary>
/// Plays or pauses current track.
/// </summary>
public void PlayOrPause()
{
    if (_player.Playing)
    {
        _player.Pause();
    }
    else
    {
        _player.Play();
    }
}

/// <summary>
/// Seeks ongoing track forward.
/// </summary>
public void Forward()
{
    _player.SeekTo(_player.PlaybackPosition + SEEK_STEP);
}

/// <summary>
/// Changes track to next.
/// </summary>
public void Next()
{
    if (Tracks.Count == 0)
    {
        return;
    }

    int index = Tracks.FindIndex(x => x.Path == CurrentTrack.Path);
    if (index + 1 >= Tracks.Count)
    {
        index = 0;
    }
    else
    {
        index++;
    }

    SetTrack(index, Playing);
}

#endregion
```

Let's go through each of the implemented methods:

As we have all of the methods which are required to manage the playback of the tracks, before we will utilize those methods, we will add the body of the **OnPlaybackCompleted** method which handles the **_PlaybackCompleted_** event of the player.



_MusicPlayer/Models/ **PlayerModel** .cs_

<highlight>14</highlight>

```csharp
...

#region methods

...

/// <summary>
/// Event handler for completing the playback.
/// </summary>
/// <param name="sender">Sender of the event.</param>
/// <param name="e">Event arguments.</param>
private void OnPlaybackCompleted(object sender, EventArgs e)
{
    Next();
}

...

#endregion
```

We just execute the **Next** method of the **PlayerModel** , because what we want to achieve is the change to the next track if the playback of the current track is completed.



Now let's execute the **PlayerModel** 's methods in the handlers of the **Commands**  executed after pressing the buttons on the **PreviewPage** .



_MusicPlayer/ViewModels/ **MainViewModel** .cs_

<highlight>12,28,40,48,56,64,72,77-85</highlight>

```csharp
...

#region properties

...

/// <summary>
/// Determines if track is paused.
/// </summary>
public bool IsPaused
{
    get => !_musicPlayerModel.Playing;
}

...

#endregion

#region methods

/// <summary>
/// Initializes class instance.
/// </summary>
public MainViewModel()
{
    ...

    _musicPlayerModel.PlaybackStateChanged += OnPlaybackStateChanged;

    ...
}

...

/// <summary>
/// Handles the execution of "GoToPreviousTrackCommand"
/// </summary>
private void GoToPreviousTrack()
{
    _musicPlayerModel.Previous();
}

/// <summary>
/// Handles the execution of "RewindTrackCommand"
/// </summary>
private void RewindTrack()
{
    _musicPlayerModel.Rewind();
}

/// <summary>
/// Handles the execution of "PlayOrPauseTrackCommand"
/// </summary>
private void PlayOrPauseTrack()
{
    _musicPlayerModel.PlayOrPause();
}

/// <summary>
/// Handles the execution of "ForwardTrackCommand"
/// </summary>
private void ForwardTrack()
{
    _musicPlayerModel.Forward();
}

/// <summary>
/// Handles the execution of "GoToNextTrackCommand"
/// </summary>
private void GoToNextTrack()
{
    _musicPlayerModel.Next();
}

...

/// <summary>
/// Handles an event of changing the playback state of player.
/// </summary>
/// <param name="sender">Sender of the event.</param>
/// <param name="eventArgs">Event arguments.</param>
private void OnPlaybackStateChanged(object sender, EventArgs eventArgs)
{
    OnPropertyChanged(nameof(IsPaused));
}

#endregion
```

We changed the getter of the **_IsPaused_** property to return the negation of the  **PlayerModel** 's  **_Playing_** property. We have added also the handler for the **_PlaybackStateChanged_** event of the **PlayerModel** (which is fired when the playback state of the player changed) in which we perform **OnPropertyChanged**  for the **_IsPaused_** property, so it informs the properties binded to **_IsPaused_**  about the update. The **Commands** handlers bodies are just calling the corresponding methods which we have already implemented in the **PlayerModel** .

After running the application it is now possible to control the player from the **PreviewPage** .

<img src="/assets/images/tutorials/108/preview_page_buttons_logic.png" style="height:480px; width:853px"/>

You can also notice that the indicator at the left side of the screen on the **SoundtracksListPage** is displaying the proper image for the current state of the player. It works, because we have binded the **_Source_** property of the **Image**  to **_IsPaused_**  property and we have passed its value through the **BooleanToStringConverter** before.

<img src="/assets/images/tutorials/108/soundtrack_list_page_final.png" style="height:480px; width:853px"/>

So now we have almost fully functional player. What is missing is the progress bar logic and the playback position label logic. Let's implement it.

## 3. Progress bar and duration label logic

As we have done almost everything before, there is not much to add to make the progress bar and the label, representing the current playback position, work We have only to update the **_TrackProgress_** property and **_TrackPlaybackPosition_** .



_MusicPlayer/ViewModels/ **MainViewModel** .cs_

<highlight>5-8,23,30-43</highlight>

```csharp
#region fields

...

/// <summary>
/// Frequency of updating progress of the track.
/// </summary>
private const int UPDATE_PROGRESS_INTERVAL = 100;

#endregion

...

#region methods

/// <summary>
/// Initializes class instance.
/// </summary>
public MainViewModel()
{
    ...

    Device.StartTimer(TimeSpan.FromMilliseconds(UPDATE_PROGRESS_INTERVAL), OnProgressUpdateTimerTick);

    ...
}

...

/// <summary>
/// Updates progress of the track.
/// </summary>
/// <returns>Flag indicating if timer should keep recurring.</returns>
private bool OnProgressUpdateTimerTick()
{
    if (_musicPlayerModel.CurrentTrack.Duration != 0)
    {
        TrackProgress = _musicPlayerModel.Progress;
        TrackPlaybackPosition = _musicPlayerModel.PlaybackPosition;
    }

    return true;
}


#endregion
```

We have to add the constant **_UPDATE_PROGRESS_INTERVAL_** which will represent the frequency in the milliseconds of updating the progress of the playback.



In the constructor we have to use the static method from the **Device** class which allows to run specified method periodically while _true_ is being returned by the method. **StartTimer**  method takes the **TimeSpan** object as a first argument, so we create the one from the milliseconds given in the constant. Second argument is the name of the method which we would like to run, so we point to the  **OnProgressUpdateTimerTick** method.



**OnProgressUpdateTimerTick** checks if the duration of the current track loaded by the **PlayerModel** is not equal to 0 (if it is then there is no need to update the progress, because the track is not loaded). We just take the **_Progress_** property from the **PlayerModel** and assign it to the **_TrackProgress_** of the **MainViewModel** (which **_Progress_** property of the **ProgressBar** is binded to). To update the label representing the current playback position we update the **_TrackPlaybackPosition_** with the **_PlaybackPosition_** property of the **PlayerModel** . At the end we return _true_ to inform that we still want to run the method after the time interval specified in the **StartTimer** argument pass.



After building and launching the application and navigating to the **Preview Page** we will see that the progress bar and the label, indicating the playback position of the player, are being properly updated.

<img src="/assets/images/tutorials/108/_preview_page.png" style="height:480px; width:853px"/>

It will be almost everything, but only one more thing is still missing. We have to somehow inform the user if there is no any available tracks to play. So let's add this feature.

## 4. No tracks available information

At this point we have the fully functional Music Player application. The one last thing is the nice information for the user if no tracks are present on the device so we are not able to play any track. The appearance will be like on the following screen.

<img src="/assets/images/tutorials/108/no_tracks_view.png" style="height:480px; width:853px"/>

To achieve this we will show some things only if tracks are present and we will hide them if they are not. The **_IsVisible_** property of the elements will be binded to the boolean property of the **MainViewModel** . If the value of this property will be set to _true_ , then the elements will become visible. If we want to hide some of them when the value is _true_ , then it is the place to use the **NegateBooleanConverter** created before - converter which just inverts the boolean value. Let's add this property.



_MusicPlayer/ViewModels/ **MainViewModel** .cs_

<highlight>5-11</highlight>

```csharp
#region properties

...

/// <summary>
/// Determines if there are any tracks available
/// </summary>
public bool TracksAvailable
{
    get => _musicPlayerModel.Tracks.Count > 0;
}

#endregion

...
```

This property consists of the getter which returns the boolean value from the expression checking if number of the elements inside the **_Tracks_** property of the **PlayerModel** is larger than 0, so we get the information if there are any tracks available to play. Now we have just to add few elements inside the **SoundtracksListPage** and to utilize this new property.



\*MusicPlayer/Views/ **SoundtracksListPage\*** _.xaml_

<highlight>10,11-23,30,37-46,49</highlight>

```xml
<ContentPage.Content>
    <Grid>
        ...
        <Image Source="{Binding IsPaused, Converter={StaticResource BooleanToString},
                                    ConverterParameter={StaticResource ImageArray}}"
               Grid.Row="0"
               Grid.Column="1"
               VerticalOptions="Center"
               HorizontalOptions="Center"
               IsVisible="{Binding TracksAvailable}" />
        <Image Source="images/Rectangle.png"
               Grid.Row="0"
               Grid.Column="1"
               VerticalOptions="Center"
               HorizontalOptions="Center"
               IsVisible="{Binding TracksAvailable, Converter={StaticResource NegateBoolean}}" />
        <Image Source="images/_icon_no-file.png"
               Grid.Row="0"
               Grid.Column="1"
               Margin="132, 106, 0, 0"
               VerticalOptions="Start"
               HorizontalOptions="Start"
               IsVisible="{Binding TracksAvailable, Converter={StaticResource NegateBoolean}}" />
        <Button Grid.Row="0"
                Grid.Column="1"
                Command="{Binding GoToPreviewPageCommand}"
                BackgroundColor="Transparent"
                BorderColor="Transparent"
                Opacity="0.5"
                IsEnabled="{Binding TracksAvailable}" />
        <StackLayout Grid.Row="1"
                     Grid.Column="1">
            <Label Text="{Binding CurrentTrack.Title}"
                   ... />
            ...
        </StackLayout>
        <StackLayout Grid.Row="0"
                     Grid.Column="3"
                     IsVisible="{Binding TracksAvailable, Converter={StaticResource NegateBoolean}}">
            <Label Text="No music file"
                   FontSize="85"
                   TextColor="White" />
            <Label Text="Unavailable to play"
                   FontSize="50"
                   Opacity="0.6" />
        </StackLayout>
        <controls:ScrollableGrid Rows="4"
                                 ...
                                 IsVisible="{Binding TracksAvailable}">
            ...
        </controls:ScrollableGrid>
    </Grid>
</ContentPage.Content>

```

So we have added few elements (semi-transparent black rectangle over the track cover, no tracks available icon and labels informing about no tracks available to play). Things which we want to be visible, when the value of the **_TracksAvailable_** property is _true_  (which means that there are some audio files on the device) have the **_IsVisible_** property binded to this property without the converter, however elements which are only visible, when there are no tracks, have the **_IsVisible_** property binded with use of the **NegateBooleanConverter** . Also the **Button** , which navigates to the **PreviewPage**  has the **_IsEnabled_** property binded to **_TracksAvailable_** , so if the **_TracksAvailable_** is equal to  _false_ , we don't want to navigate to the **PreviewPage** , that's why the **Button** becomes disabled and it is not possible to press it.



To check if everything is working properly and if the information about the no available tracks to play is visible, we have to delete the audio files from the device.



Let's perform the following steps:

Now, after running the application you will see the information about no available tracks.



That was the last element to implement in our appliaction. Now we have fully functional player with possibility to list the information about the tracks stored on the device with the artworks assigned and the ability to play audio files as well as control their playback.
