---
layout: ../../layouts/tutorial/TextTutorial.astro
title: 'How to Create "Text Reader" App'
description: "This tutorial teaches how to create Text Reader app using Xamarin Forms and Text-to-Speech API."
created: "2017/09/12"
modified: "2018/10/11"
profile: ["mobile"]
type: "dotnet"
level: 3
state: "open"
thumbnail: "/assets/images/tutorials/13/Text_Reader.jpg"
---

# I. INTRODUCTION

## 1. Overview

In this tutorial, we will create a Text Reader application which will use TTS API to synthesize voice from text, and play synthesized sound data.

First, take a look at the final version of the application. The user interface consists of:

Below pictures show a fully functional application.

<img src="/assets/images/tutorials/13/text-reader-final-1.png" style="width:30%"/>
 
<img src="/assets/images/tutorials/13/text-reader-final-2.png" style="width:30%"/>
 
<img src="/assets/images/tutorials/13/text-reader-final-3.png" style="width:30%"/>

## 2. Importing and building solution

In this step, we will import and build Visual Studio solution containing initial application code.

Step 1: Download and unpack [text-reader.zip](https://s3-us-west-1.amazonaws.com/tizenschool/13/text-reader.zip) file.

Step 2: Click File > Open > Project/Solution...

<img src="/assets/images/tutorials/13/text-reader-import-1.png" style="width:90%"/>

Step 3: Go to downloaded directory and select TextReader.sln file (Microsoft Visual Studio Solution), then click the "Open" button.

<img src="/assets/images/tutorials/13/text-reader-import-2.png" style="width:90%"/>

The solution structure should appear in the Solution Explorer view. It should contain two projects: TextReader and TextReader.Tizen.Mobile.

<img src="/assets/images/tutorials/13/text-reader-import-3.png" style="width:90%"/>

Step 4: Right-click on the solution and select "Restore NuGet Packages" from the context menu. This will set up NuGet packages for all projects.

<img src="/assets/images/tutorials/13/text-reader-import-4.png" style="width:90%"/>

Step 5: Right click on the solution again and select "Rebuild Solution" from the context menu.

<img src="/assets/images/tutorials/13/text-reader-import-5.png" style="width:90%"/>

Step 6: Right-click on the "TextReader.Tizen.Mobile" project and select "Set as StartUp Project" from the context menu.

<img src="/assets/images/tutorials/13/text-reader-import-6.png" style="width:90%"/>

Right now the application can be run on the emulator or target device. We will start with the base version of the application. There is no input data displayed. The reset button is missing. Other buttons do nothing and there is no hover effect when they are tapped. But don't worry, we will implement these things in the next steps.

<img src="/assets/images/tutorials/13/text-reader-import-7.png" style="width:35%"/>

# II. DISPLAYING THE READER TEXT

## 1. Goal

The goal of this tutorial's part is displaying text which will be read by the application. Text is scrollable and divided into paragraphs. Each paragraph can be selected by tapping it. Of course, the selected paragraph (active one) has a slightly different appearance than others. So, let's begin.

<img src="/assets/images/tutorials/13/text-reader-active-final.png" style="width:35%"/>

## 2. Providing text for the view

We have to provide a property in the main view model (TextReaderViewModel.cs) containing all text paragraphs, so the view can display them. We will use data model to get the data (DataModel.cs). It is already implemented and contains a public property with the list of all paragraphs.

```csharp
class DataModel
{
    #region fields

    /// <summary>
    /// Reader's input text as an array of paragraphs.
    /// </summary>
    private readonly string[] _paragraphs =
    {
        "Welcome to Tizen .NET!",

        "Tizen .NET is an exciting new way to develop applications for the Tizen operating" +
            " system, running on 50 million Samsung devices, including TVs, wearables," +
            " mobile, and many other IoT devices around the world.",

        "The existing Tizen frameworks are either C-based with no advantages of a managed" +
            " runtime, or HTML5-based with fewer features and lower performance than" +
            " the C-based solution.",

        "With Tizen .NET, you can use the C# programming language and the Common Language" +
            " Infrastructure standards and benefit from a managed runtime for faster" +
            " application development, and efficient, secure code execution."
    };

    #endregion

    #region properties

    /// <summary>
    /// Reader's input text as a list of paragraphs.
    /// </summary>
    public List<string> Paragraphs => _paragraphs.ToList();

    #endregion
}
```

1. Open TextReader/ViewModels/TextReaderViewModel.cs file and create private fields for the list of paragraphs and data model instance.

<highlight>3-8, 10-14</highlight>

```csharp
#region fields

/// <summary>
/// List of paragraphs' view models.
/// Each paragraph contains "text" property and "active" property indicating
/// if it is an active one.
/// </summary>
private List<ParagraphViewModel> _paragraphs;

/// <summary>
/// Data model class instance.
/// Provides text to create paragraphs' view models.
/// </summary>
private readonly DataModel _dataModel;

#endregion

```

2. Create public "Paragraphs" property, so the view can access it.

<highlight>3-11</highlight>

```csharp
public ICommand RestoreStateCommand { get; private set; }

/// <summary>
/// List of paragraphs' view models.
/// Each paragraph contains "text" property and "active" property indicating
/// if it is an active one.
/// </summary>
public List<ParagraphViewModel> Paragraphs
{
    get { return _paragraphs; }
}

#endregion

```

3. Create InitParagraphs method and instance of DataModel class.

<highlight>6, 9, 12-19</highlight>

```csharp
/// <summary>
/// TextReaderViewModel class constructor.
/// </summary>
public TextReaderViewModel()
{
    _dataModel = new DataModel();

    InitCommands();
    InitParagraphs();
}

/// <summary>
/// Initializes paragraphs view models.
/// Uses data model to obtain text for the reader.
/// </summary>
private void InitParagraphs()
{

}

```

4. Initialize private \_paragraphs field and use DataModel instance to fill it with actual data.

<highlight>6-10</highlight>

```csharp
/// Initializes paragraphs view models.
/// Uses data model to obtain text for the reader.
/// </summary>
private void InitParagraphs()
{
    _paragraphs = new List<ParagraphViewModel>();

    _paragraphs = _dataModel.Paragraphs.
        Select(item => new ParagraphViewModel(item, false))
        .ToList();
}

```

Each paragraph text is "wrapped" into ParagraphViewModel class. It contains also "active" property which will be used later. For now, we set it to false value.

## 3. Displaying a list of paragraphs

To display a list, we will use a Xamarin ListView component. It requires us to specify a template for an item and ItemSource bindable property value. Empty ListView is already added to the MainPage.xaml file. We need to modify it a little bit to make it work with our data.

```xml
<ListView IsPullToRefreshEnabled="False"
          x:Name="ParagraphsListView"
          SeparatorVisibility="None"
          HasUnevenRows="True">

    <ListView.Header>
        <StackLayout HeightRequest="32"></StackLayout>
    </ListView.Header>
    <ListView.Footer>
        <StackLayout HeightRequest="32"></StackLayout>
    </ListView.Footer>
</ListView>
```

1. Open TextReader/Views/MainPage.xaml file and add styles which we apply for the list item template.

<highlight>6-20</highlight>

```xml
<Style TargetType="StackLayout">
    <Setter Property="BackgroundColor"
            Value="White"></Setter>
</Style>

<Style x:Key="Paragraph"
        TargetType="StackLayout">
    <Setter Property="BackgroundColor"
            Value="White"></Setter>
    <Setter Property="Padding"
            Value="32, 0, 32, 0"></Setter>
</Style>

<Style x:Key="ParagraphLabel"
        TargetType="Label">
    <Setter Property="FontSize"
            Value="26"></Setter>
    <Setter Property="TextColor"
            Value="{StaticResource TextColor}"></Setter>
</Style>

```

2. Define ItemSource property value for the ListView component using public property of the view model we created earlier.

<highlight>2</highlight>

```xml
<ListView IsPullToRefreshEnabled="False"
          ItemsSource="{Binding Paragraphs}"
          x:Name="ParagraphsListView"
          SeparatorVisibility="None"
          HasUnevenRows="True">

    <ListView.Header>
        <StackLayout HeightRequest="32"></StackLayout>
    </ListView.Header>
    <ListView.Footer>
        <StackLayout HeightRequest="32"></StackLayout>
    </ListView.Footer>
</ListView>

```

We use "Binding" XAML markup extension which allows binding component property with specified binding context property ("Paragraphs" in our case). Data bindings allow properties of two objects to be linked so that a change in one causes a change in the other. The binding context for our main page is set to instance of TextReaderViewModel class in the beginning of the xaml file.

```xml
<ContentPage.BindingContext>
    <viewmodels:TextReaderViewModel x:Name="MainContext" />
</ContentPage.BindingContext>
```

3. Define template for the ListView's item.

<highlight>7-21</highlight>

```xml
<ListView IsPullToRefreshEnabled="False"
          ItemsSource="{Binding Paragraphs}"
          x:Name="ParagraphsListView"
          SeparatorVisibility="None"
          HasUnevenRows="True">

    <ListView.ItemTemplate>
        <DataTemplate>
            <ViewCell>
                <StackLayout Style="{StaticResource Paragraph}">
                    <Label Style="{StaticResource ParagraphLabel}"
                           Text="{Binding Text, Mode=OneWay}">
                    </Label>

                    <StackLayout HeightRequest="54">
                    </StackLayout>

                </StackLayout>
            </ViewCell>
        </DataTemplate>
    </ListView.ItemTemplate>

    <ListView.Header>
        <StackLayout HeightRequest="32"></StackLayout>
    </ListView.Header>
    <ListView.Footer>
        <StackLayout HeightRequest="32"></StackLayout>
    </ListView.Footer>
</ListView>

```

In item template we used ViewCell which can contain a developer-defined view. In our case we decided to use stack layouts and labels for the content of the cell. Once again we utilized data binding technique. The binding context for the list item is ParagraphViewModel instance so we use its "Text" property to display the paragraph text value.

<img src="/assets/images/tutorials/13/text-reader-text-1.png" style="width:35%"/>

- Reference

[Data binding basics](https://developer.xamarin.com/guides/xamarin-forms/xaml/xaml-basics/data_binding_basics/)

[ListView guide](https://developer.xamarin.com/guides/xamarin-forms/user-interface/listview/)

[XAML styles](https://developer.xamarin.com/guides/xamarin-forms/user-interface/styles/)

## 4. Selecting active paragraph

We want to allow the user to select the paragraph he wants to hear (change the active paragraph). We also want to be able to do it from the code level. How?

The answer is simple. Once again, we will create public view model property and use data binding to create a link between a component and a view model (this time it will be a two-way binding).

1. Open TextReader/ViewModels/TextReaderViewModel.cs file and create a private field holding the currently active paragraph.

<highlight>10-13</highlight>

```csharp
#region fields

/// <summary>
/// List of paragraphs' view models.
/// Each paragraph contains "text" property and "active" property indicating
/// if it is an active one.
/// </summary>
private List<ParagraphViewModel> _paragraphs;

/// <summary>
/// Reference to the currently active paragraph's view model.
/// </summary>
private ParagraphViewModel _activeParagraph;

/// <summary>
/// Data model class instance.
/// Provides text to create paragraph view models.
/// </summary>
private readonly DataModel _dataModel;

#endregion

```

Create a field that will be used as a backing field for a public property.

2. Create public property ActiveParagraph with a setter and a getter.

<highlight>6-32</highlight>

```csharp
public List<ParagraphViewModel> Paragraphs
{
    get { return _paragraphs; }
}

/// <summary>
/// Active paragraph view model.
/// Changing the value will change the current utterance text.
/// </summary>
public ParagraphViewModel ActiveParagraph
{
    get { return _activeParagraph; }
    set
    {
        if (_activeParagraph == value)
        {
            return;
        }

        if (_activeParagraph != null)
        {
            _activeParagraph.Active = false;
        }

        if (value != null)
        {
            value.Active = true;
        }

        SetProperty(ref _activeParagraph, value);
    }
}

#endregion

```

The getter method only returns a value stored in a private backing field. The setter method does a lot more. First, it checks if the new value is different than the current one. If not, it returns immediately. Next, it updates Active property in the current and the new active paragraph. Finally, it calls SetProperty method (inherited from ViewModelBase) to change the private field and notify all listening components about it.

3. Set an initial value for the ActiveParagraph.

<highlight>13</highlight>

```csharp
/// <summary>
/// Initializes paragraphs view models.
/// Uses data model to obtain text for the reader.
/// </summary>
private void InitParagraphs()
{
    _paragraphs = new List<ParagraphViewModel>();

    _paragraphs = _dataModel.Paragraphs.
        Select(item => new ParagraphViewModel(item, false))
        .ToList();

    ActiveParagraph = null;
}

```

4. Create a two-way binding between ListView selected item and ActiveParagraph property.

<highlight>6</highlight>

```xml
<ListView IsPullToRefreshEnabled="False"
          ItemsSource="{Binding Paragraphs}"
          x:Name="ParagraphsListView"
          SeparatorVisibility="None"
          HasUnevenRows="True"
          SelectedItem="{Binding ActiveParagraph, Mode=TwoWay}">

```

5. Customize active paragraph's appearance (color & bottom line).

<highlight>7-14, 18-19</highlight>

```xml
<ListView.ItemTemplate>
    <DataTemplate>
        <ViewCell>
            <StackLayout Style="{StaticResource Paragraph}">
                <Label Style="{StaticResource ParagraphLabel}"
                       Text="{Binding Text, Mode=OneWay}">
                    <Label.Triggers>
                        <DataTrigger TargetType="Label"
                                     Binding="{Binding Active, StringFormat='{0}'}"
                                     Value="True">
                            <Setter Property="TextColor"
                                    Value="{StaticResource MainColor}"></Setter>
                        </DataTrigger>
                    </Label.Triggers>
                </Label>

                <StackLayout HeightRequest="54">
                    <Image IsVisible="{Binding Active, Mode=OneWay}"
                           Style="{StaticResource UnitLineImage}"></Image>
                </StackLayout>

            </StackLayout>
        </ViewCell>
    </DataTemplate>
</ListView.ItemTemplate>

```

We used data trigger to update paragraph's text color if it was active. Data triggers use data binding to monitor another control to cause the setters to get called. In our case data trigger monitors Active property of paragraph view model. If it is true, the setter is called.

We also added an image for bottom line. It is visible if the paragraph is active.

6. Add missing style to the bottom line image.

<highlight>9-15</highlight>

```xml
<Style x:Key="ParagraphLabel"
       TargetType="Label">
    <Setter Property="FontSize"
            Value="26"></Setter>
    <Setter Property="TextColor"
            Value="{StaticResource TextColor}"></Setter>
</Style>

<Style x:Key="UnitLineImage"
       TargetType="Image">
    <Setter Property="Source"
            Value="images/active_unit_line.png"></Setter>
    <Setter Property="HorizontalOptions"
            Value="Start"></Setter>
</Style>

```

Now, you can tap the paragraph to make it active.

<img src="/assets/images/tutorials/13/text-reader-active-final.png" style="width:35%"/>

- Reference

[Triggers guide](https://developer.xamarin.com/guides/xamarin-forms/application-fundamentals/triggers/)

# III. NAVIGATION OVER PARAGRAPHS

## 1. Goal

The goal of this part is to allow the user to navigate over paragraphs of text using Forward and Backward buttons.

<img src="/assets/images/tutorials/13/text-reader-navigation-1.png" style="width:35%"/>

## 2. Forward navigation

In Text Reader application, we use Image components to represent buttons. To make Image component clickable, TapGestureRecognizer is used. It was added already to all buttons (images) using attached properties (XAML).

```xml
<Image WidthRequest="134" Source="images/forward.png">
    <Image.GestureRecognizers>
        <TapGestureRecognizer Command="{Binding GoToNextUnitCommand}" />
    </Image.GestureRecognizers>
</Image>

```

We use binding to link the tap gesture recognizer with a proper action in a view model. The view model exposes commands (ICommand interface) which it can handle and we link to one of them using Command property of the tap gesture recognizer.

View model's commands are already defined (with empty handler functions). We only have to create handlers' implementation.

```csharp
/// <summary>
/// A command which changes the active paragraph to the next one.
/// </summary>
public ICommand GoToNextUnitCommand { get; private set; }
```

```csharp
/// <summary>
/// Initializes view model's commands.
/// </summary>
private void InitCommands()
{
    ResetCommand = new Command(ExecuteReset, CanExecuteReset);
    ToggleRepeatUnitCommand = new Command(ExecuteToggleRepeatUnit);
    ToggleRepeatAllCommand = new Command(ExecuteToggleRepeatAll);
    GoToPreviousUnitCommand = new Command(ExecuteGoToPreviousUnit);
    GoToNextUnitCommand = new Command(ExecuteGoToNextUnit);
    TogglePlayStateCommand = new Command(ExecuteTogglePlayState);
    SaveStateAndPauseCommand = new Command(ExecuteSaveStateAndPause);
    RestoreStateCommand = new Command(ExecuteRestoreState);
}
```

```csharp
/// <summary>
/// Go to next unit command handler.
/// </summary>
private void ExecuteGoToNextUnit()
{


}
```

1. Open TextReader/ViewModels/TextReaderViewModel.cs file and modify GoToNextUnitCommand handler so that it changes ActiveParagraph property value to the next one (or to the first one, if there is no next paragraph).

<highlight>6-9</highlight>

```csharp
/// <summary>
/// Go to next unit command handler.
/// </summary>
private void ExecuteGoToNextUnit()
{
    int activeUnitIndex = _paragraphs.IndexOf(ActiveParagraph);

    ActiveParagraph = activeUnitIndex + 1 >= _paragraphs.Count ?
        _paragraphs[0] : _paragraphs[activeUnitIndex + 1];
}

```

Right now, the Forward button should work properly.

- Reference

[Adding a Tap Gesture Gesture Recognizer](https://developer.xamarin.com/guides/xamarin-forms/application-fundamentals/gestures/tap/)

## 3. Backward navigation

In a similar way as Forward button, we handle Backward button. We only need to implement a proper command handler.

1. Open TextReader/ViewModels/TextReaderViewModel.cs file and modify GoToPreviousUnitCommand handler so that it changes ActiveParagraph property value to the previous one (or to null value, if there is no previous paragraph).

<highlight>6-14</highlight>

```csharp
/// <summary>
/// Go to previous unit command handler.
/// </summary>
private void ExecuteGoToPreviousUnit()
{
    if (ActiveParagraph == null)
    {
        return;
    }

    int activeUnitIndex = _paragraphs.IndexOf(ActiveParagraph);

    ActiveParagraph = activeUnitIndex - 1 < 0 ?
        null : _paragraphs[activeUnitIndex - 1];
}

```

Right now, the Backward button should work properly.

# IV. READING TEXT (PLAY/PAUSE)

## 1. Goal

The goal of this tutorial's part is to implement the Play/Pause button functionality.

First, we have to implement TTS service which will use TTS API to synthesize text into speech. Next, we will use it to make the Play/Pause button work.

TextReaderViewModel class uses TextToSpeechModel class to read the specified text.

The most important methods, properties and events of TextToSpeechModel class are:



TextToSpeechModel class is already implemented in the project we provided.

```csharp
/// <summary>
/// Model class which handles synthesizing text into speech.
/// </summary>
class TextToSpeechModel
{
    #region properties

    /// <summary>
    /// Event fired when the utterance is completed.
    /// </summary>
    public event EventHandler UtteranceCompleted ;

    /// <summary>
    /// Flag indicating if the service is ready to use.
    /// The model requires "Init" method to be called before use.
    /// </summary>
    public bool Ready => DependencyService.Get<ITextToSpeechService>().Ready;

    /// <summary>
    /// Currently used text.
    /// If the text is changed, the current utterance is stopped immediately
    /// and then starts the new one.
    /// </summary>
    public string Text
    {
        get { return DependencyService.Get<ITextToSpeechService>().Text; }
        set { DependencyService.Get<ITextToSpeechService>().Text = value; }
    }

    /// <summary>
    /// Flag indicating if the text is read by the TTS engine.
    /// </summary>
    public bool Playing => DependencyService.Get<ITextToSpeechService>().Playing;

    #endregion

    #region methods

    /// <summary>
    /// The model class constructor.
    /// </summary>
    public TextToSpeechModel()
    {
        var service = DependencyService.Get<ITextToSpeechService>();

        service.UtteranceCompleted += ServiceOnUtteranceCompleted;
    }

    /// <summary>
    /// Handles utterance completed event from the service.
    /// Invokes UtteranceCompleted event.
    /// </summary>
    /// <param name="sender"></param>
    /// <param name="eventArgs"></param>
    private void ServiceOnUtteranceCompleted(object sender, EventArgs eventArgs)
    {
        UtteranceCompleted?.Invoke(this, new EventArgs());
    }

    /// <summary>
    /// Initializes the model.
    /// The model instance can be used when the "Ready" property returns "true" value.
    /// </summary>
    public void Init()
    {
        DependencyService.Get<ITextToSpeechService>().Init();
    }

    /// <summary>
    /// Starts or resumes the current utterance.
    /// </summary>
    public void Play()
    {
        DependencyService.Get<ITextToSpeechService>().Play();
    }

    /// <summary>
    /// Pauses the current utterance.
    /// </summary>
    public void Pause()
    {
        DependencyService.Get<ITextToSpeechService>().Pause();
    }

    /// <summary>
    /// Stops and clears the current utterance.
    /// </summary>
    public void Stop()
    {
        DependencyService.Get<ITextToSpeechService>().Stop();
    }

    #endregion
}
```

As you see, the TextToSpeechModel class uses dependency injection to obtain service implementing ITextToSpeechService interface.

The service contains the actual logic of communication with TTS engine. Such architecture simplifies porting the application to another platform.

```csharp
/// <summary>
/// Interface of text-to-speech service which allows synthesizing text into speech.
/// </summary>
public interface ITextToSpeechService
{
    #region properties

    /// <summary>
    /// Event fired when the utterance is completed.
    /// </summary>
    event EventHandler UtteranceCompleted;

    /// <summary>
    /// Flag indicating if the service is ready to use.
    /// The service requires "Init" method to be called before use.
    /// </summary>
    bool Ready { get; }

    /// <summary>
    /// Currently used text.
    /// If the text is changed, the current utterance is stopped immediately
    /// and then starts the new one.
    /// </summary>
    string Text { get; set; }

    /// <summary>
    /// Flag indicating if the text is read by the TTS engine.
    /// </summary>
    bool Playing { get; }

    #endregion

    #region methods

    /// <summary>
    /// Initializes the service.
    /// Service can be used when the "Ready" property returns "true" value.
    /// </summary>
    void Init();

    /// <summary>
    /// Starts or resumes the current utterance.
    /// </summary>
    void Play();

    /// <summary>
    /// Pauses the current utterance.
    /// </summary>
    void Pause();

    /// <summary>
    /// Stops and clears the current utterance.
    /// </summary>
    void Stop();

    #endregion
}
```

Our main task is to implement this service interface for Tizen platform. It allows us to make the Play/Pause button work.

So, let's begin.

<img src="/assets/images/tutorials/13/text-reader-play-1.png" style="width:35%"/>

- Reference

[DependencyService guide](https://developer.xamarin.com/guides/xamarin-forms/application-fundamentals/dependency-service/)

## 2. The TTS service implementation

TextToSpeechService class is located in TextReader.Tizen.Mobile/Services/TextToSpeechService.cs file.

1. Add private constants and fields which we will use later.

<highlight>3-29</highlight>

```csharp
class TextToSpeechService : ITextToSpeechService
{
    #region consts

    /// <summary>
    /// Default voice language.
    /// </summary>
    private const string DEFAULT_VOICE_LANGUAGE = "en_US";

    #endregion

    #region fields

    /// <summary>
    /// Instance of TTS client.
    /// </summary>
    private readonly TtsClient _client;

    /// <summary>
    /// Currently synthesized text.
    /// </summary>
    private string _text;

    /// <summary>
    /// Currently used voice instance.
    /// </summary>
    private SupportedVoice _currentVoice;

    #endregion

    #region properties

```

DEFAULT_VOICE_LANGUAGE constant contains the name of default language we want to use.

\_client field will hold reference to the instance of TtsClient class (TTS API).

\_text field will hold currently synthesized text.

\_currentVoice field will be used to keep instance of currently used voice (SupportedVoice class).

2. Create instance of TtsClient (Tizen TTS API) and add listener to UtteranceCompleted event.

<highlight>6-7, 10-20</highlight>

```csharp
/// <summary>
/// The service constructor.
/// </summary>
public TextToSpeechService()
{
    _client = new TtsClient();
    _client.UtteranceCompleted += ClientOnUtteranceCompleted;
}

/// <summary>
/// Handles utterance completed event on TTS client.
/// Invokes UtteranceCompleted event.
/// </summary>
/// <param name="sender"></param>
/// <param name="utteranceEventArgs"></param>
private void ClientOnUtteranceCompleted(object sender,
    UtteranceEventArgs utteranceEventArgs)
{
    UtteranceCompleted?.Invoke(this, new EventArgs());
}

```

We will not handle the event here, but only pass it on as a new own event.

3. Add Init method implementation.

<highlight>7-23</highlight>

```csharp
/// <summary>
/// Initializes the service.
/// Service can be used when the "Ready" property returns "true" value.
/// </summary>
public void Init()
{
    if (Ready)
    {
        return;
    }

    if (_client.DefaultVoice.Language == DEFAULT_VOICE_LANGUAGE)
    {
        _currentVoice = _client.DefaultVoice;
    }
    else
    {
        _currentVoice = _client.GetSupportedVoices().
            FirstOrDefault(voice => voice.Language == DEFAULT_VOICE_LANGUAGE) ??
            _client.DefaultVoice;
    }

    _client.Prepare();
}

```

It will set up \_currentVoice field value (instance of SupportedVoice class) and call \_prepare method on the client to connect it to system TTS service.

4. Modify Ready property getter method so it returns the proper value based on the client status.

<highlight>8-11</highlight>

```csharp
/// <summary>
/// Flag indicating if the service is ready to use.
/// The service requires "Init" method to be called before use.
/// </summary>
public bool Ready
{
    get
    {
        var state = _client.CurrentState;
        return state != State.Created && state != State.Unavailable;
    }
}

```

5. Modify Playing property getter method so it returns the proper value based on the client status.

<highlight>4</highlight>

```csharp
/// <summary>
/// Flag indicating if the text is read by the TTS engine.
/// </summary>
public bool Playing => _client.CurrentState == State.Playing;

```

6. Modify Text property getter and setter methods so the getter method returns the current text and setter method updates the current synthesized text in the TTS client.

<highlight>8-31</highlight>

```csharp
/// <summary>
/// Currently used text.
/// If the text is changed, the current utterance is stopped immediately
/// and then starts the new one.
/// </summary>
public string Text
{
    get { return _text; }
    set
    {
        if (!Ready)
        {
            return;
        }

        bool playingBeforeChange = Playing;

        _client.Stop();
        _client.AddText(
            value,
            _currentVoice.Language,
            (int)_currentVoice.VoiceType,
            _client.GetSpeedRange().Normal
        );
        _text = value;

        if (playingBeforeChange)
        {
            _client.Play();
        }
    }
}

```

The getter method modification is simple, it returns only the corresponding private field value.

However, the setter method is more complicated. Its implementation requires a few steps. First it saves the playing state. Next, it stops the current utterance (Stop method also clears the engine queue). Next, it adds new text to the client using AddText method. Then, it updates local private field and finally restores the playing state.

7. Modify Play method so it calls corresponding method in the client.

<highlight>6-11</highlight>

```csharp
/// <summary>
/// Starts or resumes the current utterance.
/// </summary>
public void Play()
{
    if (!Ready)
    {
        return;
    }

    _client.Play();
}

```

8. Modify Pause method so it calls corresponding method in the client.

<highlight>6-11</highlight>

```csharp
/// <summary>
/// Pauses the current utterance.
/// </summary>
public void Pause()
{
    if (!Ready)
    {
        return;
    }

    _client.Pause();
}

```

9. Modify Stop method so it calls corresponding method in the client.

<highlight>6-11</highlight>

```csharp
/// <summary>
/// Stops and clears the current utterance.
/// </summary>
public void Stop()
{
    if (!Ready)
    {
        return;
    }

    _client.Stop();
}

```

- Reference

[TTS API reference](https://developer.tizen.org/dev-guide/csapi/namespaceTizen_1_1Uix_1_1Tts.html)

## 3. The Play/Pause button logic implementation

In this step we will use TextToSpeechModel class to implement logic of Play/Pause button.

We will modify TextReader/ViewModels/TextReaderViewModel.cs file.

1. Add private fields for TextToSpeechModel class instance and Playing property backing field.

<highlight>7-15</highlight>

```csharp
/// <summary>
/// Data model class instance.
/// Provides text to create paragraph view models.
/// </summary>
private readonly DataModel _dataModel;

/// <summary>
/// Model class instance used to synthesize text into speech.
/// </summary>
private readonly TextToSpeechModel _ttsModel;

/// <summary>
/// Flag indicating if the text reader is playing.
/// </summary>
private bool _playing;


```

2. Add public Playing property.

<highlight>11-18</highlight>

```csharp
/// <summary>
/// List of paragraphs' view models.
/// Each paragraph contains "text" property and "active" property indicating
/// if it is an active one.
/// </summary>
public List<ParagraphViewModel> Paragraphs
{
    get { return _paragraphs; }
}

/// <summary>
/// Flag indicating if the text reader is playing.
/// </summary>
public bool Playing
{
    get { return _playing; }
    private set { SetProperty(ref _playing, value); }
}

```

The property will be updated only by the view model (private setter). Public getter method allows the view to update itself.

3. Create and initialize instance of TextToSpeechModel class, set initial value for private \_playing field.

<highlight>7, 11-14</highlight>

```csharp
/// <summary>
/// TextReaderViewModel class constructor.
/// </summary>
public TextReaderViewModel()
{
    _dataModel = new DataModel();
    _ttsModel = new TextToSpeechModel();

    InitCommands();
    InitParagraphs();

    _playing = false;

    _ttsModel.Init();
}

```

4. Modify ActiveParagraph property setter method, so it updates text in TTS model and stops reading when null value is received. It will also returns immediately, if the model is not ready, and update the Playing property.

<highlight>10-13, 28, 30-34</highlight>

```csharp
/// <summary>
/// Active paragraph view model.
/// Changing the value will change the current utterance text.
/// </summary>
public ParagraphViewModel ActiveParagraph
{
    get { return _activeParagraph; }
    set
    {
        if (!_ttsModel.Ready)
        {
            return;
        }

        if (_activeParagraph == value)
        {
            return;
        }

        if (_activeParagraph != null)
        {
            _activeParagraph.Active = false;
        }

        if (value != null)
        {
            value.Active = true;
            _ttsModel.Text = value.Text;
        }
        else
        {
            _ttsModel.Stop();
            Playing = _ttsModel.Playing;
        }

        SetProperty(ref _activeParagraph, value);
    }
}

```

5. Update ExecuteGoToPreviousUnit and ExecuteGoToNextUnit, so they return immediately, if TTS model is not ready.

<highlight>6, 22-25</highlight>

```csharp
/// <summary>
/// Go to previous unit command handler.
/// </summary>
private void ExecuteGoToPreviousUnit()
{
    if (!_ttsModel.Ready || ActiveParagraph == null)
    {
        return;
    }

    int activeUnitIndex = _paragraphs.IndexOf(ActiveParagraph);

    ActiveParagraph = activeUnitIndex - 1 < 0 ?
        null : _paragraphs[activeUnitIndex - 1];
}

/// <summary>
/// Go to next unit command handler.
/// </summary>
private void ExecuteGoToNextUnit()
{
    if (!_ttsModel.Ready)
    {
        return;
    }

    int activeUnitIndex = _paragraphs.IndexOf(ActiveParagraph);

    ActiveParagraph = activeUnitIndex + 1 >= _paragraphs.Count ?
        _paragraphs[0] : _paragraphs[activeUnitIndex + 1];
}

```

6. Add implementation to the TogglePlayStateCommand handler.

<highlight>7-26</highlight>

```csharp
/// <summary>
/// Toggle play state command handler.
/// Uses TTS model to play or pause the utterance.
/// </summary>
private void ExecuteTogglePlayState()
{
    if (!_ttsModel.Ready)
    {
        return;
    }

    if (ActiveParagraph == null)
    {
        ExecuteGoToNextUnit();
    }

    if (Playing)
    {
        _ttsModel.Pause();
    }
    else
    {
        _ttsModel.Play();
    }

    Playing = _ttsModel.Playing;
}

```

The handler will return immediately, if TTS model is not ready. Additionally, it will call ExecuteGoToNextUnit method, if the active paragraph is null (it will make the first paragraph active). It will also call Pause or Play method of TTS model depending on the current state of the reading (Playing property). Finally, it will update the Playing property value.

## 4. Handling the utterance completion event

For now, if the reading of one paragraph is completed, the application does not proceed to the next paragraph. To do this, we have to find out when such a change should occur. We will use UtteranceCompleted event from the TextToSpeechModel class.

We will modify TextReader/ViewModels/TextReaderViewModel.cs file.

1. Add UtteranceCompleted event listener.

<highlight>14, 18-28</highlight>

```csharp
/// <summary>
/// TextReaderViewModel class constructor.
/// </summary>
public TextReaderViewModel()
{
    _dataModel = new DataModel();
    _ttsModel = new TextToSpeechModel();

    InitCommands();
    InitParagraphs();

    _playing = false;

    _ttsModel.UtteranceCompleted += TtsModelOnUtteranceCompleted;
    _ttsModel.Init();
}

/// <summary>
/// Handles UtteranceCompleted event of the TTS model.
/// Depending on the repeat unit and repeat all options,
/// selects the next proper active paragraph.
/// </summary>
/// <param name="sender"></param>
/// <param name="eventArgs"></param>
private void TtsModelOnUtteranceCompleted(object sender, EventArgs eventArgs)
{

}

```

2. Add event handler implementation: going to the next paragraph, if it exists.

<highlight>10-16</highlight>

```csharp
/// <summary>
/// Handles UtteranceCompleted event of the TTS model.
/// Depending on the repeat unit and repeat all options,
/// selects the next proper active paragraph.
/// </summary>
/// <param name="sender"></param>
/// <param name="eventArgs"></param>
private void TtsModelOnUtteranceCompleted(object sender, EventArgs eventArgs)
{
    if (_paragraphs.IndexOf(ActiveParagraph) != _paragraphs.Count - 1)
    {
        // go to the next unit, if not the last one
        ExecuteGoToNextUnit();
    }

    Playing = _ttsModel.Playing;
}

```

The handler also updates the Playing property value.

Now, the text is read from the beginning till the end. We will implement Repeat All and Repeat Unit features later.

# V. REPEAT ALL AND REPEAT UNIT

## 1. Goal

The goal of this tutorial's part is to implement repeat all and repeat unit features. Buttons which toggle these options on and off are already created. We need to implement command handlers and add separate images for the "on" state.

<img src="/assets/images/tutorials/13/text-reader-repeat-1.png" style="width:35%"/>

## 2. Extending the view model

First, we will add two public properties to the view model. They will match repeat all and repeat unit buttons state (on/off). Of course, we have to also modify utterance completed handler and take into account these properties.

We will modify TextReader/ViewModels/TextReaderViewModel.cs file.

1. Add private backing fields to public properties.

<highlight>6-14</highlight>

```csharp
/// <summary>
/// Flag indicating if the text reader is playing.
/// </summary>
private bool _playing;

/// <summary>
/// Flag indicating if the repeat unit option is active.
/// </summary>
private bool _repeatUnitActive;

/// <summary>
/// Flag indicating if the repeat all option is active.
/// </summary>
private bool _repeatAllActive;

#endregion

```

Both fields are the bool type. The first one indicates if the repeat unit option is active, the second does the same but for the repeat all option.

2. Set the initial value for created fields (false).

<highlight>13-14</highlight>

```csharp
/// <summary>
/// TextReaderViewModel class constructor.
/// </summary>
public TextReaderViewModel()
{
    _dataModel = new DataModel();
    _ttsModel = new TextToSpeechModel();

    InitCommands();
    InitParagraphs();

    _playing = false;
    _repeatUnitActive = false;
    _repeatAllActive = false;

    _ttsModel.UtteranceCompleted += TtsModelOnUtteranceCompleted;
    _ttsModel.Init();
}

```

3. Create public properties: RepeatUnitActive and RepeatAllActive.

<highlight>10-26</highlight>

```csharp
/// <summary>
/// Flag indicating if the text reader is playing.
/// </summary>
public bool Playing
{
    get { return _playing; }
    private set { SetProperty(ref _playing, value); }
}

/// <summary>
/// Flag indicating if the repeat unit option is active.
/// </summary>
public bool RepeatUnitActive
{
    get { return _repeatUnitActive; }
    private set { SetProperty(ref _repeatUnitActive, value); }
}

/// <summary>
/// Flag indicating if the repeat all option is active.
/// </summary>
public bool RepeatAllActive
{
    get { return _repeatAllActive; }
    private set { SetProperty(ref _repeatAllActive, value); }
}

```

The getter methods only return corresponding private field value. The setter methods call SetProperty method which updates a specified field and invokes an event about an update.

4. Modify UtteranceCompleted callback method so it takes into account the current state of repeat unit and repeat all options.

<highlight>10-22</highlight>

```csharp
/// <summary>
/// Handles UtteranceCompleted event of the TTS model.
/// Depending on the repeat unit and repeat all options,
/// selects the next proper active paragraph.
/// </summary>
/// <param name="sender"></param>
/// <param name="eventArgs"></param>
private void TtsModelOnUtteranceCompleted(object sender, EventArgs eventArgs)
{
    if (RepeatUnitActive && ActiveParagraph != null)
    {
        _ttsModel.Text = ActiveParagraph.Text;
    }
    else if (_paragraphs.IndexOf(ActiveParagraph) != _paragraphs.Count - 1)
    {
        // go to next unit if not last one
        ExecuteGoToNextUnit();
    }
    else
    {
        ActiveParagraph = RepeatAllActive ? _paragraphs[0] : null;
    }

    Playing = _ttsModel.Playing;
}

```

5. Add ToggleRepeatUnit and ToggleRepeatAll commands implementation (toggling the option state).

<highlight>7, 16</highlight>

```csharp
/// <summary>
/// Toggle repeat unit command handler.
/// Toggles the state of repeat unit option.
/// </summary>
private void ExecuteToggleRepeatUnit()
{
    RepeatUnitActive = !RepeatUnitActive;
}

/// <summary>
/// Toggle repeat all command handler.
/// Toggles the state of the repeat all option.
/// </summary>
private void ExecuteToggleRepeatAll()
{
    RepeatAllActive = !RepeatAllActive;
}

```

Now, the view model is ready. We will proceed to update the view.

## 3. Updating the view

We created public boolean properties for repeat unit and repeat all options in the view model. Now, we use them to show the current state of those options in the user interface.

We will create bindings and utilize custom converter class. The BoolToStringConverter class allows us to convert a boolean value into one of two specified string values. We will convert the current state of an option into corresponding button image path.

In this way, our buttons will have separate images for each of the states - on/off.

```csharp
public class BoolToStringConverter : IValueConverter
{
    #region fields

    /// <summary>
    /// String value for the "true" value of the input.
    /// </summary>
    private readonly string _trueValue;

    /// <summary>
    /// String value for the "false" value of the input.
    /// </summary>
    private readonly string _falseValue;

    #endregion

    #region methods

    /// <summary>
    /// Default class constructor.
    /// </summary>
    public BoolToStringConverter()
    {
        _trueValue = "True";
        _falseValue = "False";
    }

    /// <summary>
    /// Class constructor which allows specifying string values for the "true" and "false"
    /// boolean states.
    /// </summary>
    /// <param name="trueValue">String value for the "true" value of the input.</param>
    /// <param name="falseValue">String value for the "false" value of the input.</param>
    public BoolToStringConverter(string trueValue, string falseValue)
    {
        _trueValue = trueValue;
        _falseValue = falseValue;
    }

    /// <summary>
    /// Converts boolean value to string value.
    /// </summary>
    /// <param name="value"></param>
    /// <param name="targetType"></param>
    /// <param name="parameter"></param>
    /// <param name="culture"></param>
    /// <returns></returns>
    public object Convert(object value, Type targetType, object parameter, CultureInfo culture)
    {
        return (bool) value ? _trueValue : _falseValue;
    }

    /// <summary>
    /// Converts back string value to boolean value.
    /// </summary>
    /// <param name="value"></param>
    /// <param name="targetType"></param>
    /// <param name="parameter"></param>
    /// <param name="culture"></param>
    /// <returns></returns>
    public object ConvertBack(object value, Type targetType, object parameter,
        CultureInfo culture)
    {
        throw new NotImplementedException();
    }

    #endregion
}
```

We will modify TextReader/Views/MainPage.xaml file.

1. Define a XML namespace for custom converters.

<highlight>4</highlight>

```xml
<ContentPage xmlns="http://xamarin.com/schemas/2014/forms"
             xmlns:x="http://schemas.microsoft.com/winfx/2009/xaml"
             xmlns:viewmodels="clr-namespace:TextReader.ViewModels;"
             xmlns:converters="clr-namespace:TextReader.Converters;"
             x:Class="TextReader.Views.MainPage"
             Title="Text Reader"
             NavigationPage.HasBackButton="False">

```

2. Create converter instance for each button in ResourceDictionary section.

<highlight>9-21</highlight>

```xml
<Style x:Key="UnitLineImage"
       TargetType="Image">
    <Setter Property="Source"
            Value="images/active_unit_line.png"></Setter>
    <Setter Property="HorizontalOptions"
            Value="Start"></Setter>
</Style>

<converters:BoolToStringConverter x:Key="ActiveStateToRepeatUnitImage">
    <x:Arguments>
        <x:String>images/repeat_unit_hover.png</x:String>
        <x:String>images/repeat_unit.png</x:String>
    </x:Arguments>
</converters:BoolToStringConverter>

<converters:BoolToStringConverter x:Key="ActiveStateToRepeatAllImage">
    <x:Arguments>
        <x:String>images/repeat_all_hover.png</x:String>
        <x:String>images/repeat_all.png</x:String>
    </x:Arguments>
</converters:BoolToStringConverter>

```

3. Create one-way binding from view model's RepeatUnitActive property to Image's Source property with custom converter.

<highlight>1-2</highlight>

```xml
<Image WidthRequest="122"
       Source="{Binding RepeatUnitActive, Mode=OneWay, Converter={StaticResource ActiveStateToRepeatUnitImage}}">
    <Image.GestureRecognizers>
        <TapGestureRecognizer Command="{Binding ToggleRepeatUnitCommand}" />
    </Image.GestureRecognizers>
</Image>

```

4. Create one-way binding from view model's RepeatAllActive property to Image's Source property with custom converter.

<highlight>1-2</highlight>

```xml
<Image WidthRequest="122"
       Source="{Binding RepeatAllActive, Mode=OneWay, Converter={StaticResource ActiveStateToRepeatAllImage}}">
    <Image.GestureRecognizers>
        <TapGestureRecognizer Command="{Binding ToggleRepeatAllCommand}" />
    </Image.GestureRecognizers>
</Image>

```

Now, Repeat Unit and Repeat All buttons are fully functional.

<img src="/assets/images/tutorials/13/text-reader-repeat-2.png" style="width:35%"/>

# VI. IMAGE BASED BUTTON TAP EFFECT

## 1. Goal

The goal of this tutorial's part is to add tap effect to three buttons: Backward, Forward and Play/Pause. In our application we are using images to represent buttons. When a user taps on the image, its action is triggered but there is no animation or other effect we may find in regular buttons.

We are going to create such an effect. When the image is tapped, we will change it to another one for a specified period of time (300 milliseconds).

In case of Play/Pause button, we will also define a separate image for the playing state.

## 2. Tap effect for Backward and Forward buttons

First, we will add a tap effect to Backward and Forward buttons.

We will utilize custom behavior class. Behaviors allows extending functionality of already existing components. In our case, it adds its own tap gesture recognizer to the image in order to change its source to other file for a specified amount of time when a user taps on it.

The behavior which we will use is implemented as ImageActiveBehavior class. It is already included into project (TextReader/Behaviors/ImageActiveBehavior.cs).

```csharp
/// <summary>
/// ImageActiveBehavior class.
/// Adds behavior to image component which allows to set a separate source for an active state
/// (tapped image).
/// </summary>
public class ImageActiveBehavior : Behavior<Image>
{
    /// <summary>
    /// Structure which holds behavior's private data.
    /// </summary>
    struct TargetStorage
    {
        /// <summary>
        /// Reference to the tap recognizer which was added to the target component
        /// by the behavior.
        /// </summary>
        public TapGestureRecognizer TapRecognizer;

        /// <summary>
        /// Flag indicating if the target component is currently active (tapped).
        /// </summary>
        public bool Active;
    }

    #region consts

    /// <summary>
    /// Default timeout to restore original image source (active state).
    /// </summary>
    public const int DEFAULT_TIMEOUT_MILLISECONDS = 300;

    #endregion

    #region fields

    /// <summary>
    /// Converter used to transform string source to ImageSource class instance.
    /// </summary>
    private readonly ImageSourceConverter _converter = new ImageSourceConverter();

    /// <summary>
    /// Structure used to hold private data for each target component (bindable object).
    /// </summary>
    private readonly Dictionary<BindableObject, TargetStorage> _storage =
        new Dictionary<BindableObject, TargetStorage>();

    #endregion

    #region properties

    /// <summary>
    /// ActiveSource property definition.
    /// It defines image source used for the active state of the component.
    /// </summary>
    public static readonly BindableProperty ActiveSourceProperty =
        BindableProperty.Create("ActiveSource", typeof(string), typeof(ImageActiveBehavior));

    /// <summary>
    /// OriginalSource property definition.
    /// It defines image source for the default state of the component.
    /// </summary>
    public static readonly BindableProperty OriginalSourceProperty =
        BindableProperty.Create("OriginalSource", typeof(string), typeof(ImageActiveBehavior));

    /// <summary>
    /// Timeout property definition.
    /// It defines time (in milliseconds) for the active state of the component
    /// (after that time the original image source will be restored).
    /// </summary>
    public static readonly BindableProperty TimeoutProperty =
        BindableProperty.Create("Timeout", typeof(int), typeof(ImageActiveBehavior),
            DEFAULT_TIMEOUT_MILLISECONDS);

    /// <summary>
    /// Image source for the active state of the component.
    /// </summary>
    public string ActiveSource
    {
        get { return (string) GetValue(ActiveSourceProperty); }
        set { SetValue(ActiveSourceProperty, value);}
    }

    /// <summary>
    /// Image source for the default state of the component.
    /// </summary>
    public string OriginalSource
    {
        get { return (string)GetValue(OriginalSourceProperty); }
        set { SetValue(OriginalSourceProperty, value); }
    }

    /// <summary>
    /// Active state timeout (in milliseconds).
    /// </summary>
    public int Timeout
    {
        get { return (int)GetValue(TimeoutProperty); }
        set { SetValue(TimeoutProperty, value); }
    }

    #endregion

    #region methods

    /// <summary>
    /// Converts image source (string) to ImageSource class instance.
    /// </summary>
    /// <param name="source"></param>
    /// <returns>ImageSoruce class instance created from specified string.</returns>
    private ImageSource SourceToImageSource(string source)
    {
        return source == null
            ? null :
            (ImageSource) _converter.ConvertFromInvariantString(source);
    }

    /// <summary>
    /// Called when the behavior is attached to the view.
    /// Adds tap recognizer (to the image) which changes the source for a specified time
    /// (active state).
    /// </summary>
    /// <param name="bindable"></param>
    protected override void OnAttachedTo(BindableObject bindable)
    {
        base.OnAttachedTo(bindable);
        Image target = (Image) bindable;

        target.Source = SourceToImageSource(OriginalSource);

        TargetStorage targetStorage = new TargetStorage
        {
            TapRecognizer = new TapGestureRecognizer(),
        };

        targetStorage.TapRecognizer.Tapped += (sender, args) =>
        {
            if (targetStorage.Active)
            {
                return;
            }

            target.Source = SourceToImageSource(ActiveSource);
            targetStorage.Active = true;

            Device.StartTimer(TimeSpan.FromMilliseconds(Timeout), () =>
            {
                if (_storage.ContainsKey(bindable))
                {
                    target.Source = SourceToImageSource(OriginalSource);
                }

                targetStorage.Active = false;
                return false;
            });
        };

        target.GestureRecognizers.Add(targetStorage.TapRecognizer);
        _storage[bindable] = targetStorage;
    }

    /// <summary>
    /// Called when the behavior is removed from the attached control.
    /// Used to remove tap recognizer and perform cleanup.
    /// </summary>
    /// <param name="bindable"></param>
    protected override void OnDetachingFrom(BindableObject bindable)
    {
        base.OnDetachingFrom(bindable);
        if (!_storage.ContainsKey(bindable))
        {
            return;
        }

        TargetStorage targetStorage = _storage[bindable];
        Image target = (Image) bindable;
        target.GestureRecognizers.Remove(targetStorage.TapRecognizer);

        _storage.Remove(bindable);
    }

    /// <summary>
    /// Called when one of the behavior's properties was changed.
    /// Used to update original source value in all image components.
    /// </summary>
    /// <param name="propertyName"></param>
    protected override void OnPropertyChanged(string propertyName = null)
    {
        base.OnPropertyChanged(propertyName);

        if (propertyName == OriginalSourceProperty.PropertyName)
        {
            foreach (KeyValuePair<BindableObject, TargetStorage> entry in _storage)
            {
                if (entry.Value.Active)
                {
                    continue;
                }

                ((Image) entry.Key).Source = SourceToImageSource(OriginalSource);
            }
        }
    }

    #endregion
}
```

We will modify TextReader/ViewModels/TextReaderViewModel.cs file.

1. Define an XML namespace for custom behaviors.

<highlight>5</highlight>

```xml
<ContentPage xmlns="http://xamarin.com/schemas/2014/forms"
             xmlns:x="http://schemas.microsoft.com/winfx/2009/xaml"
             xmlns:viewmodels="clr-namespace:TextReader.ViewModels;"
             xmlns:converters="clr-namespace:TextReader.Converters;"
             xmlns:behaviors="clr-namespace:TextReader.Behaviors;"
             x:Class="TextReader.Views.MainPage"
             Title="Text Reader"
             NavigationPage.HasBackButton="False">

```

2. Attach behavior to the Backward button image (Source property should be removed from Image component).

<highlight>1-5</highlight>

```xml
<Image WidthRequest="134">
    <Image.Behaviors>
        <behaviors:ImageActiveBehavior OriginalSource="images/back.png"
                                       ActiveSource="images/back_hover.png" />
    </Image.Behaviors>
    <Image.GestureRecognizers>
        <TapGestureRecognizer Command="{Binding GoToPreviousUnitCommand}" />
    </Image.GestureRecognizers>
</Image>

```

3. Attach behavior to the Forward button image (Source property should be removed from Image component).

<highlight>1-5</highlight>

```xml
<Image WidthRequest="134">
    <Image.Behaviors>
        <behaviors:ImageActiveBehavior OriginalSource="images/forward.png"
                                       ActiveSource="images/forward_hover.png" />
    </Image.Behaviors>
    <Image.GestureRecognizers>
        <TapGestureRecognizer Command="{Binding GoToNextUnitCommand}" />
    </Image.GestureRecognizers>
</Image>

```

## 3. Tap effect for Play/Pause button

For Play/Pause button we use both ImageActiveBehavior and BoolToStringConverter classes because it has two states (playing, paused) so there should be also two images for each state (default, tapped).

Once again, we will modify TextReader/Views/MainPage.xaml file.

1. Create converter instances for each state (default, tapped) in ResourceDictionary section.

<highlight>8-20</highlight>

```xml
<converters:BoolToStringConverter x:Key="ActiveStateToRepeatAllImage">
    <x:Arguments>
        <x:String>images/repeat_all_hover.png</x:String>
        <x:String>images/repeat_all.png</x:String>
    </x:Arguments>
</converters:BoolToStringConverter>

<converters:BoolToStringConverter x:Key="PlayStateToButtonImage">
    <x:Arguments>
        <x:String>images/pause.png</x:String>
        <x:String>images/play.png</x:String>
    </x:Arguments>
</converters:BoolToStringConverter>

<converters:BoolToStringConverter x:Key="PlayStateToButtonHoverImage">
    <x:Arguments>
        <x:String>images/play_hover.png</x:String>
        <x:String>images/pause_hover.png</x:String>
    </x:Arguments>
</converters:BoolToStringConverter>

```

2. Attach behavior to the Play/Pause button image (Source property should be removed from Image component).

<highlight>1, 5-11</highlight>

```xml
<Image WidthRequest="144">
    <Image.GestureRecognizers>
        <TapGestureRecognizer Command="{Binding TogglePlayStateCommand}" />
    </Image.GestureRecognizers>
    <Image.Behaviors>
        <behaviors:ImageActiveBehavior
                BindingContext="{x:Reference MainContext}"
                OriginalSource="{Binding Playing, Mode=OneWay, Converter={StaticResource PlayStateToButtonImage}}"
                ActiveSource="{Binding Playing, Mode=OneWay, Converter={StaticResource PlayStateToButtonHoverImage}}">
        </behaviors:ImageActiveBehavior>
    </Image.Behaviors>
</Image>

```

For OriginalSource and ActiveSource properties of the behavior, there are one-way bindings created. They allow updating a pair of images used in the behavior when the state of the Playing (view model) property is changed.

# VII. RESET BUTTON

## 1. Goal

The goal of this tutorial's part is to provide a button (Reset button) which restores initial application state. The operation must be confirmed by the user. The reading must be paused while the confirm dialog is displayed.

We will add a toolbar item to the application and use Dialog component from the Tizen.Xamarin.Forms.Extension package.

<img src="/assets/images/tutorials/13/text-reader-reset-1.png" style="width:30%"/>
 
<img src="/assets/images/tutorials/13/text-reader-reset-2.png" style="width:30%"/>

## 2. Extending the view model

We have to add implementation to three view model's commands: ResetCommand, SaveStateAndPauseCommand and RestoreStateCommand. Empty command handlers are already created. The ResetCommand instance is created with an additional method – CanExecuteReset, which returns true value, if the command can be executed.

The ResetCommand will restore view model to its initial state (active paragraph, repeat all, repeat unit).

The SaveStateAndPauseCommand will save the state of playing flag and then pause the reading. It will be used when a confirm dialog shows.

The RestoreStateCommand will restore the state of the reading saved using the SaveStateAndPauseCommand. It will be used when the user will cancel the reset.

We will modify TextReader/ViewModels/TextReaderViewModel.cs file.

1. Add reset command handler implementation which restores initial application state.

<highlight>7-9</highlight>

```csharp
/// <summary>
/// Reset command handler.
/// Restores default states of the reader.
/// </summary>
private void ExecuteReset()
{
    ActiveParagraph = null;
    RepeatAllActive = false;
    RepeatUnitActive = false;
}

```

2. Add CanExecuteReset method implementation. The reset command execution is allowed only if one of the paragraphs is active.

<highlight>7</highlight>

```csharp
/// <summary>
/// Returns true if reset command can be executed, false otherwise.
/// </summary>
/// <returns>True if reset command can be executed, false otherwise</returns>
private bool CanExecuteReset()
{
    return ActiveParagraph != null;
}

```

3. Notify about a possible change in reset command availability using ChangeCanExecute method of Command class.

<highlight>37</highlight>

```csharp
/// <summary>
/// Active paragraph view model.
/// Changing the value will change the current utterance text.
/// </summary>
public ParagraphViewModel ActiveParagraph
{
    get { return _activeParagraph; }
    set
    {
        if (!_ttsModel.Ready)
        {
            return;
        }

        if (_activeParagraph == value)
        {
            return;
        }

        if (_activeParagraph != null)
        {
            _activeParagraph.Active = false;
        }

        if (value != null)
        {
            value.Active = true;
            _ttsModel.Text = value.Text;
        }
        else
        {
            _ttsModel.Stop();
            Playing = _ttsModel.Playing;
        }

        SetProperty(ref _activeParagraph, value);
        ((Command)ResetCommand).ChangeCanExecute();
    }
}

```

4. Add a private field which keeps the saved state of playing flag.

<highlight>6-10</highlight>

```csharp
/// <summary>
/// Flag indicating if the text reader is playing.
/// </summary>
private bool _playing;

/// <summary>
/// Playing flag saved state.
/// Used to restore the state of the reader.
/// </summary>
private bool _playingSavedState;

```

5. Add implementation to SaveStateAndPauseCommand and RestoreStateCommand command handlers.

<highlight>7-14, 23-28</highlight>

```csharp
/// <summary>
/// Save state and pause command handler.
/// Saves state of the playing state and pauses the utterance.
/// </summary>
private void ExecuteSaveStateAndPause()
{
    _playingSavedState = Playing;

    if (Playing)
    {
        _ttsModel.Pause();
    }

    Playing = _ttsModel.Playing;
}

/// <summary>
/// Restore state command handler.
/// Uses saved state of the playing flag to resume the utterance.
/// </summary>
private void ExecuteRestoreState()
{
    if (!Playing && _playingSavedState)
    {
        _ttsModel.Play();
    }

    Playing = _ttsModel.Playing;
}

```

Both command handlers use \_playingSavedState private field to save and then restore the playing state.

## 3. Updating the view

We need to add Reset button and confirmation dialog. We will use toolbar item as a reset button.

We will modify TextReader/Views/MainPage.xaml and TextReader/Views/MainPage.xaml.cs files.

1. In MainPage.xaml file add toolbar item with "RESET" label.

<highlight>3-5</highlight>

```xml
</ContentPage.Resources>

<ContentPage.ToolbarItems>
    <ToolbarItem x:Name="ResetToolbarItem" Text="RESET"></ToolbarItem>
</ContentPage.ToolbarItems>

<StackLayout Spacing="0">

```

2. In MainPage.xaml file define an XML namespace for Tizen Extension components.

<highlight>6</highlight>

```xml
<ContentPage xmlns="http://xamarin.com/schemas/2014/forms"
             xmlns:x="http://schemas.microsoft.com/winfx/2009/xaml"
             xmlns:viewmodels="clr-namespace:TextReader.ViewModels;"
             xmlns:converters="clr-namespace:TextReader.Converters;"
             xmlns:behaviors="clr-namespace:TextReader.Behaviors;"
             xmlns:ext="clr-namespace:Tizen.Xamarin.Forms.Extension;assembly=Tizen.Xamarin.Forms.Extension"
             x:Class="TextReader.Views.MainPage"
             Title="Text Reader"
             NavigationPage.HasBackButton="False">

```

3. In MainPage.xaml file define the confirmation dialog appearance.

<highlight>8-23</highlight>

```xml
<converters:BoolToStringConverter x:Key="PlayStateToButtonHoverImage">
    <x:Arguments>
        <x:String>images/play_hover.png</x:String>
        <x:String>images/pause_hover.png</x:String>
    </x:Arguments>
</converters:BoolToStringConverter>

<ext:Dialog x:Key="ConfirmDialog"
            Title="Reset Confirmation">
    <ext:Dialog.Positive>
        <Button Text="Yes"></Button>
    </ext:Dialog.Positive>
    <ext:Dialog.Negative>
        <Button Text="No"></Button>
    </ext:Dialog.Negative>
</ext:Dialog>

<StackLayout x:Key="ConfirmDialogContent"
             VerticalOptions="FillAndExpand">
    <Label FontSize="23"
           Margin="35, 0, 35, 20"
           Text="Are you sure you want to reset this app to default screen?"></Label>
</StackLayout>

```

4. In MainPage.xaml.cs file add InitResetToolbarItem method which will initialize the Reset toolbar item.

<highlight>7, 10-18</highlight>

```csharp
/// <summary>
/// Main page constructor.
/// </summary>
public MainPage()
{
    InitializeComponent();
    InitResetToolbarItem();
}

/// <summary>
/// Initializes reset button.
/// Reset button shows a confirmation popup.
/// If a user confirms, proper view model command is executed.
/// </summary>
private void InitResetToolbarItem()
{

}

#endregion

```

5. In MainPage.xaml.cs add implementation for InitResetToolbarItem method.

<highlight>8-47</highlight>

```csharp
/// <summary>
/// Initializes reset button.
/// Reset button shows a confirmation popup.
/// If a user confirms, proper view model command is executed.
/// </summary>
private void InitResetToolbarItem()
{
    TextReaderViewModel context = (TextReaderViewModel)BindingContext;

    Dialog confirmDialog = (Dialog)Resources["ConfirmDialog"];

    EventHandler closeHandler = (sender, args) =>
    {
        context.RestoreStateCommand.Execute(null);
        confirmDialog.Hide();
    };

    confirmDialog.Positive.Clicked += (sender, args) =>
    {
        context.ResetCommand.Execute(null);
        ParagraphsListView.ScrollTo(
            ParagraphsListView.ItemsSource.Cast<object>().First(),
            ScrollToPosition.Start,
            animated: false
        );
        confirmDialog.Hide();
    };

    confirmDialog.Negative.Clicked += closeHandler;
    confirmDialog.BackButtonPressed += closeHandler;
    confirmDialog.OutsideClicked += closeHandler;

    ResetToolbarItem.Command = new Command(
        () =>
        {
            confirmDialog.Content = (View)Resources["ConfirmDialogContent"];

            context.SaveStateAndPauseCommand.Execute(null);
            confirmDialog.Show();
        },
        () => context.ResetCommand.CanExecute(null)
    );

    context.ResetCommand.CanExecuteChanged += (sender, args) =>
    {
        ((Command)ResetToolbarItem.Command).ChangeCanExecute();
    };
}

```

This method will set up handlers for following actions: reset item click (command), back button press, dialog positive button click, dialog negative button click and click outside the dialog.

When the reset button is tapped, we execute SaveStateAndPauseCommand command and show the confirmation dialog.

Negative dialog's button, back button (device) and click outside the dialog share the same handler. It executes view model's RestoreStateCommand command and hides the dialog.

When reset is confirmed by the user, ResetCommand command is executed, paragraphs list scrolls to the beginning and the confirmation dialog hides.

- Reference

[Tizen Extension: Dialog API](https://developer.tizen.org/dev-guide/csapi/classTizen_1_1Xamarin_1_1Forms_1_1Extension_1_1Dialog.html)
