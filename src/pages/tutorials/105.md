---
layout: ../../layouts/tutorial/TextTutorial.astro
title: 'How to Create "Compass" App'
description: "This tutorial demonstrates the process of compass application development with the use of Tizen.Sensor.API."
created: "2018/04/21"
modified: "2020/04/19"
profile: ["wearable"]
type: "dotnet"
level: 2
state: "open"
thumbnail: "/assets/images/tutorials/105/compass_thumnail.png"
---

#

# I. INTRODUCTION

## 1. Overview

In the tutorial below, we will learn how to create a compass application using OrientationSensor API. The application will read the current position of the user in relation to the North Pole and present it on a screen.

The tutorial is divided into four chapters:

At the end of this tutorial, we will get the compass application that allows us to determine our position relative to the North Pole.

<img src="/assets/images/tutorials/105/Compass_Wearable_general_screen.png" style="height:360px; width:360px"/>

Content of this tutorial is under [Apache 2.0](http://www.apache.org/licenses/LICENSE-2.0) license.

## 2. Importing and building solution

In this step, we will import and build Visual Studio solution containing initial application code.

Step 1: Download and unpack [Compass.zip](https://tizenschool.org/assets/images/tutorials/105/Compass.zip) file.

Step 2: Click File > Open > Project/Solution...

<img src="/assets/images/tutorials/105/Compass_1_Open_solution.jpg" style="height:400px; width:699px"/>

Step 3: Go to downloaded directory and select Compass.sln file (Microsoft Visual Studio Solution), then click the "Open" button.

<img src="/assets/images/tutorials/105/Compass_2_Open_compass.jpg" style="height:435px; width:699px"/>

The solution structure should appear in the Solution Explorer view. It should contain two projects: Compass and Compass.Tizen.Wearable.

<img src="/assets/images/tutorials/105/Compass_3_solution_structure.jpg" style="height:600px; width:426px"/>

Step 4: Right click on the solution and select "Restore NuGet Packages" from the context menu. This will set up NuGet packages for all projects.

<img src="/assets/images/tutorials/105/Compass_4_restore_nuget.jpg" style="height:600px; width:600px"/>

Step 5: Right click on the solution again and select "Clean Solution" from the context menu.

<img src="/assets/images/tutorials/105/Compass_5_Clean_solution.jpg" style="height:600px; width:600px"/>

Step 6: Right click on the solution again and select "Rebuild Solution" from the context menu.

<img src="/assets/images/tutorials/105/Compass_6_Rebuild_solution.jpg" style="height:600px; width:600px"/>

Step 7: Right click on the "Compass.Tizen.Wearable" project and select "Set as StartUp Project" from the context menu.

<img src="/assets/images/tutorials/105/Compass_7_Set_startup.jpg" style="height:600px; width:600px"/>

The application is ready to be launched on the emulator or target device. This is the base version of the application we are going to work on. Right know it presents only the black screen - we will change it in the next chapters.

<img src="/assets/images/tutorials/105/Compass_8_Initial_page.jpg" style="height:572px; width:464px"/>

# II. APPLICATION LOGIC

## 1. Goal

In this part of the tutorial, we will develop the application logic. We will display the page, create the services, process the data in the model and implement the view model.

<img src="/assets/images/tutorials/105/Compass_2_3_MainPageSet.jpg" style="height:573px; width:464px"/>

## 2. Implementing page navigation

The purpose of this section is to implement a system responsible for presenting selected pages that complies with the MVVM pattern.

Let's start with implementation of service we are going to use. This service will allow to set Compass page as a main application page.

Step 1: We have to add new interface. Our service is connected to the View layer. Right click on the Compass project, select  _Add > New Folder_ from the context menu and name it _Views_ . Now, \** right click on the *Views* folder, select  *Add > New Item...* , choose *Interface* type and name it  *IPageNavigation.cs\*

<img src="/assets/images/tutorials/105/Compass_2_1_ViewsFolder.jpg" style="height:477px; width:385px"/>

Step 2: Let's modify our  _IPageNavigation.cs_ interface _._ Add _CreateMainPage()_ method:

<highlight>3-5,8-15</highlight>

```csharp
namespace Compass.Views
{
    /// <summary>
    /// Provides method to present main application page.
    /// </summary>
    public interface IPageNavigation
    {
        #region methods

        /// <summary>
        /// Creates and sets the main page.
        /// </summary>
        void CreateMainPage();

        #endregion
    }
}

```

Step 3: Next, go to _Compass.Tizen.Wearable_ project. ** Right click on the _Views_ folder ** and add new _PageNavigation.cs_ class \*\* inside it.

<img src="/assets/images/tutorials/105/Compass_2_2_PageNavigationClass.jpg" style="height:477px; width:385px"/>

Step 4: Implement the _IPageNavigation_ interface in \** the *PageNavigation* class *.* Also specify *DependencyAttribute\* .

<highlight>1-5, 9-12, 14-24</highlight>

```csharp
using Compass.Tizen.Wearable.Views;
using Compass.Views;
using Xamarin.Forms;

[assembly: Dependency(typeof(PageNavigation))]

namespace Compass.Tizen.Wearable.Views
{
    /// <summary>
    /// Page navigation implementation for wearable profile.
    /// </summary>
    public class PageNavigation : IPageNavigation
    {
        #region methods

        /// <summary>
        /// Creates and sets the main page.
        /// </summary>
        public void CreateMainPage()
        {
            Application.Current.MainPage = new CompassPage();
        }

        #endregion
    }
}


```

We have service set up. Now we can modify page we want to display. Go to _Views/CompassPage.xaml_ file and change it a bit in order to test our navigation service.

<highlight>5, 8-17</highlight>

```xml
<?xml version="1.0" encoding="utf-8" ?>
<ContentPage xmlns="http://xamarin.com/schemas/2014/forms"
             xmlns:x="http://schemas.microsoft.com/winfx/2009/xaml"
             x:Class="Compass.Tizen.Wearable.Views.CompassPage"
             BackgroundColor="DarkGray"
             x:Name="Root">

    <ContentPage.Content>
        <AbsoluteLayout>
            <Label AbsoluteLayout.LayoutBounds="15, 0, 330, 330"
                   HorizontalTextAlignment="Center"
                   VerticalTextAlignment="Center"
                   Text="Azimuth"
                   TextColor="White"
                   FontAttributes="Bold" />
        </AbsoluteLayout>
    </ContentPage.Content>
</ContentPage>

```

This is just a base view. We will implement the whole compass view in the Chapter III.

Finally, we can set the main page of our application to be  _CompassPage.xaml._ In the _Compass.cs_  file change _App()_ method to use _DependencyService_ and call _CreateMainPage()._

<highlight>1, 15, 19</highlight>

```csharp
using Compass.Views;
using Xamarin.Forms;

namespace Compass
{
    /// <summary>
    /// App class.
    /// </summary>
    public class App : Application
    {
        #region methods

        /// <summary>
        /// App class constructor.
        /// Calls platform specific page manager to create main page.
        /// </summary>
        public App()
        {
            DependencyService.Get<IPageNavigation>().CreateMainPage();
        }

        #endregion
    }
}

```

That is our new main page of the application:

<img src="/assets/images/tutorials/105/Compass_2_3_MainPageSet.jpg" style="height:573px; width:464px"/>

## 3. Setting up services

Let's implement the services. They use the **Tizen.Sensor API** , more specifically the orientation sensor. These services will allow us to read data indicating the location of the device, such as the azimuth.

Step 1: To follow MVVM pattern, first create a folder named _Models_ in our _Compass_ project. Right-click on the _Compass_ project, select _Add > New Folder_ from the context menu and name the new folder _Models_ .

Step 2: Now, we have to add new interface. Right-click on the _Models_ folder, select  _Add > New Item..._ from the context menu, choose type  _Interface_ and name it  _IOrientationSensorService.cs_

<img src="/assets/images/tutorials/105/Compass_3_1_InterfaceCreate.jpg" style="height:477px; width:385px"/>

Step 3: Let's modify our  _IOrientationSensorService.cs_ interface _._  Add two methods:

and two events:

<highlight>5-7,10-36</highlight>

```csharp
using System;

namespace Compass.Models
{
    /// <summary>
    /// Orientation sensor service interface.
    /// </summary>
    public interface IOrientationSensorService
    {
        #region properties

        /// <summary>
        /// Event invoked whenever orientation sensor's data is updated.
        /// </summary>
        event EventHandler<float> OrientationSensorDataUpdated;

        /// <summary>
        /// Event invoked if the orientation sensor is not supported.
        /// </summary>
        event EventHandler NotSupported;

        #endregion

        #region methods

        /// <summary>
        /// Initializes the service.
        /// </summary>
        void Init();

        /// <summary>
        /// Starts orientation sensor.
        /// </summary>
        void Start();

        #endregion
    }
}

```

Step 4: Next, go to  _Compass.Tizen.Wearable_  project. ** Create a folder _Services_ and then add a new  _OrientationSensorService.cs_ class ** inside it.

<img src="/assets/images/tutorials/105/Compass_3_2_ServiceCreate.jpg" style="height:477px; width:385px"/>

Step 5: Implement the  _IOrientationSensorService_ interface in \** the  *OrientationSensorService* class *.*  Also, specify  *DependencyAttribute\* .

<highlight>2-5,9-13,15-45</highlight>

```csharp
using System;
using Compass.Models;
using Compass.Tizen.Wearable.Services;

[assembly: Xamarin.Forms.Dependency(typeof(OrientationSensorService))]

namespace Compass.Tizen.Wearable.Services
{
    /// <summary>
    /// Allows to obtain the orientation sensor's data.
    /// Implements IOrientationSensorService interface.
    /// </summary>
    public class OrientationSensorService : IOrientationSensorService
    {
        #region properties

        /// <summary>
        /// Event invoked whenever orientation sensor's data is updated.
        /// </summary>
        public event EventHandler<float> OrientationSensorDataUpdated;

        /// <summary>
        /// Event invoked if the orientation sensor is not supported.
        /// </summary>
        public event EventHandler NotSupported;

        #endregion

        #region methods

        /// <summary>
        /// Initializes the service.
        /// </summary>
        public void Init()
        {
        }

        /// <summary>
        /// Starts the orientation sensor.
        /// </summary>
        public void Start()
        {
        }

        #endregion
    }
}

```

Step 6: Create an OrientationSensor field and implement _Init()_ and _Start()_ methods. Add _OnDataUpdated()_ method to handle _DataUpdated_ event of the orientation service.

<highlight>4, 16-24, 46-54, 62, 65-75</highlight>

```csharp
using System;
using Compass.Models;
using Compass.Tizen.Wearable.Services;
using Tizen.Sensor;

[assembly: Xamarin.Forms.Dependency(typeof(OrientationSensorService))]

namespace Compass.Tizen.Wearable.Services
{
    /// <summary>
    /// Allows to obtain the orientation sensor's data.
    /// Implements IOrientationSensorService interface.
    /// </summary>
    public class OrientationSensorService : IOrientationSensorService
    {
        #region fields

        /// <summary>
        /// Reference to native API orientation sensor instance which allows to obtain sensor's data.
        /// </summary>
        private OrientationSensor _orientationSensor;

        #endregion

        #region properties

        /// <summary>
        /// Event invoked whenever orientation sensor's data is updated.
        /// </summary>
        public event EventHandler<float> OrientationSensorDataUpdated;

        /// <summary>
        /// Event invoked if the orientation sensor is not supported.
        /// </summary>
        public event EventHandler NotSupported;

        #endregion

        #region methods

        /// <summary>
        /// Initializes the service.
        /// </summary>
        public void Init()
        {
            if (!OrientationSensor.IsSupported)
            {
                NotSupported?.Invoke(this, null);
                return;
            }

            _orientationSensor = new OrientationSensor();
            _orientationSensor.Interval = 10;
            _orientationSensor.DataUpdated += OnDataUpdated;
        }

        /// <summary>
        /// Starts the orientation sensor.
        /// </summary>
        public void Start()
        {
            _orientationSensor?.Start();
        }

        /// <summary>
        /// Handles "DataUpdated" event of the orientation sensor.
        /// Invokes "OrientationSensorDataUpdated" event.
        /// </summary>
        /// <param name="sender">Instance of the object which invokes the event.</param>
        /// <param name="eventArgs">Event data.</param>
        private void OnDataUpdated(object sender, OrientationSensorDataUpdatedEventArgs eventArgs)
        {
            OrientationSensorDataUpdated?.Invoke(this, eventArgs.Azimuth);
        }

        #endregion
    }
}

```

## 4. Building model

To make use of our services, we have to develop our model class that will process sensor data.

Step 1: Right-click on the _Models_ folder, select  _Add > New Item..._ from the context menu and create a _CompassModel_ class.

Step 2: Add a field which stores service class instance and allows to obtain orientation sensor's data.

<highlight>3-5, 8-16</highlight>

```csharp
namespace Compass.Models
{
    /// <summary>
    /// Provides methods to obtain the compass data.
    /// </summary>
    public class CompassModel
    {
        #region fields

        /// <summary>
        /// Stores platform specific service class instance obtained with dependency injection.
        /// Allows to obtain orientation sensor's data.
        /// </summary>
        private IOrientationSensorService _orientationSensorService;

        #endregion
    }
}

```

Step 3: Add an  _InitOrientationSensor()_  method which will initialize orientation sensor. Call this method in the class constructor.

<highlight>1-2, 19-40</highlight>

```csharp
using Xamarin.Forms;

namespace Compass.Models
{
    /// <summary>
    /// Provides methods to obtain the compass data.
    /// </summary>
    public class CompassModel
    {
        #region fields

        /// <summary>
        /// Stores platform specific service class instance obtained with dependency injection.
        /// Allows to obtain orientation sensor's data.
        /// </summary>
        private IOrientationSensorService _orientationSensorService;

        #endregion

        #region methods

        /// <summary>
        /// CompassModel class constructor.
        /// Initializes the model.
        /// </summary>
        public CompassModel()
        {
            InitOrientationSensor();
        }

        /// <summary>
        /// Initializes orientation sensor.
        /// </summary>
        private void InitOrientationSensor()
        {
            _orientationSensorService = DependencyService.Get<IOrientationSensorService>();
            _orientationSensorService.Init();
        }

        #endregion
    }
}


```

Step 4: Create a  _NotSupported event_ - invoked if the compass is not supported on the device; and  _OnNotSupported()_  method to handle _NotSupported_ event of the sensor service. Invoke _NotSupported_ event inside it. In the  _InitOrientationSensor()_ method subscribe to the orientation sensor _NotSupported_ event.

<highlight>1, 20-28, 47, 51-61</highlight>

```csharp
using System;
using Xamarin.Forms;

namespace Compass.Models
{
    /// <summary>
    /// Provides methods to obtain the compass data.
    /// </summary>
    public class CompassModel
    {
        #region fields

        /// <summary>
        /// Stores platform specific service class instance obtained with dependency injection.
        /// Allows to obtain orientation sensor's data.
        /// </summary>
        private IOrientationSensorService _orientationSensorService;

        #endregion

        #region properties

        /// <summary>
        /// Event invoked if the compass is not supported.
        /// </summary>
        public event EventHandler NotSupported;

        #endregion

        #region methods

        /// <summary>
        /// CompassModel class constructor.
        /// Initializes the model.
        /// </summary>
        public CompassModel()
        {
            InitOrientationSensor();
        }

        /// <summary>
        /// Initializes orientation sensor.
        /// </summary>
        private void InitOrientationSensor()
        {
            _orientationSensorService = DependencyService.Get<IOrientationSensorService>();
            _orientationSensorService.NotSupported += OnNotSupported;
            _orientationSensorService.Init();
        }

        /// <summary>
        /// Handles "NotSupported" event of the sensor service.
        /// Invokes "NotSupported" event.
        /// </summary>
        /// <param name="sender">Instance of the object which invoked the event.</param>
        /// <param name="eventArgs">Event data.</param>
        private void OnNotSupported(object sender, EventArgs eventArgs)
        {
            NotSupported?.Invoke(this, null);
        }

        #endregion
    }
}

```

Step 5: Create a public _Start()_ method which will start the compass.

<highlight>6-13</highlight>

```csharp
        private void OnNotSupported(object sender, EventArgs eventArgs)
        {
            NotSupported?.Invoke(this, null);
        }

        /// <summary>
        /// Starts the compass.
        /// </summary>
        public void Start()
        {
            _orientationSensorService.Start();
        }

        #endregion
    }
}


```

We have the basis of our model. In the following chapters we will deal with the processing of sensor data.

## 5. Compass data processing - part I

The data we receive from the sensor must be processed in order to obtain the necessary information from it.

Let's start from calculating the deviation from the North Pole. It is important that the data displayed to the user is as accurate as possible, so we have to deal with some erroneous measurements. In order to do this, we will load 50 sensor readings, then calculate their avarage and pass this information to other application modules.

Step 1: Right-click on the _Compass_  project, add a new _Utils_ folder and a  _DeviationCalculator.cs_ class inside.

Step 2: Add a _MAX_NUMBER_OF_MEASUREMENTS_ constant that holds the maximum number of measurements before averaging, a  _\_measurements_  array that stores the consecutive readings, as well as a _\_counter_ field that counts the number of accumulated measurements.

<highlight>3-5,8-25</highlight>

```csharp
namespace Compass.Utils
{
    /// <summary>
    /// Calculates average compass deviation.
    /// </summary>
    public class DeviationCalculator
    {
        #region fields

        /// <summary>
        /// Number of measurements used to calculate average.
        /// </summary>
        private const int MAX_NUMBER_OF_MEASUREMENTS = 50;

        /// <summary>
        /// Contains measurements to calculate average from.
        /// </summary>
        private float[] _measurements;

        /// <summary>
        /// Number of gathered measurements.
        /// </summary>
        private int _counter;

        #endregion
    }
}

```

Step 3: In the constructor, initialize our array.

<highlight>7-18</highlight>

```csharp
        /// <summary>
        /// Number of gathered measurements.
        /// </summary>
        private int _counter;

        #endregion

        #region methods

        /// <summary>
        /// Initializes the class.
        /// </summary>
        public DeviationCalculator()
        {
            _measurements = new float[MAX_NUMBER_OF_MEASUREMENTS];
        }

        #endregion
    }
}

```

Step 4: At this point we have to implement a procedure of action:

<highlight>12-48</highlight>

```csharp
        #region methods

        /// <summary>
        /// DeviationCalculator class constructor.
        /// Initializes the class.
        /// </summary>
        public DeviationCalculator()
        {
            _measurements = new float[MAX_NUMBER_OF_MEASUREMENTS];
        }

        /// <summary>
        /// Checks whether all measurements have been gathered.
        /// If so, starts calculating deviation.
        /// </summary>
        private void CheckCounter()
        {
            if (_counter >= MAX_NUMBER_OF_MEASUREMENTS)
            {
                CalculateDeviation();
                _counter = 0;
            }
        }

        /// <summary>
        /// Calculates average compass deviation.
        /// </summary>
        private void CalculateDeviation()
        {
            float deviation = 0;

            for (int i = 0; i < _counter; i++)
            {
                deviation += _measurements[i];
            }
        }

        /// <summary>
        /// Adds a new measurement to the list of measurements.
        /// </summary>
        /// <param name="newMeasurements">New compass deviation measurement.</param>
        public void Add(float newMeasurements)
        {
            _measurements[_counter] = newMeasurements;
            _counter++;
            CheckCounter();
        }

        #endregion

```

Step 5: Whenever an averaged deviation is calculated, we want the interested application modules to be notified about it. For this purpose, we will create and call a  _DeviationCalculated_  event that will pass the calculated data.

<highlight>1-2,29-37, 74-75</highlight>

```csharp
using System;

namespace Compass.Utils
{
    /// <summary>
    /// Calculates average compass deviation.
    /// </summary>
    public class DeviationCalculator
    {
        #region fields

        /// <summary>
        /// Number of measurements used to calculate average.
        /// </summary>
        private const int MAX_NUMBER_OF_MEASUREMENTS = 50;

        /// <summary>
        /// Contains measurements to calculate average from.
        /// </summary>
        private float[] _measurements;

        /// <summary>
        /// Number of gathered measurements.
        /// </summary>
        private int _counter;

        #endregion

        #region properties

        /// <summary>
        /// Event invoked when average compass deviation is calculated.
        /// </summary>
        public event EventHandler<float> DeviationCalculated;

        #endregion

        #region methods

        /// <summary>
        /// DeviationCalculator class constructor.
        /// Initializes the class.
        /// </summary>
        public DeviationCalculator()
        {
            _measurements = new float[MAX_NUMBER_OF_MEASUREMENTS];
        }

        /// <summary>
        /// Checks whether all measurements have been gathered.
        /// If so, starts calculating deviation.
        /// </summary>
        private void CheckCounter()
        {
            if (_counter >= MAX_NUMBER_OF_MEASUREMENTS)
            {
                CalculateDeviation();
                _counter = 0;
            }
        }

        /// <summary>
        /// Calculates average compass deviation.
        /// Invokes "DeviationCalculated" event.
        /// </summary>
        private void CalculateDeviation()
        {
            float deviation = 0;

            for (int i = 0; i < _counter; i++)
            {
                deviation += _measurements[i];
            }

            DeviationCalculated?.Invoke(this, deviation / (_counter + 1));
        }

        /// <summary>
        /// Adds a new measurement to the list of measurements.
        /// </summary>
        /// <param name="newMeasurements">New compass deviation measurement.</param>
        public void Add(float newMeasurements)
        {
            _measurements[_counter] = newMeasurements;
            _counter++;
            CheckCounter();
        }

        #endregion
    }
}

```

Step 6: Now we will be modifying our _CompassModel_ class. Initiate the deviation calculator.

<highlight>1,14-18,44,47-54</highlight>

```csharp
using Compass.Utils;
using System;
using Xamarin.Forms;

namespace Compass.Models
{
    /// <summary>
    /// Provides methods to obtain the compass data.
    /// </summary>
    public class CompassModel
    {
        #region fields

        /// <summary>
        /// Calculates compass deviation.
        /// </summary>
        private DeviationCalculator _deviationCalculator;

        /// <summary>
        /// Stores platform specific service class instance obtained with dependency injection.
        /// Allows to obtain orientation sensor's data.
        /// </summary>
        private IOrientationSensorService _orientationSensorService;

        #endregion

        #region properties

        /// <summary>
        /// Event invoked if the compass is not supported.
        /// </summary>
        public event EventHandler NotSupported;

        #endregion

        #region methods

        /// <summary>
        /// CompassModel class constructor.
        /// Initializes the model.
        /// </summary>
        public CompassModel()
        {
            InitDeviationCalculator();
            InitOrientationSensor();
        }

        /// <summary>
        /// Initializes deviation calculator.
        /// </summary>
        private void InitDeviationCalculator()
        {
            _deviationCalculator = new DeviationCalculator();
        }

```

Step 7: Add an _OnCompassDataUpdated()_ method to handle the _OrientationSensorDataUpdated_ event from our sensor. The method should pass the sensor reading to our calculator.

<highlight>11-21,36</highlight>

```csharp
        /// <summary>
        /// CompassModel class constructor.
        /// Initializes the model.
        /// </summary>
        public CompassModel()
        {
            InitDeviationCalculator();
            InitOrientationSensor();
        }

        /// <summary>
        /// Handles "OrientationSensorDataUpdated" event of the IOrientationSensorService object.
        /// Adds a new measurement to deviation calculator.
        /// </summary>
        /// <param name="sender">Instance of the object which invoked the event.</param>
        /// <param name="azimuth">The current azimuth.</param>
        private void OnCompassDataUpdated(object sender, float azimuth)
        {
            _deviationCalculator.Add(azimuth);
        }

        /// <summary>
        /// Initializes deviation calculator.
        /// </summary>
        private void InitDeviationCalculator()
        {
            _deviationCalculator = new DeviationCalculator();
        }

        /// <summary>
        /// Initializes orientation sensor.
        /// </summary>
        private void InitOrientationSensor()
        {
            _orientationSensorService = DependencyService.Get<IOrientationSensorService>();
            _orientationSensorService.OrientationSensorDataUpdated += OnCompassDataUpdated;
            _orientationSensorService.NotSupported += OnNotSupported;
            _orientationSensorService.Init();
        }

```

Step 8: We also need to subscribe to the _DeviationCalculated_ event from our calculator. The handler will be implemented in the next section.

<highlight>12-20,27</highlight>

```csharp
        /// <summary>
        /// Handles "OrientationSensorDataUpdated" event of the IOrientationSensorService object.
        /// Adds a new measurement to deviation calculator.
        /// </summary>
        /// <param name="sender">Instance of the object which invoked the event.</param>
        /// <param name="azimuth">The current azimuth.</param>
        private void OnCompassDataUpdated(object sender, float azimuth)
        {
            _deviationCalculator.Add(azimuth);
        }

        /// <summary>
        /// Handles "OrientationSensorDataUpdated" event of the sensor service.
        /// </summary>
        /// <param name="sender">Instance of the object which invoked the event.</param>
        /// <param name="azimuth">Calculated deviation.</param>
        private void OnDeviationCalculated(object sender, float azimuth)
        {
        }

        /// <summary>
        /// Initializes deviation calculator.
        /// </summary>
        private void InitDeviationCalculator()
        {
            _deviationCalculator = new DeviationCalculator();
            _deviationCalculator.DeviationCalculated += OnDeviationCalculated;
        }

```

## 6. Compass data processing - part II

Having the current azimuth we should determine the direction indicated by the compass.

Step 1: In the _Utils_ folder create _CompassDirections.cs_ enumerator, which will have the directions possible to be indicated by the compass.

<highlight>3-51</highlight>

```csharp
namespace Compass.Utils
{
    /// <summary>
    /// Enumerator that contains compass directions.
    /// </summary>
    public enum CompassDirections
    {
        /// <summary>
        /// Northeast direction.
        /// </summary>
        NorthEast,

        /// <summary>
        /// East direction.
        /// </summary>
        East,

        /// <summary>
        /// Southeast direction.
        /// </summary>
        SouthEast,

        /// <summary>
        /// South direction.
        /// </summary>
        South,

        /// <summary>
        /// Southwest direction.
        /// </summary>
        SouthWest,

        /// <summary>
        /// West direction.
        /// </summary>
        West,

        /// <summary>
        /// Northwest direction.
        /// </summary>
        NorthWest,

        /// <summary>
        /// North direction.
        /// </summary>
        North,

        /// <summary>
        /// Undefined direction.
        /// </summary>
        Undefined
    }
}

```

Step 2: In the _Utils_ folder add _DirectionIndicator.cs_ class. Create a  _\_directionBoundaries_ array in it that stores the limit values of the subsequent directions.

<highlight>3-5,8-15</highlight>

```csharp
namespace Compass.Utils
{
    /// <summary>
    /// Indicates compass direction.
    /// </summary>
    public class DirectionIndicator
    {
        #region fields

        /// <summary>
        /// Limit values for directions.
        /// </summary>
        private static readonly int[] _directionBoundaries = { 23, 67, 113, 157, 203, 247, 293, 337 };

        #endregion
    }
}

```

Step 3: Add a _\_directionDictionary_ dictionary that will store the directions starting from the northeast and going clockwise.

<highlight>1-2,17-32</highlight>

```csharp
using System.Collections.Generic;

namespace Compass.Utils
{
    /// <summary>
    /// Indicates compass direction.
    /// </summary>
    public class DirectionIndicator
    {
        #region fields

        /// <summary>
        /// Limit values for directions.
        /// </summary>
        private static readonly int[] _directionBoundaries = { 23, 67, 113, 157, 203, 247, 293, 337 };

        /// <summary>
        /// Dictionary with all possible options of the compass direction.
        /// </summary>
        private static readonly Dictionary<int, CompassDirections> _directionDictionary =
            new Dictionary<int, CompassDirections>
            {
                { 0, CompassDirections.NorthEast },
                { 1, CompassDirections.East },
                { 2, CompassDirections.SouthEast },
                { 3, CompassDirections.South },
                { 4, CompassDirections.SouthWest },
                { 5, CompassDirections.West },
                { 6, CompassDirections.NorthWest },
                { 7, CompassDirections.North }
            };

        #endregion
    }
}

```

Step 4: Implement a  _GetCompassDirection()_  method that takes the current azimuth and returns the corresponding direction.

<highlight>18-41</highlight>

```csharp
        /// <summary>
        /// Dictionary with all possible options of the compass direction.
        /// </summary>
        private static readonly Dictionary<int, CompassDirections> _directionDictionary =
            new Dictionary<int, CompassDirections>
            {
                { 0, CompassDirections.NorthEast },
                { 1, CompassDirections.East },
                { 2, CompassDirections.SouthEast },
                { 3, CompassDirections.South },
                { 4, CompassDirections.SouthWest },
                { 5, CompassDirections.West },
                { 6, CompassDirections.NorthWest },
                { 7, CompassDirections.North }
            };

        #endregion

        #region methods

        /// <summary>
        /// Returns compass direction.
        /// </summary>
        /// <param name="azimuth">Compass deviation.</param>
        /// <returns>Compass direction.</returns>
        public static CompassDirections GetCompassDirection(float azimuth)
        {
            CompassDirections compassDirection = CompassDirections.North;

            for (int i = 0; i < _directionBoundaries.Length; i++)
            {
                if (azimuth > _directionBoundaries[i])
                {
                    compassDirection = _directionDictionary[i];
                }
            }

            return compassDirection;
        }

        #endregion
    }
}

```

Step 5: Go back to our _CompassModel.cs_ . Let's implement a _CompassDataUpdated_ event that will transmit the current compass deviation and direction. Firstly, create _CompassDataUpdatedEventHandler_ delegate.

<highlight>14-22</highlight>

```csharp
        #region fields

        /// <summary>
        /// Calculates compass deviation.
        /// </summary>
        private DeviationCalculator _deviationCalculator;

        /// <summary>
        /// Stores platform specific service class instance obtained with dependency injection.
        /// Allows to obtain orientation sensor's data.
        /// </summary>
        private IOrientationSensorService _orientationSensorService;

        /// <summary>
        /// Event handler for the compass data updated event.
        /// </summary>
        /// <param name="sender">Instance of the object which invoked event.</param>
        /// <param name="compassDeviation">Compass deviation.</param>
        /// <param name="compassDirection">Compass direction.</param>
        public delegate void CompassDataUpdatedEventHandler(object sender, float compassDeviation,
            CompassDirections compassDirection);

        #endregion

```

Step 6: Declare  _CompassDataUpdated_ event.

<highlight>3-7</highlight>

```csharp
        #region properties

        /// <summary>
        /// Event invoked whenever compass state is updated.
        /// </summary>
        public event CompassDataUpdatedEventHandler CompassDataUpdated;

        /// <summary>
        /// Event invoked if the compass is not supported.
        /// </summary>
        public event EventHandler NotSupported;

        #endregion

```

Step 7: Implement the method we created in the previous section - _OnDeviationCalculated()_ . We want it to call _CompassDataUpdated_ event with processed data.

<highlight>14,20</highlight>

```csharp
        /// <summary>
        /// Handles "OrientationSensorDataUpdated" event of the IOrientationSensorService object.
        /// Adds a new measurement to deviation calculator.
        /// </summary>
        /// <param name="sender">Instance of the object which invoked the event.</param>
        /// <param name="azimuth">The current azimuth.</param>
        private void OnCompassDataUpdated(object sender, float azimuth)
        {
            _deviationCalculator.Add(azimuth);
        }

        /// <summary>
        /// Handles "OrientationSensorDataUpdated" event of the sensor service.
        /// Invokes "CompassDataUpdated" event.
        /// </summary>
        /// <param name="sender">Instance of the object which invoked the event.</param>
        /// <param name="azimuth">Calculated deviation.</param>
        private void OnDeviationCalculated(object sender, float azimuth)
        {
            CompassDataUpdated?.Invoke(this, azimuth, DirectionIndicator.GetCompassDirection(azimuth));
        }

        /// <summary>
        /// Initializes deviation calculator.
        /// </summary>
        private void InitDeviationCalculator()
        {
            _deviationCalculator = new DeviationCalculator();
            _deviationCalculator.DeviationCalculated += OnDeviationCalculated;
        }

```

## 7. Implementing view model

In order to show all the data to the user we need a view model, which acts as a connection between the model and the view and is responsible for the presentation logic.

Step 1: In _ViewModels_ folder create _CompassViewModel_ class. It must inherit from the ViewModelBase class.

<highlight>3-6</highlight>

```csharp
namespace Compass.ViewModels
{
    /// <summary>
    /// Provides methods responsible for application view model state.
    /// </summary>
    public class CompassViewModel : ViewModelBase
    {
    }
}

```

Step 2: Let's start with creating the instance of our model class _\_compassModel_ , and then implementing the fields we need for the properties: _\_compassDeviation_ and _\_compassDirection_ .

<highlight>1-3,11-28</highlight>

```csharp
using Compass.Models;
using Compass.Utils;

namespace Compass.ViewModels
{
    /// <summary>
    /// Provides methods responsible for application view model state.
    /// </summary>
    public class CompassViewModel : ViewModelBase
    {
        #region fields

        /// <summary>
        /// Backing field of the CompassDeviation property.
        /// </summary>
        private float _compassDeviation;

        /// <summary>
        /// Backing field of the CompassDirection property.
        /// </summary>
        private CompassDirections _compassDirection;

        /// <summary>
        /// Provides methods to obtain the compass data.
        /// </summary>
        private CompassModel _compassModel = new CompassModel();

        #endregion
    }
}

```

Step 3: In the next step, we add two properties: _CompassDeviation_ responsible for indicating current compass deviation and _CompassDirection_ showing the current compass direction.

<highlight>4-25</highlight>

```csharp
        private CompassModel _compassModel = new CompassModel();

        #endregion

        #region properties

        /// <summary>
        /// Current compass deviation.
        /// </summary>
        public float CompassDeviation
        {
            get => _compassDeviation;
            private set => SetProperty(ref _compassDeviation, value);
        }

        /// <summary>
        /// Current compass direction.
        /// </summary>
        public CompassDirections CompassDirection
        {
            get => _compassDirection;
            private set => SetProperty(ref _compassDirection, value);
        }

        #endregion
    }
}

```

Step 4: Now we are going to implement a _OnCompassDataUpdated()_ method that handles each change in the compass data and assigns new values to our properties.

<highlight>8-24</highlight>

```csharp
        public CompassDirections CompassDirection
        {
            get => _compassDirection;
            private set => SetProperty(ref _compassDirection, value);
        }

        #endregion

        #region methods

        /// <summary>
        /// Handles "CompassDataUpdated" event of the CompassModel class.
        /// Updates value of CompassDeviation and CompassDirection properties.
        /// </summary>
        /// <param name="sender">Instance of the object which invoked the event.</param>
        /// <param name="compassDeviation">Compass deviation.</param>
        /// <param name="compassDirection">Compass direction.</param>
        private void OnCompassDataUpdated(object sender, float compassDeviation, CompassDirections compassDirection)
        {
            CompassDeviation = compassDeviation;
            CompassDirection = compassDirection;
        }

        #endregion
    }

```

Step 5: In our view model class constructor we must subscribe to the _CompassDataUpdated_ event of our _\_compassModel_  class instance. We also start the compass module.

<highlight>3-11</highlight>

```csharp
        #region methods

        /// <summary>
        /// Initializes the view model.
        /// </summary>
        public CompassViewModel()
        {
            _compassModel.CompassDataUpdated += OnCompassDataUpdated;
            _compassModel?.Start();
        }

        /// <summary>
        /// Handles "CompassDataUpdated" event of the CompassModel class.

```

<br/> 

# III. APPLICATION USER INTERFACE

## 1. Goal

It is high time to deal with the interface. In this chapter we will create a full UI of the application, fill it with data from the model using binding, and then animate it with the behavior.

<img src="/assets/images/tutorials/105/Compass_Wearable_general_screen.png" style="height:360px; width:360px"/>

## 2. Creating application UI

Let's start with setting the user interface elements. All changes described on this page will be made in the _CompassPage.xaml_ file.

Step 1: Set the background of the application, apply a compass rose on it, and also a picture imitating a glass cover.

<highlight>5, 10-15</highlight>

```xml
<?xml version="1.0" encoding="utf-8" ?>
<ContentPage xmlns="http://xamarin.com/schemas/2014/forms"
             xmlns:x="http://schemas.microsoft.com/winfx/2009/xaml"
             x:Class="Compass.Tizen.Wearable.Views.CompassPage"
             BackgroundImage="compass_background_w.png"
             x:Name="Root">

    <ContentPage.Content>
        <AbsoluteLayout>
            <Image AbsoluteLayout.LayoutBounds="20, 20, 320, 320"
                   Source="compass_rotation_w.png" />
            <Image AbsoluteLayout.LayoutBounds="15, 15, 330, 330"
                   Source="compass_counter_w.png" />
            <Image AbsoluteLayout.LayoutBounds="20, 20, 320, 320"
                   Source="compass_cover_w.png" />
        </AbsoluteLayout>
    </ContentPage.Content>
</ContentPage>

```

Step 2: Between the compass rose and the 'glass', add a label indicating the current azimuth. We temporarily set it to '0°', on the following pages we will assign it data from our compass model.

<highlight>7-12</highlight>

```xml
    <ContentPage.Content>
        <AbsoluteLayout>
            <Image AbsoluteLayout.LayoutBounds="20, 20, 320, 320"
                   Source="compass_rotation_w.png" />
            <Image AbsoluteLayout.LayoutBounds="15, 15, 330, 330"
                   Source="compass_counter_w.png" />
            <Label AbsoluteLayout.LayoutBounds="15, 0, 330, 330"
                   HorizontalTextAlignment="Center"
                   VerticalTextAlignment="Center"
                   Text="0°"
                   TextColor="White"
                   FontAttributes="Bold" />
            <Image AbsoluteLayout.LayoutBounds="20, 20, 320, 320"
                   Source="compass_cover_w.png" />
        </AbsoluteLayout>
    </ContentPage.Content>

```

Step 3: Add a label to indicate the specific direction of the current azimuth. We will also modify it on the next page, but at this point we will assign it the value 'N'.

<highlight>13-19</highlight>

```xml
    <ContentPage.Content>
        <AbsoluteLayout>
            <Image AbsoluteLayout.LayoutBounds="20, 20, 320, 320"
                   Source="compass_rotation_w.png" />
            <Image AbsoluteLayout.LayoutBounds="15, 15, 330, 330"
                   Source="compass_counter_w.png" />
            <Label AbsoluteLayout.LayoutBounds="15, 0, 330, 330"
                   HorizontalTextAlignment="Center"
                   VerticalTextAlignment="Center"
                   Text="0°"
                   TextColor="White"
                   FontAttributes="Bold" />
            <Label AbsoluteLayout.LayoutBounds="15, 35, 330, 330"
                   HorizontalTextAlignment="Center"
                   VerticalTextAlignment="Center"
                   Text="N"
                   TextColor="White"
                   FontSize="12"
                   FontAttributes="Bold" />
            <Image AbsoluteLayout.LayoutBounds="20, 20, 320, 320"
                   Source="compass_cover_w.png" />
        </AbsoluteLayout>
    </ContentPage.Content>

```

Final result:

<img src="/assets/images/tutorials/105/Compass_4_1_UI_set.png" style="height:360px; width:360px"/>

## 3. Binding the view model to the view

This section is about connecting our view model  _CompassViewModel.cs_ with the view  _CompassPage.xaml._ We are going to use the binding technique.

Step 1: Open  _CompassPage.xaml_  file and set the binding context here:

<highlight>5, 9-12</highlight>

```xml
<?xml version="1.0" encoding="utf-8" ?>
<ContentPage xmlns="http://xamarin.com/schemas/2014/forms"
             xmlns:x="http://schemas.microsoft.com/winfx/2009/xaml"
             x:Class="Compass.Tizen.Wearable.Views.CompassPage"
             xmlns:viewModels="clr-namespace:Compass.ViewModels;assembly=Compass"
             BackgroundImage="compass_background_w.png"
             x:Name="Root">

    <ContentPage.BindingContext>
        <viewModels:CompassViewModel x:Name="CompassViewModel" />
    </ContentPage.BindingContext>

    <ContentPage.Content>
        <AbsoluteLayout>

```

Step 2: Bind  _CompassDeviation_ property. We want displayed values to always be presented as degrees, so we also set the StringFormat attribute.

<highlight>10</highlight>

```xml
    <ContentPage.Content>
        <AbsoluteLayout>
            <Image AbsoluteLayout.LayoutBounds="20, 20, 320, 320"
                   Source="compass_rotation_w.png" />
            <Image AbsoluteLayout.LayoutBounds="15, 15, 330, 330"
                   Source="compass_counter_w.png" />
            <Label AbsoluteLayout.LayoutBounds="15, 0, 330, 330"
                   HorizontalTextAlignment="Center"
                   VerticalTextAlignment="Center"
                   Text="{Binding CompassDeviation, StringFormat='{0:F0}°'}"
                   TextColor="White"
                   FontAttributes="Bold" />
            <Label AbsoluteLayout.LayoutBounds="15, 35, 330, 330"
                   HorizontalTextAlignment="Center"
                   VerticalTextAlignment="Center"
                   Text="N"
                   TextColor="White"
                   FontSize="12"
                   FontAttributes="Bold" />
            <Image AbsoluteLayout.LayoutBounds="20, 20, 320, 320"
                   Source="compass_cover_w.png" />
        </AbsoluteLayout>
    </ContentPage.Content>

```

Step 3: We also want to bind the _CompassDirection_ property. However, its type excludes the possibility of direct binding, so we need to create a converter. Create _Converters_ folder in our _Compass_ project and add _CompassDirectionToDirectionIndicatorConverter.cs._ The class should implement _IValueConverter_ interface.

<highlight>2-3, 7-10, 12-41</highlight>

```csharp
using System;
using System.Globalization;
using Xamarin.Forms;

namespace Compass.Converters
{
    /// <summary>
    /// Converts the compass direction to direction indicator.
    /// </summary>
    public class CompassDirectionToDirectionIndicatorConverter : IValueConverter
    {
        #region methods

        /// <summary>
        /// Converts the compass direction to direction indicator.
        /// </summary>
        /// <param name="value">The value produced by the binding source.</param>
        /// <param name="targetType">The type of the binding target property.</param>
        /// <param name="parameter">The converter parameter to use.</param>
        /// <param name="culture">The culture to use in the converter.</param>
        /// <returns>Direction indicator.</returns>
        public object Convert(object value, Type targetType, object parameter, CultureInfo culture)
        {
            throw new NotImplementedException();
        }

        /// <summary>
        /// Converts direction indicator to compass direction.
        /// Not required by the application, so it is not implemented.
        /// </summary>
        /// <param name="value">The value produced by the binding source.</param>
        /// <param name="targetType">The type of the binding target property.</param>
        /// <param name="parameter">The converter parameter to use.</param>
        /// <param name="culture">The culture to use in the converter.</param>
        /// <returns>Converted value.</returns>
        public object ConvertBack(object value, Type targetType, object parameter, CultureInfo culture)
        {
            throw new NotImplementedException();
        }

        #endregion
    }
}

```

Step 4: When converting, we have to check if we are dealing with the value of the _CompassDirection_ type. If so, the corresponding direction symbol is returned.

<highlight>1,25-48</highlight>

```csharp
using Compass.Utils;
using System;
using System.Globalization;
using Xamarin.Forms;

namespace Compass.Converters
{
    /// <summary>
    /// Converts the compass direction to direction indicator.
    /// </summary>
    public class CompassDirectionToDirectionIndicatorConverter : IValueConverter
    {
        #region methods

        /// <summary>
        /// Converts the compass direction to direction indicator.
        /// </summary>
        /// <param name="value">The value produced by the binding source.</param>
        /// <param name="targetType">The type of the binding target property.</param>
        /// <param name="parameter">The converter parameter to use.</param>
        /// <param name="culture">The culture to use in the converter.</param>
        /// <returns>Direction indicator.</returns>
        public object Convert(object value, Type targetType, object parameter, CultureInfo culture)
        {
            if (value is CompassDirections compassDirection)
            {
                switch (compassDirection)
                {
                    case CompassDirections.North:
                        return "N";
                    case CompassDirections.NorthEast:
                        return "NE";
                    case CompassDirections.East:
                        return "E";
                    case CompassDirections.SouthEast:
                        return "SE";
                    case CompassDirections.South:
                        return "S";
                    case CompassDirections.SouthWest:
                        return "SW";
                    case CompassDirections.West:
                        return "W";
                    case CompassDirections.NorthWest:
                        return "NW";
                }
            }

            return "";
        }

        /// <summary>
        /// Converts direction indicator to compass direction.
        /// Not required by the application, so it is not implemented.
        /// </summary>
        /// <param name="value">The value produced by the binding source.</param>
        /// <param name="targetType">The type of the binding target property.</param>
        /// <param name="parameter">The converter parameter to use.</param>
        /// <param name="culture">The culture to use in the converter.</param>
        /// <returns>Converted value.</returns>
        public object ConvertBack(object value, Type targetType, object parameter, CultureInfo culture)
        {
            throw new NotImplementedException();
        }

        #endregion
    }
}

```

Step 5: Go back to _CompassPage.xaml._ We need to add the newly created converter to our resources.

<highlight>5, 14-19</highlight>

```xml
<?xml version="1.0" encoding="utf-8" ?>
<ContentPage xmlns="http://xamarin.com/schemas/2014/forms"
             xmlns:x="http://schemas.microsoft.com/winfx/2009/xaml"
             x:Class="Compass.Tizen.Wearable.Views.CompassPage"
             xmlns:converters="clr-namespace:Compass.Converters;assembly=Compass"
             xmlns:viewModels="clr-namespace:Compass.ViewModels;assembly=Compass"
             BackgroundImage="compass_background_w.png"
             x:Name="Root">

    <ContentPage.BindingContext>
        <viewModels:CompassViewModel x:Name="CompassViewModel" />
    </ContentPage.BindingContext>

    <ContentPage.Resources>
        <ResourceDictionary>
            <converters:CompassDirectionToDirectionIndicatorConverter x:Key="CompassDirectionToDirectionIndicator" />
        </ResourceDictionary>
    </ContentPage.Resources>

    <ContentPage.Content>
        <AbsoluteLayout>

```

Step 5: Bind the _CompassDirection_ property using our converter.

<highlight>16</highlight>

```xml
    <ContentPage.Content>
        <AbsoluteLayout>
            <Image AbsoluteLayout.LayoutBounds="20, 20, 320, 320"
                   Source="compass_rotation_w.png" />
            <Image AbsoluteLayout.LayoutBounds="15, 15, 330, 330"
                   Source="compass_counter_w.png" />
            <Label AbsoluteLayout.LayoutBounds="15, 0, 330, 330"
                   HorizontalTextAlignment="Center"
                   VerticalTextAlignment="Center"
                   Text="{Binding CompassDeviation, StringFormat='{0:F0}°'}"
                   TextColor="White"
                   FontAttributes="Bold" />
            <Label AbsoluteLayout.LayoutBounds="15, 35, 330, 330"
                   HorizontalTextAlignment="Center"
                   VerticalTextAlignment="Center"
                   Text="{Binding CompassDirection, Converter={StaticResource CompassDirectionToDirectionIndicator}}"
                   TextColor="White"
                   FontSize="12"
                   FontAttributes="Bold" />
            <Image AbsoluteLayout.LayoutBounds="20, 20, 320, 320"
                   Source="compass_cover_w.png" />
        </AbsoluteLayout>
    </ContentPage.Content>

```

When we compile the code, we will see that the values indicated by the compass change but the compass rose remains motionless - we will take care of it in the next section.

<img src="/assets/images/tutorials/105/Compass_4_2_UI_binding.png" style="height:360px; width:360px"/>

## 4. Animating compass rose

Compass rose animation is the last missing element in our application. We will implement it with use of a Xamarin Forms' Behavior class.

Step 1: Right-click on the _Compass_  project, add a new _Behaviors_ folder and a  _CompassRoseBehavior.cs_ class inside.

Step 2: We want to animate a compass rose, which in our application is represented by an image, so a newly created  _CompassRoseBehavior_ class should inherit from _Behavior<Image>_ class. It should also have an _Image_ type field to store an instance of an object to which it is attached.

<highlight>1-2,5-9,11-18</highlight>

```csharp
using Xamarin.Forms;

namespace Compass.Behaviors
{
    /// <summary>
    /// Image behavior class that animates compass rose rotation.
    /// </summary>
    /// <remarks>This behavior must be connected to one image per instance.</remarks>
    public class CompassRoseBehavior : Behavior<Image>
    {
        #region fields

        /// <summary>
        /// Image the behavior is connected to.
        /// </summary>
        private Image _image;

        #endregion
    }
}

```

Step 3: Create a  _CompassDeviation_ property, as well as a **bindable property** - CompassDeviationProperty, which will allow to obtain the compass deviation. We want the rose animation to take place whenever the compass deviation changes, so we create a  _CompassDeviationPropertyChanged()_ method.

<highlight>19-52</highlight>

```csharp
using Xamarin.Forms;

namespace Compass.Behaviors
{
    /// <summary>
    /// Image behavior class that animates compass rose rotation.
    /// </summary>
    /// <remarks>This behavior must be connected to one image per instance.</remarks>
    public class CompassRoseBehavior : Behavior<Image>
    {
        #region fields

        /// <summary>
        /// Image the behavior is connected to.
        /// </summary>
        private Image _image;

        #endregion

        #region properties

        /// <summary>
        /// Bindable property that allows to obtain compass deviation.
        /// </summary>
        public static readonly BindableProperty CompassDeviationProperty =
            BindableProperty.Create(nameof(CompassDeviation), typeof(float), typeof(CompassRoseBehavior),
                default(float), propertyChanged: CompassDeviationPropertyChanged);

        /// <summary>
        /// Compass deviation.
        /// </summary>
        public float CompassDeviation
        {
            get => (float)GetValue(CompassDeviationProperty);
            set => SetValue(CompassDeviationProperty, value);
        }

        #endregion

        #region methods

        /// <summary>
        /// Called whenever compass deviation is changed.
        /// </summary>
        /// <param name="sender">Object which sent the event.</param>
        /// <param name="oldValue">Previous compass deviation.</param>
        /// <param name="newValue">New compass deviation.</param>
        public static void CompassDeviationPropertyChanged(object sender, object oldValue, object newValue)
        {
        }

        #endregion
    }
}

```

Step 4: Storing the instance of the object to which we attach the behavior, is handled by overriding functions _OnAttachedTo() and_   _OnDetachingFrom()._

<highlight>11-30</highlight>

```csharp
        /// <summary>
        /// Called whenever compass deviation is changed.
        /// </summary>
        /// <param name="sender">Object which sent the event.</param>
        /// <param name="oldValue">Previous compass deviation.</param>
        /// <param name="newValue">New compass deviation.</param>
        public static void CompassDeviationPropertyChanged(object sender, object oldValue, object newValue)
        {
        }

        /// <summary>
        /// Called when behavior is attached to the image.
        /// </summary>
        /// <param name="image">Object to attach behavior to.</param>
        protected override void OnAttachedTo(Image image)
        {
            base.OnAttachedTo(image);
            _image = image;
        }

        /// <summary>
        /// Called when behavior is detached from the image.
        /// </summary>
        /// <param name="image">Object to detach behavior from.</param>
        protected override void OnDetachingFrom(Image image)
        {
            base.OnDetachingFrom(image);
            _image = null;
        }

        #endregion

```

Step 5: Implement a  _RotateCompassRose()_ method that will rotate the attached image. Then call it in the _CompassDeviationPropertyChanged()_ method.

<highlight>9,12-25</highlight>

```csharp
        /// <summary>
        /// Called whenever compass deviation is changed.
        /// </summary>
        /// <param name="sender">Object which sent the event.</param>
        /// <param name="oldValue">Previous compass deviation.</param>
        /// <param name="newValue">New compass deviation.</param>
        public static void CompassDeviationPropertyChanged(object sender, object oldValue, object newValue)
        {
            ((CompassRoseBehavior)sender).RotateCompassRose((float)oldValue, (float)newValue);
        }

        /// <summary>
        /// Animates the image rotation.
        /// </summary>
        /// <param name="oldDeviation">Previous compass deviation.</param>
        /// <param name="newDeviation">New compass deviation.</param>
        public void RotateCompassRose(float oldDeviation, float newDeviation)
        {
            if (_image != null)
            {
                new Animation(v => _image.Rotation = v, -oldDeviation, -newDeviation)
                    .Commit(_image, "CompassAnimation", 16, 500, Easing.Linear, null, () => false);
            }
        }

        /// <summary>
        /// Called when behavior is attached to the image.
        /// </summary>
        /// <param name="image">Object to attach behavior to.</param>
        protected override void OnAttachedTo(Image image)
        {
            base.OnAttachedTo(image);
            _image = image;
        }

```

Step 6: We have to attach the created behavior to the compass rose image. To do this, modify _CompassPage.xaml._

<highlight>7,23-29</highlight>

```xml
<?xml version="1.0" encoding="utf-8" ?>
<ContentPage xmlns="http://xamarin.com/schemas/2014/forms"
             xmlns:x="http://schemas.microsoft.com/winfx/2009/xaml"
             x:Class="Compass.Tizen.Wearable.Views.CompassPage"
             xmlns:converters="clr-namespace:Compass.Converters;assembly=Compass"
             xmlns:viewModels="clr-namespace:Compass.ViewModels;assembly=Compass"
             xmlns:behaviors="clr-namespace:Compass.Behaviors;assembly=Compass"
             BackgroundImage="compass_background_w.png"
             x:Name="Root">

    <ContentPage.BindingContext>
        <viewModels:CompassViewModel x:Name="CompassViewModel" />
    </ContentPage.BindingContext>

    <ContentPage.Resources>
        <ResourceDictionary>
            <converters:CompassDirectionToDirectionIndicatorConverter x:Key="CompassDirectionToDirectionIndicator" />
        </ResourceDictionary>
    </ContentPage.Resources>

    <ContentPage.Content>
        <AbsoluteLayout>
            <Image AbsoluteLayout.LayoutBounds="20, 20, 320, 320"
                   Source="compass_rotation_w.png">
                <Image.Behaviors>
                    <behaviors:CompassRoseBehavior CompassDeviation="{Binding Source={x:Reference Root},
                                                       Path=BindingContext.CompassDeviation}" />
                </Image.Behaviors>
            </Image>
            <Image AbsoluteLayout.LayoutBounds="15, 15, 330, 330"
                   Source="compass_counter_w.png" />
            <Label AbsoluteLayout.LayoutBounds="15, 0, 330, 330"
                   HorizontalTextAlignment="Center"
                   VerticalTextAlignment="Center"
                   Text="{Binding CompassDeviation, StringFormat='{0:F0}°'}"
                   TextColor="White"
                   FontAttributes="Bold" />
            <Label AbsoluteLayout.LayoutBounds="15, 35, 330, 330"
                   HorizontalTextAlignment="Center"
                   VerticalTextAlignment="Center"
                   Text="{Binding CompassDirection, Converter={StaticResource CompassDirectionToDirectionIndicator}}"
                   TextColor="White"
                   FontSize="12"
                   FontAttributes="Bold" />
            <Image AbsoluteLayout.LayoutBounds="20, 20, 320, 320"
                   Source="compass_cover_w.png" />
        </AbsoluteLayout>
    </ContentPage.Content>
</ContentPage>

```

The final effect:

<img src="/assets/images/tutorials/105/Compass_Wearable_general_screen.png" style="height:360px; width:360px"/>

# III. TESTING

## 1. Orientation sensor in Control Panel

Our application is now functionally ready. In order to check if it works properly, we have to test it. The emulator allows you to simulate the position of the device.

Step 1: Right-click on the emulator screen and choose Control Panel from the menu.

<img src="/assets/images/tutorials/105/Compass_5_1_Testing_ControlPanelStart.png" style="height:582px; width:458px"/>

Step 2: Among the available options, find the Sensor and click it.

<img src="/assets/images/tutorials/105/Compass_5_2_Testing_ControlPanelSensor.png" style="height:600px; width:557px"/>

Step 3: A window opens with options for simulating the position. As its values change, the readings visible in the application should also change.

<img src="/assets/images/tutorials/105/Compass_5_3_Testing_InitialSetUp.png" style="height:600px; width:554px"/>

Simulating different positions of the device we should get different readings from the sensor, and the compass rose should rotate according to the displayed data. Below are some examples of states:

<img src="/assets/images/tutorials/105/Compass_5_9_Testing_Results.png" style="height:410px; width:700px"/>

Your application should behave identically.

## 2. Results

Congratulations!

This is the end of this tutorial. You have finished the **Compass** application which uses **OrientationSensor API** and has been built according to **MVVM** guidelines.

<img src="/assets/images/tutorials/105/Compass_5_11_SumUp.png" style="height:231px; width:700px"/>
