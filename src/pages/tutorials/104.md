---
layout: ../../layouts/tutorial/TextTutorial.astro
title: 'How to Create "MetalDetector" App'
description: "This tutorial shows obtaining and example usage of the magnetometer sensor data provided by the Tizen.Sensor API."
created: "2018/03/26"
modified: "2018/10/06"
profile: ["wearable"]
type: "dotnet"
level: 2
state: "open"
thumbnail: "/assets/images/tutorials/104/MetalDetector.png"
---

#

# I. INTRODUCTION

## 1. Overview

In this tutorial, we will create a MetalDetector application which uses Sensor API to obtain the magnetometer sensor data in order to present it on the screen.



First, take a look at the final version of the application.

The application’s UI consists of one page, which contains six image layers.

<img src="/assets/images/tutorials/104/main-page-layers.png" style="height:1052px; width:680px"/>

All images together with additional two text labels create a view, that allows the application to indicate the magnetometer sensor detection.

<img src="/assets/images/tutorials/104/metal-detector-1-1-1.PNG" style="height:544px; width:400px"/>

The application's UI has been designed in the shape of radar. To simulate radar work, one of the images rotates continuously. Two other images are rotated by a certain angle so as to indicate the direction corresponding to the data received from the magnetometer sensor. The source file of one of them varies depending on the signal strength calculated based on the sensor data, so that the signal strength changes are always visible on the screen. In addition, the signal strength value is displayed in the label placed centrally in the application screen, in microtesla units.



Content of this tutorial is under [Apache 2.0](http://www.apache.org/licenses/LICENSE-2.0) license.

## 2. Importing and building solution

In this step, we will import and build Visual Studio solution containing the initial application code.



Step 1: Download and unpack [metal-detector.zip](https://s3-us-west-1.amazonaws.com/tizenschool/104/metal-detector.zip) file.



Step 2: Click File > Open > Project/Solution...
<img src="/assets/images/tutorials/104/metal-detector-import-1.png" style="height:851px; width:1231px"/>



Step 3: Go to downloaded directory and select MetalDetector.sln file (Microsoft Visual Studio Solution), then click the "Open" button.

<img src="/assets/images/tutorials/104/metal-detector-import-2.png" style="undefined"/>

The solution structure should appear in the Solution Explorer view. It should contain two projects: MetalDetector and MetalDetector.Tizen.Wearable.

<img src="/assets/images/tutorials/104/metal-detector-import-3.png" style="undefined"/>



Step 4: Right click on the solution and select "Restore NuGet Packages" from the context menu. This will set up NuGet packages for all projects.

<img src="/assets/images/tutorials/104/metal-detector-import-4.png" style="undefined"/>



Step 5: Right click on the solution again and select "Clean Solution" from the context menu.

<img src="/assets/images/tutorials/104/metal-detector-import-5.png" style="undefined"/>



Step 6: Right click on the solution again and select "Rebuild Solution" from the context menu.

<img src="/assets/images/tutorials/104/metal-detector-import-6.png" style="undefined"/>



Step 7: Right click on the "MetalDetector.Tizen.Wearable" project and select "Set as StartUp Project" from the context menu.

<img src="/assets/images/tutorials/104/metal-detector-import-7.png" style="undefined"/>

Right now, the application can be run on the emulator or target device. We will start with the base version of the application. The application displays "black screen" and nothing more happens. But don't worry, we will implement all application's features in the next steps.

<img src="/assets/images/tutorials/104/metal-detector-1-2-1.PNG" style="height:544px; width:400px"/>

# II. APPLICATION UI

## 1. Goal

The goal of this tutorial's part is to create the application's UI designed in the shape of radar, as it is described in the Introduction > Overview chapter.

At the end of this chapter, the application's UI should contain all elements, which are necessary to indicate the magnetometer sensor detection.

<img src="/assets/images/tutorials/104/metal-detector-2-1-1_before.PNG" style="height:544px; width:400px"/>
        
<img src="/assets/images/tutorials/104/metal-detector-2-1-1_after.PNG" style="height:544px; width:400px"/>

The obtained layout of elements will be static. The following chapters will provide information on what to do to revive the application screen.

So, let's begin.

## 2. MainPage layout

We will modify MetalDetector/MetalDetectorApp.xaml and MetalDetector/Views/MainPage.xaml files of the project.



Step 1: Extend the MetalDetector/MetalDetectorApp class with MainPage definition. From now, the MetalDetector/Views/MainPage class will be treated as the application main page.

<highlight>4, 6-9</highlight>

```xml
<?xml version="1.0" encoding="utf-8" ?>
<Application xmlns="http://xamarin.com/schemas/2014/forms"
             xmlns:x="http://schemas.microsoft.com/winfx/2009/xaml"
             xmlns:views="clr-namespace:MetalDetector.Views"
             x:Class="MetalDetector.MetalDetectorApp">

    <Application.MainPage>
        <views:MainPage />
    </Application.MainPage>
</Application>

```



Step 2: In the MetalDetector/Views/MainPage.xaml file create AbsoluteLayout element inside the Content of the ContentPage, which fills the entire application screen.

<highlight>6-10</highlight>

```xml
<?xml version="1.0" encoding="utf-8" ?>
<ContentPage xmlns="http://xamarin.com/schemas/2014/forms"
             xmlns:x="http://schemas.microsoft.com/winfx/2009/xaml"
             x:Class="MetalDetector.Views.MainPage">

    <ContentPage.Content>
        <AbsoluteLayout VerticalOptions="FillAndExpand"
                        HorizontalOptions="FillAndExpand">
        </AbsoluteLayout>
    </ContentPage.Content>
</ContentPage>

```

In all other steps of this page we will make changes to the MetalDetector/Views/MainPage.xaml file.



Step 3: Create Image element responsible for providing the application background. This element is positioned absolutely so that it fills the entire application screen.

<highlight>4-7</highlight>

```xml
<ContentPage.Content>
    <AbsoluteLayout VerticalOptions="FillAndExpand"
                    HorizontalOptions="FillAndExpand">

        <Image AbsoluteLayout.LayoutFlags="All"
               AbsoluteLayout.LayoutBounds="0, 0, 1, 1"
               Source="background.png" />
    </AbsoluteLayout>
</ContentPage.Content>

```

<img src="/assets/images/tutorials/104/metal-detector-2-2-1.PNG" style="height:544px; width:400px"/>



Step 4: Create Image element responsible for displaying the application screen frame. This element is positioned absolutely so that it fills the entire application screen.

<highlight>8-11</highlight>

```xml
<ContentPage.Content>
    <AbsoluteLayout VerticalOptions="FillAndExpand"
                    HorizontalOptions="FillAndExpand">

        <Image AbsoluteLayout.LayoutFlags="All"
               AbsoluteLayout.LayoutBounds="0, 0, 1, 1"
               Source="background.png" />

        <Image AbsoluteLayout.LayoutFlags="All"
               AbsoluteLayout.LayoutBounds="0, 0, 1, 1"
               Source="frame.png" />
    </AbsoluteLayout>
</ContentPage.Content>

```

<img src="/assets/images/tutorials/104/metal-detector-2-2-2.PNG" style="height:544px; width:400px"/>



Step 5: Create AbsoluteLayout element, which will group the rest of the UI elements, in order to display them only when the metal detector is ready to use. At this stage of development the AbsoluteLayout element will be visible. Conditional hiding will be implemented later.

<highlight>4-7</highlight>

```xml
<Image AbsoluteLayout.LayoutFlags="All"
       AbsoluteLayout.LayoutBounds="0, 0, 1, 1"
       Source="background.png" />

<AbsoluteLayout AbsoluteLayout.LayoutFlags="All"
                AbsoluteLayout.LayoutBounds="0, 0, 1, 1">
</AbsoluteLayout>

<Image AbsoluteLayout.LayoutFlags="All"
       AbsoluteLayout.LayoutBounds="0, 0, 1, 1"
       Source="frame.png" />

```



Step 6: Create Image element responsible for displaying the signal strength indicator. This element is positioned absolutely so that it fills the entire application screen. The source of the image will be changed later via binding, in order to display image corresponding to the current signal strength.

<highlight>7-10</highlight>

```xml
<Image AbsoluteLayout.LayoutFlags="All"
       AbsoluteLayout.LayoutBounds="0, 0, 1, 1"
       Source="background.png" />

<AbsoluteLayout AbsoluteLayout.LayoutFlags="All"
                AbsoluteLayout.LayoutBounds="0, 0, 1, 1">

    <Image AbsoluteLayout.LayoutFlags="All"
           AbsoluteLayout.LayoutBounds="0, 0, 1, 1"
           Source="signal_strength_0.png" />
</AbsoluteLayout>

<Image AbsoluteLayout.LayoutFlags="All"
       AbsoluteLayout.LayoutBounds="0, 0, 1, 1"
       Source="frame.png" />

```

<img src="/assets/images/tutorials/104/metal-detector-2-2-3.PNG" style="height:544px; width:400px"/>



Step 7: Create Image element responsible for displaying texts indicating medium and high level of the signal strength value. This element is positioned absolutely so that it fills the entire application screen.

<highlight>7-10</highlight>

```xml
<AbsoluteLayout AbsoluteLayout.LayoutFlags="All"
                AbsoluteLayout.LayoutBounds="0, 0, 1, 1">

    <Image AbsoluteLayout.LayoutFlags="All"
           AbsoluteLayout.LayoutBounds="0, 0, 1, 1"
           Source="signal_strength_0.png" />

    <Image AbsoluteLayout.LayoutFlags="All"
           AbsoluteLayout.LayoutBounds="0, 0, 1, 1"
           Source="text.png" />
</AbsoluteLayout>

```

<img src="/assets/images/tutorials/104/metal-detector-2-2-4.PNG" style="height:544px; width:400px"/>



Step 8: Create Image element responsible for radar work simulation. This element is positioned absolutely so that it fills the entire application screen. Continuous rotation of this element will be implemented later.

<highlight>4-7</highlight>

```xml
    <Image AbsoluteLayout.LayoutFlags="All"
           AbsoluteLayout.LayoutBounds="0, 0, 1, 1"
           Source="text.png" />

    <Image AbsoluteLayout.LayoutFlags="All"
           AbsoluteLayout.LayoutBounds="0, 0, 1, 1"
           Source="radar.png" />
</AbsoluteLayout>

```

<img src="/assets/images/tutorials/104/metal-detector-2-2-5.PNG" style="height:544px; width:400px"/>



Step 9: Create Image element responsible for indicating the direction from which the detection took place. This element is positioned absolutely so that it fills the entire application screen. Rotation of the image will be changed later via binding.

<highlight>4-7</highlight>

```xml
    <Image AbsoluteLayout.LayoutFlags="All"
           AbsoluteLayout.LayoutBounds="0, 0, 1, 1"
           Source="radar.png" />

    <Image AbsoluteLayout.LayoutFlags="All"
           AbsoluteLayout.LayoutBounds="0, 0, 1, 1"
           Source="signal_direction_indicator_on.png" />
</AbsoluteLayout>

```

<img src="/assets/images/tutorials/104/metal-detector-2-2-6.PNG" style="height:544px; width:400px"/>



Step 10: Create StackLayout elements containing Label elements responsible for displaying signal strength value. These elements are positioned absolutely so that they are located in the middle of the application screen.

<highlight>4-19</highlight>

```xml
    <Image AbsoluteLayout.LayoutFlags="All"
           AbsoluteLayout.LayoutBounds="0, 0, 1, 1"
           Source="signal_direction_indicator_on.png" />

    <StackLayout AbsoluteLayout.LayoutBounds="0, 154, 360, AutoSize"
                 HorizontalOptions="FillAndExpand">
        <Label FontSize="10"
               HorizontalOptions="Center"
               Text="0"
               TextColor="White" />
    </StackLayout>

    <StackLayout AbsoluteLayout.LayoutBounds="0, 186, 360, AutoSize"
                 HorizontalOptions="FillAndExpand">
        <Label FontSize="7"
               HorizontalOptions="Center"
               Text="µT"
               TextColor="White" />
    </StackLayout>
</AbsoluteLayout>

```

<img src="/assets/images/tutorials/104/metal-detector-2-2-7.PNG" style="height:544px; width:400px"/>

# III. RADAR ANIMATION

## 1. Goal

The goal of this tutorial's part is to start animation giving the radar effect. The application should start the animation and make it visible only when the metal detector is ready to use.



So, let's begin.

## 2. Implementing magnetometer service interface

We have to implement  **MagnetometerService**  class, which allows the application to obtain magnetometer data using the Tizen Sensor API.

For now, we need to know whether the magnetometer sensor is supported. If it is, the application will start it.



We will modify the MetalDetector.Tizen.Wearable/Service/MagnetometerService.cs file of the project.



Step 1: Create private \_magnetometer field, which will store an instance of the Magnetometer class provided by the Tizen Sensor API.

<highlight>3, 13-22</highlight>

```csharp
using MetalDetector.Models;
using MetalDetector.Tizen.Wearable.Service;
using Tizen.Sensor;

[assembly: Xamarin.Forms.Dependency(typeof(MagnetometerService))]
namespace MetalDetector.Tizen.Wearable.Service
{
    /// <summary>
    /// Magnetometer service which allows obtaining the magnetometer data.
    /// </summary>
    class MagnetometerService : IMagnetometerService
    {
        #region fields

        /// <summary>
        /// Magnetometer class instance used for registering callbacks for the magnetometer
        /// and getting the magnetometer data.
        /// </summary>
        private Magnetometer _magnetometer;

        #endregion

        #region methods

        /// <summary>
        /// MagnetometerService class constructor.
        /// </summary>
        public MagnetometerService()
        {
        }

        #endregion
    }
}

```



Step 2: Create an instance of the Magnetometer class in the constructor.

<highlight>8</highlight>

```csharp
#region methods

/// <summary>
/// MagnetometerService class constructor.
/// </summary>
public MagnetometerService()
{
    _magnetometer = new Magnetometer();
}

#endregion

```



Step 3: Create public IsSupported method, which will return a flag indicating whether magnetometer is supported or not.

<highlight>10-18</highlight>

```csharp
#region methods

/// <summary>
/// MagnetometerService class constructor.
/// </summary>
public MagnetometerService()
{
    _magnetometer = new Magnetometer();
}

/// <summary>
/// Returns true if the magnetometer is supported, false otherwise.
/// </summary>
/// <returns>Flag indicating whether magnetometer is supported or not.</returns>
public bool IsSupported()
{
    return Magnetometer.IsSupported;
}

#endregion

```



Step 4: Create public Start method which starts the magnetometer sensor.

<highlight>8-25</highlight>

```csharp
/// <summary>
/// MagnetometerService class constructor.
/// </summary>
public MagnetometerService()
{
    _magnetometer = new Magnetometer();
}

/// <summary>
/// Starts the magnetometer sensor.
/// </summary>
public void Start()
{
    if (!IsSupported())
    {
        return;
    }

    if (_magnetometer.IsSensing)
    {
        return;
    }

    _magnetometer.Start();
}

/// <summary>
/// Returns true if the magnetometer is supported, false otherwise.
/// </summary>
/// <returns>Flag indicating whether magnetometer is supported or not.</returns>
public bool IsSupported()
{
    return Magnetometer.IsSupported;
}

```



Step 5: Create public Stop method, which stops the magnetometer sensor.

<highlight>18-33</highlight>

```csharp
/// <summary>
/// Starts the magnetometer sensor.
/// </summary>
public void Start()
{
    if (!IsSupported())
    {
        return;
    }

    if (_magnetometer.IsSensing)
    {
        return;
    }

    _magnetometer.Start();
}

/// <summary>
/// Stops the magnetometer sensor.
/// </summary>
public void Stop()
{
    if (!IsSupported())
    {
        return;
    }

    if (_magnetometer.IsSensing)
    {
        _magnetometer.Stop();
    }
}

/// <summary>
/// Returns true if the magnetometer is supported, false otherwise.
/// </summary>
/// <returns>Flag indicating whether magnetometer is supported or not.</returns>
public bool IsSupported()
{
    return Magnetometer.IsSupported;
}

```



## 3. Implementing magnetometer service

We have to implement **IMagnetometerService**  interface, in the portable part of the application, which can be implemented on different platforms.

At this development step, we need a service, which provides  **IsSupported** , **Start** and **Stop** methods. In the next subchapter we will implement them in the platform's specific part of the application.



Now, we will modify the MetalDetector/Models/IMagnetometerService.cs file of the project.



Step 1: Define three methods mentioned above.

<highlight>8-26</highlight>

```csharp
namespace MetalDetector.Models
{
    /// <summary>
    /// Interface of magnetometer service which allows obtaining the magnetometer data.
    /// </summary>
    public interface IMagnetometerService
    {
        #region methods

        /// <summary>
        /// Returns true if the magnetometer is supported, false otherwise.
        /// </summary>
        /// <returns>Flag indicating whether magnetometer is supported or not.</returns>
        bool IsSupported();

        /// <summary>
        /// Starts magnetometer sensor.
        /// </summary>
        void Start();

        /// <summary>
        /// Stops magnetometer sensor.
        /// </summary>
        void Stop();

        #endregion
    }
}

```

## 4. Implementing metal detector model

We have to implement  **MetalDetectorModel**  class, which allows the application to use properties describing metal detector state, as well as to execute provided methods.

For now, it should provide **IsSupported** , **Start** and **Stop** methods, which are needed to achieve the goal of this tutorial's part.



We will modify the MetalDetector/Models/MetalDetectorModel.cs file of the project.



Step 1: Create private \_iMagnetometerService field, which will store an instance of the class implementing IMagnetometerService service.

<highlight>9-17</highlight>

```csharp
namespace MetalDetector.Models
{
    /// <summary>
    /// Class defining metal detector model which allows the application to use properties
    /// describing metal detector state.
    /// </summary>
    public class MetalDetectorModel
    {
        #region fields

        /// <summary>
        /// Magnometer service which allows obtaining the magnetometer data.
        /// </summary>
        private IMagnetometerService _iMagnetometerService;

        #endregion

        #region methods

        /// <summary>
        /// MagnetometerModel class constructor.
        /// Initializes the model.
        /// </summary>
        public MetalDetectorModel()
        {
        }

        #endregion
    }
}

```



Step 2: Create an instance of the class implementing the IMagnetometerService interface.

<highlight>1, 28</highlight>

```csharp
using Xamarin.Forms;

namespace MetalDetector.Models
{
    /// <summary>
    /// Class defining metal detector model which allows the application to use properties
    /// describing metal detector state.
    /// </summary>
    public class MetalDetectorModel
    {
        #region fields

        /// <summary>
        /// Magnometer service which allows obtaining the magnetometer data.
        /// </summary>
        private IMagnetometerService _iMagnetometerService;

        #endregion

        #region methods

        /// <summary>
        /// MagnetometerModel class constructor.
        /// Initializes the model.
        /// </summary>
        public MetalDetectorModel()
        {
            _iMagnetometerService = DependencyService.Get<IMagnetometerService>();
        }

        #endregion
    }
}

```



Step 3: Create IsSupported method returning true, if the metal detector is supported.

<highlight>9-17</highlight>

```csharp
/// <summary>
/// MagnetometerModel class constructor.
/// Initializes the model.
/// </summary>
public MetalDetectorModel()
{
    _iMagnetometerService = DependencyService.Get<IMagnetometerService>();
}

/// <summary>
/// Returns true if the metal detector is supported, false otherwise.
/// </summary>
/// <returns>Flag indicating whether metal detector is supported or not.</returns>
public bool IsSupported()
{
    return _iMagnetometerService.IsSupported();
}

#endregion

```



Step 4: Create Start method which starts the metal detector.

<highlight>9-16</highlight>

```csharp
/// <summary>
/// MagnetometerModel class constructor.
/// Initializes the model.
/// </summary>
public MetalDetectorModel()
{
    _iMagnetometerService = DependencyService.Get<IMagnetometerService>();
}

/// <summary>
/// Starts metal detector.
/// </summary>
public void Start()
{
    _iMagnetometerService.Start();
}

/// <summary>
/// Returns true if the metal detector is supported, false otherwise.
/// </summary>
/// <returns>Flag indicating whether metal detector is supported or not.</returns>
public bool IsSupported()
{
    return _iMagnetometerService.IsSupported();
}

```



Step 5: Create Stop method which stops the metal detector.

<highlight>8-15</highlight>

```csharp
/// <summary>
/// Starts metal detector.
/// </summary>
public void Start()
{
    _iMagnetometerService.Start();
}

/// <summary>
/// Stops metal detector.
/// </summary>
public void Stop()
{
    _iMagnetometerService.Stop();
}

/// <summary>
/// Returns true if the metal detector is supported, false otherwise.
/// </summary>
/// <returns>Flag indicating whether metal detector is supported or not.</returns>
public bool IsSupported()
{
    return _iMagnetometerService.IsSupported();
}

```

## 5. Implementing main view model

We have to implement  **MainViewModel**  class, which provides abstraction of the view exposing public properties and commands.



We will modify the MetalDetector/ViewModels/MainViewModel.cs file of the project.



Step 1: Create private \_metalDetectorModel field, which will store an instance of the MetalDetector class, describing metal detector state and providing methods to manipulate its state.

<highlight>1, 11-19</highlight>

```csharp
using MetalDetector.Models;

namespace MetalDetector.ViewModels
{
    /// <summary>
    /// Main view model class for the application.
    /// Encapsulates presentation logic and state of the application.
    /// </summary>
    public class MainViewModel : ViewModelBase
    {
        #region fields

        /// <summary>
        /// Metal detector model which allows the application to use the metal detector data.
        /// </summary>
        private MetalDetectorModel _metalDetectorModel;

        #endregion

        #region methods

        /// <summary>
        /// MainViewModel class constructor.
        /// Initializes the view model.
        /// </summary>
        public MainViewModel()
        {
        }

        #endregion
    }
}

```



Step 2: Create an instance of the MetalDetectorModel class.

<highlight>7</highlight>

```csharp
/// <summary>
/// MainViewModel class constructor.
/// Initializes the view model.
/// </summary>
public MainViewModel()
{
    _metalDetectorModel = new MetalDetectorModel();
}

```



Step 3: Create StartCommand and StopCommand, which will be executed from the view layer to have control over whether the metal detector is started or not.

<highlight>1-2, 21-34, 46, 48-75</highlight>

```csharp
using MetalDetector.Models;
using System.Windows.Input;
using Xamarin.Forms;

namespace MetalDetector.ViewModels
{
    /// <summary>
    /// Main view model class for the application.
    /// Encapsulates presentation logic and state of the application.
    /// </summary>
    public class MainViewModel : ViewModelBase
    {
        #region fields

        /// <summary>
        /// Metal detector model which allows the application to use the metal detector data.
        /// </summary>
        private MetalDetectorModel _metalDetectorModel;

        #endregion

        #region properties

        /// <summary>
        /// Command which starts the metal detector.
        /// </summary>
        public ICommand StartCommand { get; private set; }

        /// <summary>
        /// Command which stops the metal detector.
        /// </summary>
        public ICommand StopCommand { get; private set; }

        #endregion

        #region methods

        /// <summary>
        /// MainViewModel class constructor.
        /// Initializes the view model.
        /// </summary>
        public MainViewModel()
        {
            _metalDetectorModel = new MetalDetectorModel();

            InitCommands();
        }

        /// <summary>
        /// Initializes view model's commands.
        /// </summary>
        private void InitCommands()
        {
            StartCommand = new Command(ExecuteStart);
            StopCommand = new Command(ExecuteStop);
        }

        /// <summary>
        /// Starts the metal detector.
        /// </summary>
        private void ExecuteStart()
        {
            if (_metalDetectorModel.IsSupported())
            {
                _metalDetectorModel.Start();
            }
        }

        /// <summary>
        /// Stops the metal detector.
        /// </summary>
        private void ExecuteStop()
        {
            _metalDetectorModel.Stop();
        }

        #endregion
    }
}

```



Step 4: Create \_ready backing field of the Ready property, which will indicate if the metal detector is ready.

<highlight>2-6</highlight>

```csharp
#region fields

/// <summary>
/// Backing field of the Ready property.
/// </summary>
private bool _ready = false;

/// <summary>
/// Metal detector model which allows the application to use the metal detector data.
/// </summary>
private MetalDetectorModel _metalDetectorModel;

```



Step 5: Create Ready property, which uses private backing field we have already created.

<highlight>5-13</highlight>

```csharp
/// <summary>
/// Command which stops metal detector.
/// </summary>
public ICommand StopCommand { get; private set; }

/// <summary>
/// Indicates if the metal detector is ready.
/// </summary>
public bool Ready
{
    private set => SetProperty(ref _ready, value);
    get => _ready;
}

#endregion

```



Step 6: Set the Ready property to true when the Start command is executed.

<highlight>9</highlight>

```csharp
/// <summary>
/// Starts the metal detector.
/// </summary>
private void ExecuteStart()
{
    if (_metalDetectorModel.IsSupported())
    {
        _metalDetectorModel.Start();
        Ready = true;
    }
}

```



## 6. Implementing view

We have to implement **MainPage**  class by defining the animation of radar image. This animation will be launched when the metal detector model is ready to use. We also have to extend the MetalDetector/MetalDetectorApp class with binding context definition. From now, the MainViewModel class will be available for all application's visual elements.



We will modify MetalDetector/Views/MainPage.xaml, MetalDetector/Views/MainPage.xaml.cs and MetalDetector/MetalDetectorApp.xaml files of the project.



Step 1: In the MetalDetector/MetalDetectorApp.xaml define the BindingContext of the Application element.

<highlight>5, 11-14</highlight>

```xml
<?xml version="1.0" encoding="utf-8" ?>
<Application xmlns="http://xamarin.com/schemas/2014/forms"
             xmlns:x="http://schemas.microsoft.com/winfx/2009/xaml"
             xmlns:views="clr-namespace:MetalDetector.Views"
             xmlns:viewModels="clr-namespace:MetalDetector.ViewModels"
             x:Class="MetalDetector.MetalDetectorApp">

    <Application.MainPage>
        <views:MainPage />
    </Application.MainPage>

    <Application.BindingContext>
        <viewModels:MainViewModel />
    </Application.BindingContext>
</Application

```



Step 2: In the MetalDetector/Views/MainPage.xaml define x:Name property of the radar Image element, in order to reference it from the code behind.

<highlight>1</highlight>

```xml
<Image x:Name="radar"
       AbsoluteLayout.LayoutFlags="All"
       AbsoluteLayout.LayoutBounds="0, 0, 1, 1"
       Source="radar.png" />

```

In the next steps of this page we will modify the MetalDetector/Views/MainPage.xaml.cs file.



Step 3: Create a private field being a reference to the object of the Animation class.

<highlight>13-22</highlight>

```csharp
using Xamarin.Forms;
using Xamarin.Forms.Xaml;

namespace MetalDetector.Views
{
    /// <summary>
    /// Main (and only one) page of the application.
    /// Handles UI logic for the application.
    /// </summary>
    [XamlCompilation(XamlCompilationOptions.Compile)]
    public partial class MainPage : ContentPage
    {
        #region fields

        /// <summary>
        /// Reference to the object of the Animation class.
        /// It allows creating and starting the animation of the radar element.
        /// </summary>
        private Animation _radarAnimation;

        #endregion

        #region methods

        /// <summary>
        /// The page constructor.
        /// Creates page structure defined in the XAML file.
        /// </summary>
        public MainPage()
        {
            InitializeComponent();
        }

        #endregion
    }
}

```



Step 4: Add InitRadarAnimation method, which creates an instance of Animation class. Execute this method in the class constructor.

<highlight>10, 13-20</highlight>

```csharp
#region methods

/// <summary>
/// The page constructor.
/// Creates page structure defined in the XAML file.
/// </summary>
public MainPage()
{
    InitializeComponent();
    InitRadarAnimation();
}

/// <summary>
/// Initializes radar animation.
/// </summary>
private void InitRadarAnimation()
{
    _radarAnimation = new Animation(v => radar.Rotation = v, 0, 360);
}

#endregion

```

Created animation will animate the Rotation property of the radar element in the range from 0 to 360 degrees.



Step 5: Create a private field being a reference to the object of the MainViewModel class.

<highlight>1, 16-21</highlight>

```csharp
using MetalDetector.ViewModels;
using Xamarin.Forms;
using Xamarin.Forms.Xaml;

namespace MetalDetector.Views
{
    /// <summary>
    /// Main (and only one) page of the application.
    /// Handles UI logic for the application.
    /// </summary>
    [XamlCompilation(XamlCompilationOptions.Compile)]
    public partial class MainPage : ContentPage
    {
        #region fields

        /// <summary>
        /// Reference to the object of the MainViewModel class.
        /// It allows listening to the main view model events and executing its commands.
        /// </summary>
        private MainViewModel _mainViewModel;

        /// <summary>
        /// Reference to the object of the Animation class.
        /// It allows creating and starting the animation of the radar element.
        /// </summary>
        private Animation _radarAnimation;

        #endregion

```



Step 6: Implement OnAppearing method, which will be executed when the main page of the application becomes visible. It assigns reference to the MainViewModel to the created private field and executes the StartCommand command of this class.

<highlight>9-19</highlight>

```csharp
/// <summary>
/// Initializes radar animation.
/// </summary>
private void InitRadarAnimation()
{
    _radarAnimation = new Animation(v => radar.Rotation = v, 0, 360);
}

/// <summary>
/// Performs action when the main page appears.
/// Starts metal detector.
/// </summary>
protected override void OnAppearing()
{
    _mainViewModel = (MainViewModel)this.BindingContext;

    _mainViewModel.StartCommand.Execute(null);
}

#endregion

```



Step 7: Implement OnDisappearing method, which will be executed when the main page disappears. It executes the StopCommand command of the MainViewModel class.

<highlight>12-20</highlight>

```csharp
/// <summary>
/// Performs action when the main page appears.
/// Starts metal detector.
/// </summary>
protected override void OnAppearing()
{
    _mainViewModel = (MainViewModel)this.BindingContext;

    _mainViewModel.StartCommand.Execute(null);
}

/// <summary>
/// Performs action when the main page disappears.
/// Stops metal detector.
/// </summary>
protected override void OnDisappearing()
{
    _mainViewModel.StopCommand.Execute(null);
}

#endregion

```



Step 8: Create handler of PropertyChanged event of the MainViewModel class containing IF statement, which checks if the Ready property has changed.

<highlight>2, 51-63, 72</highlight>

```csharp
using MetalDetector.ViewModels;
using System.ComponentModel;
using Xamarin.Forms;
using Xamarin.Forms.Xaml;

namespace MetalDetector.Views
{
    /// <summary>
    /// Main (and only one) page of the application.
    /// Handles UI logic for the application.
    /// </summary>
    [XamlCompilation(XamlCompilationOptions.Compile)]
    public partial class MainPage : ContentPage
    {
        #region fields

        /// <summary>
        /// Reference to the object of the MainViewModel class.
        /// It allows listening to the main view model events and executing its commands.
        /// </summary>
        private MainViewModel _mainViewModel;

        /// <summary>
        /// Reference to the object of the Animation class.
        /// It allows creating and starting the animation of the radar element.
        /// </summary>
        private Animation _radarAnimation;

        #endregion

        #region methods

        /// <summary>
        /// The page constructor.
        /// Creates page structure defined in the XAML file.
        /// </summary>
        public MainPage()
        {
            InitializeComponent();
            InitRadarAnimation();
        }

        /// <summary>
        /// Initializes radar animation.
        /// </summary>
        private void InitRadarAnimation()
        {
            _radarAnimation = new Animation(v => radar.Rotation = v, 0, 360);
        }

        /// <summary>
        /// Handles "PropertyChanged" event of the view model.
        /// Starts radar animation.
        /// </summary>
        /// <param name="sender">Object firing the event.</param>
        /// <param name="e">Event arguments.</param>
        private void OnPropertyChanged(object sender, PropertyChangedEventArgs e)
        {
            if (e.PropertyName == nameof(_mainViewModel.Ready))
            {
            }
        }

        /// <summary>
        /// Performs action when the main page appears.
        /// Starts metal detector.
        /// </summary>
        protected override void OnAppearing()
        {
            _mainViewModel = (MainViewModel)this.BindingContext;

            _mainViewModel.PropertyChanged += OnPropertyChanged;
            _mainViewModel.StartCommand.Execute(null);
        }

```



Step 9: Create StartRadarAnimation method, which launches the radar element animation by executing its Commit method. The animation will last two seconds with the rate of 16 frames per second and linear easing. At the end of the full cycle of the animation the Rotation property of the animated element will be reset to zero and the animation will be restarted. Execute the StartRadarAnimation method when the Ready property has changed.

<highlight>9-16, 26-28</highlight>

```csharp
/// <summary>
/// Initializes radar animation.
/// </summary>
private void InitRadarAnimation()
{
    _radarAnimation = new Animation(v => radar.Rotation = v, 0, 360);
}

/// <summary>
/// Starts radar animation.
/// </summary>
private void StartRadarAnimation()
{
    _radarAnimation.Commit(this, "RadarAnimation", 16, 2000, Easing.Linear, (v, c) => radar.Rotation = 0, () => true);
}

/// <summary>
/// Handles "PropertyChanged" event of the view model.
/// Starts radar animation.
/// </summary>
/// <param name="sender">Object firing the event.</param>
/// <param name="e">Event arguments.</param>
private void OnPropertyChanged(object sender, PropertyChangedEventArgs e)
{
    if (e.PropertyName == nameof(_mainViewModel.Ready))
    {
        StartRadarAnimation();
    }
}

```

# IV. SIGNAL STRENGTH AND DIRECTION INDICATION

## 1. Goal

The goal of this tutorial's part is to implement the metal detector signal strength and direction indication in the application screen.

To achieve this we need to:

At the end of this chapter, the source code of the application will be complete.

## 2. Implementing magnetometer service interface

We have to extend the  **IMagnetometerService**  interface functionality. From now, it will additionally define an Updated event notifying the application that the sensor data has changed. The Updated event provides arguments of  **IMagnetometerDataUpdatedArgs** , which also need to be extended.



Now, we will modify the MetalDetector/Models/IMagnetometerService.cs and MetalDetector/Models/IMagnetometerDataUpdatedArgs.cs files of the project.



Step 1: Define Updated event.

<highlight>1, 10-18</highlight>

```csharp
using System;

namespace MetalDetector.Models
{
    /// <summary>
    /// Interface of magnetometer service which allows obtaining the magnetometer data.
    /// </summary>
    public interface IMagnetometerService
    {
        #region properties

        /// <summary>
        /// Notifies about magnetometer data update.
        /// </summary>
        event EventHandler<IMagnetometerDataUpdatedArgs> Updated;

        #endregion

        #region methods

        /// <summary>
        /// Returns true if the magnetometer is supported, false otherwise.
        /// </summary>
        /// <returns>Flag indicating whether magnetometer is supported or not.</returns>
        bool IsSupported();

        /// <summary>
        /// Starts magnetometer sensor.
        /// </summary>
        void Start();

        /// <summary>
        /// Stops magnetometer sensor.
        /// </summary>
        void Stop();

        #endregion
    }
}

```



Step 2: Define properties of the IMagnetometerDataUpdatedArgs interface.

<highlight>9-26</highlight>

```csharp
namespace MetalDetector.Models
{
    /// <summary>
    /// IMagnetometerDataUpdatedArgs interface class.
    /// Defines properties that should be implemented by class used to notifying about the magnetometer data update.
    /// </summary>
    public interface IMagnetometerDataUpdatedArgs
    {
        #region properties

        /// <summary>
        /// Value of vector x.
        /// </summary>
        float X { get; }

        /// <summary>
        /// Value of vector y.
        /// </summary>
        float Y { get; }

        /// <summary>
        /// Value of vector z.
        /// </summary>
        float Z { get; }

        #endregion
    }
}

```

The IMagnetometerDataUpdatedArgs \*\*\*\* interface defines three properties that can be used to store data provided by the magnetometer sensor.

## 3. Implementing magnetometer service

We have to extend the  **MagnetometerService**  class functionality by implementing Updated event. It will be invoked whenever the magnetometer sensor data changes. The Updated event provides arguments of  **MagnetometerDataUpdatedArgs** class, implementing **IMagnetometerDataUpdatedArgs** interface, which also needs to be extended.



We will modify the MetalDetector.Tizen.Wearable/Service/MagnetometerService.cs and MetalDetector.Tizen.Wearable/Service/MagnetometerDataUpdatedArgs.cs files of the project.



Step 1: Implement the MagnetometerDataUpdatedArgs class.

<highlight>11-45</highlight>

```csharp
using MetalDetector.Models;
using System;

namespace MetalDetector.Tizen.Wearable.Service
{
    /// <summary>
    /// Class defining the structure of the object being the parameter of the MagnetometerDataUpdated event.
    /// </summary>
    class MagnetometerDataUpdatedArgs : EventArgs, IMagnetometerDataUpdatedArgs
    {
        #region properties

        /// <summary>
        /// Value of vector x.
        /// </summary>
        public float X { get; }

        /// <summary>
        /// Value of vector y.
        /// </summary>
        public float Y { get; }

        /// <summary>
        /// Value of vector z.
        /// </summary>
        public float Z { get; }

        #endregion

        #region methods

        /// <summary>
        /// MagnetometerDataUpdatedArgs class constructor.
        /// </summary>
        /// <param name="x">X component of the magnetometer.</param>
        /// <param name="y">Y component of the magnetometer.</param>
        /// <param name="z">Z component of the magnetometer.</param>
        public MagnetometerDataUpdatedArgs(float x, float y, float z)
        {
            X = x;
            Y = y;
            Z = z;
        }

        #endregion
    }
}

```

In the next step on this page we will update the MetalDetector.Tizen.Wearable/Service/MagnetometerService.cs file.



Step 2: Define Updated event.

<highlight>3, 24-32</highlight>

```csharp
using MetalDetector.Models;
using MetalDetector.Tizen.Wearable.Service;
using System;
using Tizen.Sensor;

[assembly: Xamarin.Forms.Dependency(typeof(MagnetometerService))]
namespace MetalDetector.Tizen.Wearable.Service
{
    /// <summary>
    /// Magnetometer service which allows obtaining the magnetometer data.
    /// </summary>
    class MagnetometerService : IMagnetometerService
    {
        #region fields

        /// <summary>
        /// Magnetometer class instance used for registering callbacks for the magnetometer
        /// and getting the magnetometer data.
        /// </summary>
        private Magnetometer _magnetometer;

        #endregion

        #region properties

        /// <summary>
        /// Notifies about magnetometer data update.
        /// </summary>
        public event EventHandler<IMagnetometerDataUpdatedArgs> Updated;

        #endregion

        #region methods

```



Step 3: Create handler of the DataUpdated event provided by the Tizen Magnetometer class.

<highlight>10-20</highlight>

```csharp
/// <summary>
/// Returns true if the magnetometer is supported, false otherwise.
/// </summary>
/// <returns>Flag indicating whether magnetometer is supported or not.</returns>
public bool IsSupported()
{
    return Magnetometer.IsSupported;
}

/// <summary>
/// Handles "DataUpdated" event of the Magnetometer object.
/// Invokes "Updated" event.
/// </summary>
/// <param name="sender">Object firing the event.</param>
/// <param name="e">Event arguments.</param>
private void OnDataUpdated(object sender, MagnetometerDataUpdatedEventArgs e)
{
    Updated?.Invoke(this, new MagnetometerDataUpdatedArgs(e.X, e.Y, e.Z));
}

#endregion

```



Step 4: Attach DataUpdated event handler when the Start method is executed, and detach it when the Stop method is executed.

<highlight>16, 32</highlight>

```csharp
/// <summary>
/// Starts the magnetometer sensor.
/// </summary>
public void Start()
{
    if (!IsSupported())
    {
        return;
    }

    if (_magnetometer.IsSensing)
    {
        return;
    }

    _magnetometer.DataUpdated += OnDataUpdated;
    _magnetometer.Start();
}

/// <summary>
/// Stops the magnetometer sensor.
/// </summary>
public void Stop()
{
    if (!IsSupported())
    {
        return;
    }

    if (_magnetometer.IsSensing)
    {
        _magnetometer.DataUpdated -= OnDataUpdated;
        _magnetometer.Stop();
    }
}

```

## 4. Implementing metal detector model

We have to extend the  **MetalDetectorModel**  class by adding methods that allow the application to perform calculations based on the raw data of the magnetometer sensor. We will implement methods that allow indicating whether something is in the range of the sensor ( **IsInRange** property), how close to the sensor ( **SignalStrength** property) and in what direction from the sensor ( **Rotation** property). In addition, we will calculate the relative value of the signal strength ( **RelativeSignalStrength** property) in the range from 0 to 9 to allow the presentation of signal strength in the form of one of 10 levels.



We will modify the MetalDetector/Models/MetalDetectorModel.cs file of the project.



Step 1: Create private MAX_SIGNAL_STRENGTH const, which stores value representing max signal strength.

<highlight>8-12</highlight>

```csharp
#region fields

/// <summary>
/// Magnometer service which allows obtaining the magnetometer data.
/// </summary>
private IMagnetometerService _iMagnetometerService;

/// <summary>
/// Max signal strength value.
/// </summary>
private const int MAX_SIGNAL_STRENGTH = 5000;

#endregion

```



Step 2: Create a method that returns resultant vector signal strength based on signal strength vectors for each axis.

<highlight>1, 62-74</highlight>

```csharp
using System;
using Xamarin.Forms;

namespace MetalDetector.Models
{
    /// <summary>
    /// Class defining a metal detector model which allows the application to use properties,
    /// describing metal detector state.
    /// </summary>
    public class MetalDetectorModel
    {
        #region fields

        /// <summary>
        /// Magnometer service which allows obtaining the magnetometer data.
        /// </summary>
        private IMagnetometerService _iMagnetometerService;

        /// <summary>
        /// Max signal strength value.
        /// </summary>
        private const int MAX_SIGNAL_STRENGTH = 5000;

        #endregion

        #region methods

        /// <summary>
        /// MagnetometerModel class constructor.
        /// Initializes the model.
        /// </summary>
        public MetalDetectorModel()
        {
            _iMagnetometerService = DependencyService.Get<IMagnetometerService>();
        }

        /// <summary>
        /// Starts metal detector.
        /// </summary>
        public void Start()
        {
            _iMagnetometerService.Start();
        }

        /// <summary>
        /// Stops metal detector.
        /// </summary>
        public void Stop()
        {
            _iMagnetometerService.Stop();
        }

        /// <summary>
        /// Returns true if the metal detector is supported, false otherwise.
        /// </summary>
        /// <returns>Flag indicating whether the metal detector is supported or not.</returns>
        public bool IsSupported()
        {
            return _iMagnetometerService.IsSupported();
        }

        /// <summary>
        /// Returns resultant vector signal strength created from signal strength
        /// vectors for each axis.
        /// </summary>
        /// <param name="x">Value of vector x.</param>
        /// <param name="y">Value of vector y.</param>
        /// <param name="z">Value of vector z.</param>
        /// <returns>Resultant vector signal strength.</returns>
        private double CalculateSignalStrength(float x, float y, float z)
        {
            return Math.Sqrt(Math.Pow(x, 2) + Math.Pow(y, 2) + Math.Pow(z, 2));
        }

        #endregion
    }
}

```



Step 3: Create a method that returns signal strength relative to maximal signal strength in a given interval.

<highlight>14-26</highlight>

```csharp
/// <summary>
/// Returns resultant vector signal strength created from signal strength
/// vectors for each axis.
/// </summary>
/// <param name="x">Value of vector x.</param>
/// <param name="y">Value of vector y.</param>
/// <param name="z">Value of vector z.</param>
/// <returns>Resultant vector signal strength.</returns>
private double CalculateSignalStrength(float x, float y, float z)
{
    return Math.Sqrt(Math.Pow(x, 2) + Math.Pow(y, 2) + Math.Pow(z, 2));
}

/// <summary>
/// Returns signal strength relative to maximal signal strength in
/// interval[0, max]. Uses logarithmic scale.
/// </summary>
/// <param name="value">Signal strength.</param>
/// <param name="max">Max value that can be returned.</param>
/// <returns>Signal strength.</returns>
private int CalculateRelativeSignalStrength(double value, int max)
{
    return (int)Math.Ceiling(value > MAX_SIGNAL_STRENGTH ?
        max : Math.Log(value) / Math.Log(MAX_SIGNAL_STRENGTH) * max);
}

#endregion

```



Step 4: Create a method that returns rotation value in degrees based on electromagnetic strength of x and y axis vectors. It is supported by  **ToDegrees** method which converts the number value expressed in radians to degrees.

<highlight>10-31</highlight>

```csharp
/// <summary>
/// Returns true if the metal detector is supported, false otherwise.
/// </summary>
/// <returns>Flag indicating whether the metal detector is supported or not.</returns>
public bool IsSupported()
{
    return _iMagnetometerService.IsSupported();
}

/// <summary>
/// Converts the number value expressed in radians to degrees.
/// </summary>
/// <param name="value">Value in radians.</param>
/// <returns>Value in degrees.</returns>
private double ToDegrees(double value)
{
    return value * 180 / Math.PI;
}

/// <summary>
/// Returns rotation value in degrees
/// based on electromagnetic strength of x and y axis vectors.
/// </summary>
/// <param name="x">Value of vector x.</param>
/// <param name="y">Value of vector y.</param>
/// <returns>Rotation value in degrees.</returns>
private double CalculateRotation(float x, float y)
{
    return -ToDegrees(Math.Atan2(x, -y));
}

/// <summary>
/// Returns resultant vector signal strength created from signal strength
/// vectors for each axis.
/// </summary>
/// <param name="x">Value of vector x.</param>
/// <param name="y">Value of vector y.</param>
/// <param name="z">Value of vector z.</param>
/// <returns>Resultant vector signal strength.</returns>
private double CalculateSignalStrength(float x, float y, float z)
{
    return Math.Sqrt(Math.Pow(x, 2) + Math.Pow(y, 2) + Math.Pow(z, 2));
}

```



Step 5: Create properties needed to store all calculated values.

<highlight>8-31</highlight>

```csharp
/// <summary>
/// Max signal strength value.
/// </summary>
private const int MAX_SIGNAL_STRENGTH = 5000;

#endregion

#region properties

/// <summary>
/// Indicates if the magnetometer sensor detects something in its range.
/// </summary>
public bool IsInRange { get; private set; }

/// <summary>
/// Strength level value (in range from 0 to 9).
/// </summary>
public int RelativeSignalStrength { get; private set; }

/// <summary>
/// Strength level value.
/// </summary>
public int SignalStrength { get; private set; }

/// <summary>
/// Rotation value of the metal detector indicator.
/// </summary>
public double Rotation { get; private set; }

#endregion

#region methods

```



Step 6: Create handler of Updated event invoked by the magnetometer service.

<highlight>9, 37-55</highlight>

```csharp
/// <summary>
/// MagnetometerModel class constructor.
/// Initializes the model.
/// </summary>
public MetalDetectorModel()
{
    _iMagnetometerService = DependencyService.Get<IMagnetometerService>();

    _iMagnetometerService.Updated += ServiceOnUpdated;
}

/// <summary>
/// Starts metal detector.
/// </summary>
public void Start()
{
    _iMagnetometerService.Start();
}

/// <summary>
/// Stops metal detector.
/// </summary>
public void Stop()
{
    _iMagnetometerService.Stop();
}

/// <summary>
/// Returns true if the metal detector is supported, false otherwise.
/// </summary>
/// <returns>Flag indicating whether the metal detector is supported or not.</returns>
public bool IsSupported()
{
    return _iMagnetometerService.IsSupported();
}

/// <summary>
/// Handles "Updated" event of the magnetometer service.
/// Updates public properties that can be used outside the class.
/// Invokes "Updated" event.
/// </summary>
/// <param name="sender">Object firing the event.</param>
/// <param name="e">Event arguments.</param>
private void ServiceOnUpdated(object sender, IMagnetometerDataUpdatedArgs e)
{
    float x = e.X;
    float y = e.Y;
    float z = e.Z;

    SignalStrength = (int)CalculateSignalStrength(x, y, z);
    RelativeSignalStrength = CalculateRelativeSignalStrength(SignalStrength, 9);
    Rotation = CalculateRotation(x, y);
    IsInRange = (x <= -1 || x >= 1) || (y <= -1 || y >= 1);
}

/// <summary>
/// Converts the number value expressed in radians to degrees.
/// </summary>
/// <param name="value">Value in radians.</param>
/// <returns>Value in degrees.</returns>
private double ToDegrees(double value)
{
    return value * 180 / Math.PI;
}

```

The ServiceOnUpdated handler executes methods responsible for calculations and updates created public properties, which can be accessed outside the class.



Step 7: Create Updated event...

<highlight>3-7</highlight>

```csharp
#region properties

/// <summary>
/// Notifies about changes in metal detector data.
/// </summary>
public event EventHandler Updated;

/// <summary>
/// Indicates if the magnetometer sensor detects something in its range.
/// </summary>
public bool IsInRange { get; private set; }

```

...and invoke it to notify the application that the metal detector model properties are updated.

<highlight>19</highlight>

```csharp
/// <summary>
/// Handles "Updated" event of the magnetometer service.
/// Updates public properties that can be used outside the class.
/// Invokes "Updated" event.
/// </summary>
/// <param name="sender">Object firing the event.</param>
/// <param name="e">Event arguments.</param>
private void ServiceOnUpdated(object sender, IMagnetometerDataUpdatedArgs e)
{
    float x = e.X;
    float y = e.Y;
    float z = e.Z;

    SignalStrength = (int)CalculateSignalStrength(x, y, z);
    RelativeSignalStrength = CalculateRelativeSignalStrength(SignalStrength, 9);
    Rotation = CalculateRotation(x, y);
    IsInRange = (x <= -1 || x >= 1) || (y <= -1 || y >= 1);

    Updated?.Invoke(this, null);
}

```

## 5. Implementing main view model

We have to extend the  **MainViewModel**  class by creating properties in order to bind them later to the visual elements displayed in the application screen. They will store values provided by the metal detector model. We will also listen for the Updated event of the MetalDetectorModel class and use it to update mentioned properties.



We will modify the MetalDetector/ViewModels/MainViewModel.cs file of the project.



Step 1: Create backing fields of the created properties.

<highlight>8-27</highlight>

```csharp
#region fields

/// <summary>
/// Backing field of the Ready property.
/// </summary>
private bool _ready = false;

/// <summary>
/// Backing field of the IsInRange property.
/// </summary>
private bool _isInRange = false;

/// <summary>
/// Backing field of the RelativeSignalStrength property.
/// </summary>
private int _relativeSignalStrength = 0;

/// <summary>
/// Backing field of the SignalStrength property.
/// </summary>
private int _signalStrength = 0;

/// <summary>
/// Backing field of the Rotation property.
/// </summary>
private double _rotation = 0;

/// <summary>
/// Metal detector model which allows the application to use the metal detector data.
/// </summary>
private MetalDetectorModel _metalDetectorModel;

#endregion

```



Step 2: Create public properties for storing data provided by the metal detector model.

<highlight>10-45</highlight>

```csharp
/// <summary>
/// Indicates if the metal detector is ready.
/// </summary>
public bool Ready
{
    private set => SetProperty(ref _ready, value);
    get => _ready;
}

/// <summary>
/// Indicates if the metal detector detects something in its range.
/// </summary>
public bool IsInRange
{
    set => SetProperty(ref _isInRange, value);
    get => _isInRange;
}

/// <summary>
/// Strength level value (in range from 0 to 9).
/// </summary>
public int RelativeSignalStrength
{
    set => SetProperty(ref _relativeSignalStrength, value);
    get => _relativeSignalStrength;
}

/// <summary>
/// Strength level value.
/// </summary>
public int SignalStrength
{
    set => SetProperty(ref _signalStrength, value);
    get => _signalStrength;
}

/// <summary>
/// Rotation value of the metal detector indicator.
/// </summary>
public double Rotation
{
    set => SetProperty(ref _rotation, value);
    get => _rotation;
}

#endregion

```



Step 3: Create handler of the Updated event of the metal detector model class and update values of all created properties.

<highlight>2, 119, 151-164</highlight>

```csharp
using MetalDetector.Models;
using System;
using System.Windows.Input;
using Xamarin.Forms;

namespace MetalDetector.ViewModels
{
    /// <summary>
    /// Main view model class for the application.
    /// Encapsulates presentation logic and state of the application.
    /// </summary>
    public class MainViewModel : ViewModelBase
    {
        #region fields

        /// <summary>
        /// Backing field of the Ready property.
        /// </summary>
        private bool _ready = false;

        // <summary>
        /// Backing field of the IsInRange property.
        /// </summary>
        private bool _isInRange = false;

        // <summary>
        /// Backing field of the RelativeSignalStrength property.
        /// </summary>
        private int _relativeSignalStrength = 0;

        // <summary>
        /// Backing field of the SignalStrength property.
        /// </summary>
        private int _signalStrength = 0;

        // <summary>
        /// Backing field of the Rotation property.
        /// </summary>
        private double _rotation = 0;

        /// <summary>
        /// Metal detector model which allows the application to use the metal detector data.
        /// </summary>
        private MetalDetectorModel _metalDetectorModel;

        #endregion

        #region properties

        /// <summary>
        /// Command which starts metal detector.
        /// </summary>
        public ICommand StartCommand { get; private set; }

        /// <summary>
        /// Command which stops metal detector.
        /// </summary>
        public ICommand StopCommand { get; private set; }

        /// <summary>
        /// Indicates if the metal detector is ready.
        /// </summary>
        public bool Ready
        {
            private set => SetProperty(ref _ready, value);
            get => _ready;
        }

        /// <summary>
        /// Indicates if the metal detector detects something in its range.
        /// </summary>
        public bool IsInRange
        {
            set => SetProperty(ref _isInRange, value);
            get => _isInRange;
        }

        /// <summary>
        /// Strength level value (in range from 0 to 9).
        /// </summary>
        public int RelativeSignalStrength
        {
            set => SetProperty(ref _relativeSignalStrength, value);
            get => _relativeSignalStrength;
        }

        /// <summary>
        /// Strength level value.
        /// </summary>
        public int SignalStrength
        {
            set => SetProperty(ref _signalStrength, value);
            get => _signalStrength;
        }

        /// <summary>
        /// Rotation value of the metal detector indicator.
        /// </summary>
        public double Rotation
        {
            set => SetProperty(ref _rotation, value);
            get => _rotation;
        }

        #endregion

        #region methods

        /// <summary>
        /// MainViewModel class constructor.
        /// Initializes the view model.
        /// </summary>
        public MainViewModel()
        {
            _metalDetectorModel = new MetalDetectorModel();

            InitCommands();

            _metalDetectorModel.Updated += ModelOnMetalDetectorDataUpdated;
        }

        /// <summary>
        /// Initializes view model's commands.
        /// </summary>
        private void InitCommands()
        {
            StartCommand = new Command(ExecuteStart);
            StopCommand = new Command(ExecuteStop);
        }

        /// <summary>
        /// Starts the metal detector.
        /// </summary>
        private void ExecuteStart()
        {
            if (_metalDetectorModel.IsSupported())
            {
                _metalDetectorModel.Start();
                Ready = true;
            }
        }

        /// <summary>
        /// Stops the metal detector.
        /// </summary>
        private void ExecuteStop()
        {
            _metalDetectorModel.Stop();
        }

        /// <summary>
        /// Handles "Updated" event of the metal detector model.
        /// Updates properties bound to the application UI.
        /// </summary>
        /// <param name="sender">Object firing the event.</param>
        /// <param name="e">Event arguments.</param>
        private void ModelOnMetalDetectorDataUpdated(object sender, EventArgs e)
        {
            IsInRange = _metalDetectorModel.IsInRange;
            RelativeSignalStrength = _metalDetectorModel.RelativeSignalStrength;
            SignalStrength = _metalDetectorModel.SignalStrength;
            Rotation = _metalDetectorModel.Rotation;
        }

        #endregion
    }
}

```



## 6. Implementing converter

We have to extend the  **MainPage.xaml**  file by creating bindings to public properties of the  **MainViewModel** class. As a result, the application screen will be notified about every changes taking place in the application model.



We will modify the MetalDetector/Views/MainPage.xaml file of the project.



Step 1: Create binding to source of the image responsible for signal strength indication. This binding uses  **StrengthLevelToFileNameConverter** class, which also should be initialized.

<highlight>4, 7-12, 26-28</highlight>

```xml
<?xml version="1.0" encoding="utf-8" ?>
<ContentPage xmlns="http://xamarin.com/schemas/2014/forms"
             xmlns:x="http://schemas.microsoft.com/winfx/2009/xaml"
             xmlns:converters="clr-namespace:MetalDetector.Converters;assembly=MetalDetector"
             x:Class="MetalDetector.Views.MainPage">

    <ContentPage.Resources>
        <ResourceDictionary>
            <converters:StrengthLevelToFileNameConverter x:Key="strengthLevelToFileNameConverter" />
        </ResourceDictionary>
    </ContentPage.Resources>

    <ContentPage.Content>
        <AbsoluteLayout VerticalOptions="FillAndExpand"
                        HorizontalOptions="FillAndExpand">

            <Image AbsoluteLayout.LayoutFlags="All"
                   AbsoluteLayout.LayoutBounds="0, 0, 1, 1"
                   Source="background.png" />

            <AbsoluteLayout AbsoluteLayout.LayoutFlags="All"
                            AbsoluteLayout.LayoutBounds="0, 0, 1, 1">

                <Image AbsoluteLayout.LayoutFlags="All"
                       AbsoluteLayout.LayoutBounds="0, 0, 1, 1"
                       IsVisible="{Binding IsInRange}"
                       Source="{Binding RelativeSignalStrength, Converter={StaticResource strengthLevelToFileNameConverter}}"
                       Rotation="{Binding Rotation}" />

                <Image AbsoluteLayout.LayoutFlags="All"
                       AbsoluteLayout.LayoutBounds="0, 0, 1, 1"
                       Source="text.png" />

```



Step 2: Create binding to the source of the image responsible for signal direction indication.

<highlight>8-18</highlight>

```xml
<Image x:Name="radar"
       AbsoluteLayout.LayoutFlags="All"
       AbsoluteLayout.LayoutBounds="0, 0, 1, 1"
       Source="radar.png" />

<Image AbsoluteLayout.LayoutFlags="All"
       AbsoluteLayout.LayoutBounds="0, 0, 1, 1"
       Source="signal_direction_indicator_off.png"
       Rotation="{Binding Rotation}">
    <Image.Triggers>
        <DataTrigger Binding="{Binding IsInRange}"
                     TargetType="Image"
                     Value="True">
            <Setter Property="Source"
                    Value="signal_direction_indicator_on.png" />
        </DataTrigger>
    </Image.Triggers>
</Image>

<StackLayout AbsoluteLayout.LayoutBounds="0, 154, 360, AutoSize"
             HorizontalOptions="FillAndExpand">
    <Label FontSize="10"
           HorizontalOptions="Center"
           Text="0"
           TextColor="White" />
</StackLayout>

```



Step 3: Create binding to the text property of the label located in the middle of the application screen, which displays signal strength value.

<highlight>5</highlight>

```xml
<StackLayout AbsoluteLayout.LayoutBounds="0, 154, 360, AutoSize"
             HorizontalOptions="FillAndExpand">
    <Label FontSize="10"
           HorizontalOptions="Center"
           Text="{Binding SignalStrength}"
           TextColor="White" />
</StackLayout>

<StackLayout AbsoluteLayout.LayoutBounds="0, 186, 360, AutoSize"
             HorizontalOptions="FillAndExpand">
    <Label FontSize="7"
           HorizontalOptions="Center"
           Text="µT"
           TextColor="White" />
</StackLayout>

```



Right now the application can be run on the emulator or target device. The values displayed by the application should change depending on the position of the device in relation to metal objects in its immediate vicinity.



<img src="/assets/images/tutorials/104/metal-detector-final.PNG" style="height:544px; width:400px"/>



Implementing the indication of the metal detector signal strength and direction, was the last thing we had to do.

The application is now fully functional. Enjoy it.

## 7. Implementing view

We have to implement  **StrengthLevelToFileNameConverter**  class which allows the application to a convert given strength level value to corresponding image file name.



We will modify the MetalDetector/Converters/StrengthLevelToFileNameConverter.cs file of the project.



Step 1: Create private FILENAME_TEMPLATE const field and implement Convert method of the StrengthLevelToFileNameConverter class.

<highlight>12-20, 33</highlight>

```csharp
using System;
using System.Globalization;
using Xamarin.Forms;

namespace MetalDetector.Converters
{
    /// <summary>
    /// Class to convert strength level to corresponding image file name.
    /// </summary>
    public class StrengthLevelToFileNameConverter : IValueConverter
    {
        #region fields

        /// <summary>
        /// Filename template.
        /// </summary>
        private const string FILENAME_TEMPLATE = "signal_strength_{0}.png";

        #endregion

        #region methods

        /// <summary>
        /// Converts strength level to corresponding image file name.
        /// </summary>
        /// <param name="value">Value to be converted.</param>
        /// <param name="targetType">Type of the data binding target property.</param>
        /// <param name="parameter">Optional conversion parameter.</param>
        /// <param name="culture">CultureInfo object allowing culture specific conversion.</param>
        /// <returns>String representing converted date.</returns>
        public object Convert(object value, Type targetType, object parameter, CultureInfo culture)
        {
            return String.Format(FILENAME_TEMPLATE, (int)value);
        }

        /// <summary>
        /// Converts back image file name to strength level.
        /// Not required by the application, so it is not implemented.
        /// </summary>
        /// <param name="value">Value to be converted back.</param>
        /// <param name="targetType">Type of the data binding target property.</param>
        /// <param name="parameter">Optional conversion parameter.</param>
        /// <param name="culture">CultureInfo object allowing culture specific conversion.</param>
        /// <returns>Date object representing converted string.</returns>
        public object ConvertBack(object value, Type targetType, object parameter, CultureInfo culture)
        {
            throw new NotImplementedException();
        }

        #endregion
    }
}

```
